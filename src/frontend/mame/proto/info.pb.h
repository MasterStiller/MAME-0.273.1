// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_info_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_info_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_info_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_info_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_info_2eproto;
namespace infoprotobuf {
class adjuster;
class adjusterDefaultTypeInternal;
extern adjusterDefaultTypeInternal _adjuster_default_instance_;
class biosset;
class biossetDefaultTypeInternal;
extern biossetDefaultTypeInternal _biosset_default_instance_;
class chip;
class chipDefaultTypeInternal;
extern chipDefaultTypeInternal _chip_default_instance_;
class condition;
class conditionDefaultTypeInternal;
extern conditionDefaultTypeInternal _condition_default_instance_;
class configuration;
class configurationDefaultTypeInternal;
extern configurationDefaultTypeInternal _configuration_default_instance_;
class configuration_ConfLocation;
class configuration_ConfLocationDefaultTypeInternal;
extern configuration_ConfLocationDefaultTypeInternal _configuration_ConfLocation_default_instance_;
class configuration_ConfSetting;
class configuration_ConfSettingDefaultTypeInternal;
extern configuration_ConfSettingDefaultTypeInternal _configuration_ConfSetting_default_instance_;
class device;
class deviceDefaultTypeInternal;
extern deviceDefaultTypeInternal _device_default_instance_;
class device_DeviceInstance;
class device_DeviceInstanceDefaultTypeInternal;
extern device_DeviceInstanceDefaultTypeInternal _device_DeviceInstance_default_instance_;
class device_Extension;
class device_ExtensionDefaultTypeInternal;
extern device_ExtensionDefaultTypeInternal _device_Extension_default_instance_;
class device_ref;
class device_refDefaultTypeInternal;
extern device_refDefaultTypeInternal _device_ref_default_instance_;
class dipswitch;
class dipswitchDefaultTypeInternal;
extern dipswitchDefaultTypeInternal _dipswitch_default_instance_;
class dipswitch_DipLocation;
class dipswitch_DipLocationDefaultTypeInternal;
extern dipswitch_DipLocationDefaultTypeInternal _dipswitch_DipLocation_default_instance_;
class dipswitch_DipValue;
class dipswitch_DipValueDefaultTypeInternal;
extern dipswitch_DipValueDefaultTypeInternal _dipswitch_DipValue_default_instance_;
class disk;
class diskDefaultTypeInternal;
extern diskDefaultTypeInternal _disk_default_instance_;
class display;
class displayDefaultTypeInternal;
extern displayDefaultTypeInternal _display_default_instance_;
class driver;
class driverDefaultTypeInternal;
extern driverDefaultTypeInternal _driver_default_instance_;
class feature;
class featureDefaultTypeInternal;
extern featureDefaultTypeInternal _feature_default_instance_;
class hashes;
class hashesDefaultTypeInternal;
extern hashesDefaultTypeInternal _hashes_default_instance_;
class input;
class inputDefaultTypeInternal;
extern inputDefaultTypeInternal _input_default_instance_;
class input_Control;
class input_ControlDefaultTypeInternal;
extern input_ControlDefaultTypeInternal _input_Control_default_instance_;
class machine;
class machineDefaultTypeInternal;
extern machineDefaultTypeInternal _machine_default_instance_;
class mame;
class mameDefaultTypeInternal;
extern mameDefaultTypeInternal _mame_default_instance_;
class port;
class portDefaultTypeInternal;
extern portDefaultTypeInternal _port_default_instance_;
class port_Analog;
class port_AnalogDefaultTypeInternal;
extern port_AnalogDefaultTypeInternal _port_Analog_default_instance_;
class ramoption;
class ramoptionDefaultTypeInternal;
extern ramoptionDefaultTypeInternal _ramoption_default_instance_;
class rom;
class romDefaultTypeInternal;
extern romDefaultTypeInternal _rom_default_instance_;
class sample;
class sampleDefaultTypeInternal;
extern sampleDefaultTypeInternal _sample_default_instance_;
class slot;
class slotDefaultTypeInternal;
extern slotDefaultTypeInternal _slot_default_instance_;
class slot_SlotOption;
class slot_SlotOptionDefaultTypeInternal;
extern slot_SlotOptionDefaultTypeInternal _slot_SlotOption_default_instance_;
class softwarelist;
class softwarelistDefaultTypeInternal;
extern softwarelistDefaultTypeInternal _softwarelist_default_instance_;
class sound;
class soundDefaultTypeInternal;
extern soundDefaultTypeInternal _sound_default_instance_;
}  // namespace infoprotobuf
PROTOBUF_NAMESPACE_OPEN
template<> ::infoprotobuf::adjuster* Arena::CreateMaybeMessage<::infoprotobuf::adjuster>(Arena*);
template<> ::infoprotobuf::biosset* Arena::CreateMaybeMessage<::infoprotobuf::biosset>(Arena*);
template<> ::infoprotobuf::chip* Arena::CreateMaybeMessage<::infoprotobuf::chip>(Arena*);
template<> ::infoprotobuf::condition* Arena::CreateMaybeMessage<::infoprotobuf::condition>(Arena*);
template<> ::infoprotobuf::configuration* Arena::CreateMaybeMessage<::infoprotobuf::configuration>(Arena*);
template<> ::infoprotobuf::configuration_ConfLocation* Arena::CreateMaybeMessage<::infoprotobuf::configuration_ConfLocation>(Arena*);
template<> ::infoprotobuf::configuration_ConfSetting* Arena::CreateMaybeMessage<::infoprotobuf::configuration_ConfSetting>(Arena*);
template<> ::infoprotobuf::device* Arena::CreateMaybeMessage<::infoprotobuf::device>(Arena*);
template<> ::infoprotobuf::device_DeviceInstance* Arena::CreateMaybeMessage<::infoprotobuf::device_DeviceInstance>(Arena*);
template<> ::infoprotobuf::device_Extension* Arena::CreateMaybeMessage<::infoprotobuf::device_Extension>(Arena*);
template<> ::infoprotobuf::device_ref* Arena::CreateMaybeMessage<::infoprotobuf::device_ref>(Arena*);
template<> ::infoprotobuf::dipswitch* Arena::CreateMaybeMessage<::infoprotobuf::dipswitch>(Arena*);
template<> ::infoprotobuf::dipswitch_DipLocation* Arena::CreateMaybeMessage<::infoprotobuf::dipswitch_DipLocation>(Arena*);
template<> ::infoprotobuf::dipswitch_DipValue* Arena::CreateMaybeMessage<::infoprotobuf::dipswitch_DipValue>(Arena*);
template<> ::infoprotobuf::disk* Arena::CreateMaybeMessage<::infoprotobuf::disk>(Arena*);
template<> ::infoprotobuf::display* Arena::CreateMaybeMessage<::infoprotobuf::display>(Arena*);
template<> ::infoprotobuf::driver* Arena::CreateMaybeMessage<::infoprotobuf::driver>(Arena*);
template<> ::infoprotobuf::feature* Arena::CreateMaybeMessage<::infoprotobuf::feature>(Arena*);
template<> ::infoprotobuf::hashes* Arena::CreateMaybeMessage<::infoprotobuf::hashes>(Arena*);
template<> ::infoprotobuf::input* Arena::CreateMaybeMessage<::infoprotobuf::input>(Arena*);
template<> ::infoprotobuf::input_Control* Arena::CreateMaybeMessage<::infoprotobuf::input_Control>(Arena*);
template<> ::infoprotobuf::machine* Arena::CreateMaybeMessage<::infoprotobuf::machine>(Arena*);
template<> ::infoprotobuf::mame* Arena::CreateMaybeMessage<::infoprotobuf::mame>(Arena*);
template<> ::infoprotobuf::port* Arena::CreateMaybeMessage<::infoprotobuf::port>(Arena*);
template<> ::infoprotobuf::port_Analog* Arena::CreateMaybeMessage<::infoprotobuf::port_Analog>(Arena*);
template<> ::infoprotobuf::ramoption* Arena::CreateMaybeMessage<::infoprotobuf::ramoption>(Arena*);
template<> ::infoprotobuf::rom* Arena::CreateMaybeMessage<::infoprotobuf::rom>(Arena*);
template<> ::infoprotobuf::sample* Arena::CreateMaybeMessage<::infoprotobuf::sample>(Arena*);
template<> ::infoprotobuf::slot* Arena::CreateMaybeMessage<::infoprotobuf::slot>(Arena*);
template<> ::infoprotobuf::slot_SlotOption* Arena::CreateMaybeMessage<::infoprotobuf::slot_SlotOption>(Arena*);
template<> ::infoprotobuf::softwarelist* Arena::CreateMaybeMessage<::infoprotobuf::softwarelist>(Arena*);
template<> ::infoprotobuf::sound* Arena::CreateMaybeMessage<::infoprotobuf::sound>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace infoprotobuf {

enum condition_condition_relation : int {
  condition_condition_relation_eq = 1,
  condition_condition_relation_ne = 2,
  condition_condition_relation_gt = 3,
  condition_condition_relation_le = 4,
  condition_condition_relation_lt = 5,
  condition_condition_relation_ge = 6
};
bool condition_condition_relation_IsValid(int value);
constexpr condition_condition_relation condition_condition_relation_condition_relation_MIN = condition_condition_relation_eq;
constexpr condition_condition_relation condition_condition_relation_condition_relation_MAX = condition_condition_relation_ge;
constexpr int condition_condition_relation_condition_relation_ARRAYSIZE = condition_condition_relation_condition_relation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* condition_condition_relation_descriptor();
template<typename T>
inline const std::string& condition_condition_relation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, condition_condition_relation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function condition_condition_relation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    condition_condition_relation_descriptor(), enum_t_value);
}
inline bool condition_condition_relation_Parse(
    const std::string& name, condition_condition_relation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<condition_condition_relation>(
    condition_condition_relation_descriptor(), name, value);
}
enum driver_driver_status : int {
  driver_driver_status_good = 1,
  driver_driver_status_imperfect = 2,
  driver_driver_status_preliminary = 3
};
bool driver_driver_status_IsValid(int value);
constexpr driver_driver_status driver_driver_status_driver_status_MIN = driver_driver_status_good;
constexpr driver_driver_status driver_driver_status_driver_status_MAX = driver_driver_status_preliminary;
constexpr int driver_driver_status_driver_status_ARRAYSIZE = driver_driver_status_driver_status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* driver_driver_status_descriptor();
template<typename T>
inline const std::string& driver_driver_status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, driver_driver_status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function driver_driver_status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    driver_driver_status_descriptor(), enum_t_value);
}
inline bool driver_driver_status_Parse(
    const std::string& name, driver_driver_status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<driver_driver_status>(
    driver_driver_status_descriptor(), name, value);
}
enum driver_Supported : int {
  driver_Supported_supported = 1,
  driver_Supported_unsupported = 2
};
bool driver_Supported_IsValid(int value);
constexpr driver_Supported driver_Supported_Supported_MIN = driver_Supported_supported;
constexpr driver_Supported driver_Supported_Supported_MAX = driver_Supported_unsupported;
constexpr int driver_Supported_Supported_ARRAYSIZE = driver_Supported_Supported_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* driver_Supported_descriptor();
template<typename T>
inline const std::string& driver_Supported_Name(T enum_t_value) {
  static_assert(::std::is_same<T, driver_Supported>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function driver_Supported_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    driver_Supported_descriptor(), enum_t_value);
}
inline bool driver_Supported_Parse(
    const std::string& name, driver_Supported* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<driver_Supported>(
    driver_Supported_descriptor(), name, value);
}
enum feature_Type : int {
  feature_Type_protection = 1,
  feature_Type_timing = 2,
  feature_Type_graphics = 3,
  feature_Type_palette = 4,
  feature_Type_sound = 5,
  feature_Type_capture = 6,
  feature_Type_camera = 7,
  feature_Type_microphone = 8,
  feature_Type_controls = 9,
  feature_Type_keyboard = 10,
  feature_Type_mouse = 11,
  feature_Type_media = 12,
  feature_Type_disk = 13,
  feature_Type_printer = 14,
  feature_Type_tape = 15,
  feature_Type_punch = 16,
  feature_Type_drum = 17,
  feature_Type_rom = 18,
  feature_Type_comms = 19,
  feature_Type_lan = 20,
  feature_Type_wan = 21
};
bool feature_Type_IsValid(int value);
constexpr feature_Type feature_Type_Type_MIN = feature_Type_protection;
constexpr feature_Type feature_Type_Type_MAX = feature_Type_wan;
constexpr int feature_Type_Type_ARRAYSIZE = feature_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* feature_Type_descriptor();
template<typename T>
inline const std::string& feature_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, feature_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function feature_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    feature_Type_descriptor(), enum_t_value);
}
inline bool feature_Type_Parse(
    const std::string& name, feature_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<feature_Type>(
    feature_Type_descriptor(), name, value);
}
enum feature_feature_status : int {
  feature_feature_status_unemulated = 1,
  feature_feature_status_imperfect = 2
};
bool feature_feature_status_IsValid(int value);
constexpr feature_feature_status feature_feature_status_feature_status_MIN = feature_feature_status_unemulated;
constexpr feature_feature_status feature_feature_status_feature_status_MAX = feature_feature_status_imperfect;
constexpr int feature_feature_status_feature_status_ARRAYSIZE = feature_feature_status_feature_status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* feature_feature_status_descriptor();
template<typename T>
inline const std::string& feature_feature_status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, feature_feature_status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function feature_feature_status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    feature_feature_status_descriptor(), enum_t_value);
}
inline bool feature_feature_status_Parse(
    const std::string& name, feature_feature_status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<feature_feature_status>(
    feature_feature_status_descriptor(), name, value);
}
enum softwarelist_Status : int {
  softwarelist_Status_original = 0,
  softwarelist_Status_compatibile = 1
};
bool softwarelist_Status_IsValid(int value);
constexpr softwarelist_Status softwarelist_Status_Status_MIN = softwarelist_Status_original;
constexpr softwarelist_Status softwarelist_Status_Status_MAX = softwarelist_Status_compatibile;
constexpr int softwarelist_Status_Status_ARRAYSIZE = softwarelist_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* softwarelist_Status_descriptor();
template<typename T>
inline const std::string& softwarelist_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, softwarelist_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function softwarelist_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    softwarelist_Status_descriptor(), enum_t_value);
}
inline bool softwarelist_Status_Parse(
    const std::string& name, softwarelist_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<softwarelist_Status>(
    softwarelist_Status_descriptor(), name, value);
}
enum display_type : int {
  rastar = 1,
  vector = 2,
  lcd = 3,
  svg = 4,
  unknown = 5
};
bool display_type_IsValid(int value);
constexpr display_type display_type_MIN = rastar;
constexpr display_type display_type_MAX = unknown;
constexpr int display_type_ARRAYSIZE = display_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* display_type_descriptor();
template<typename T>
inline const std::string& display_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, display_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function display_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    display_type_descriptor(), enum_t_value);
}
inline bool display_type_Parse(
    const std::string& name, display_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<display_type>(
    display_type_descriptor(), name, value);
}
enum display_rotation : int {
  deg0 = 1,
  deg90 = 2,
  deg180 = 3,
  deg270 = 4
};
bool display_rotation_IsValid(int value);
constexpr display_rotation display_rotation_MIN = deg0;
constexpr display_rotation display_rotation_MAX = deg270;
constexpr int display_rotation_ARRAYSIZE = display_rotation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* display_rotation_descriptor();
template<typename T>
inline const std::string& display_rotation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, display_rotation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function display_rotation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    display_rotation_descriptor(), enum_t_value);
}
inline bool display_rotation_Parse(
    const std::string& name, display_rotation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<display_rotation>(
    display_rotation_descriptor(), name, value);
}
enum status : int {
  baddump = 1,
  nodump = 2,
  good = 3
};
bool status_IsValid(int value);
constexpr status status_MIN = baddump;
constexpr status status_MAX = good;
constexpr int status_ARRAYSIZE = status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* status_descriptor();
template<typename T>
inline const std::string& status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    status_descriptor(), enum_t_value);
}
inline bool status_Parse(
    const std::string& name, status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<status>(
    status_descriptor(), name, value);
}
enum chip_type : int {
  cpu = 1,
  audio = 2
};
bool chip_type_IsValid(int value);
constexpr chip_type chip_type_MIN = cpu;
constexpr chip_type chip_type_MAX = audio;
constexpr int chip_type_ARRAYSIZE = chip_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* chip_type_descriptor();
template<typename T>
inline const std::string& chip_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, chip_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function chip_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    chip_type_descriptor(), enum_t_value);
}
inline bool chip_type_Parse(
    const std::string& name, chip_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<chip_type>(
    chip_type_descriptor(), name, value);
}
// ===================================================================

class mame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.mame) */ {
 public:
  inline mame() : mame(nullptr) {};
  virtual ~mame();

  mame(const mame& from);
  mame(mame&& from) noexcept
    : mame() {
    *this = ::std::move(from);
  }

  inline mame& operator=(const mame& from) {
    CopyFrom(from);
    return *this;
  }
  inline mame& operator=(mame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const mame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mame* internal_default_instance() {
    return reinterpret_cast<const mame*>(
               &_mame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(mame& a, mame& b) {
    a.Swap(&b);
  }
  inline void Swap(mame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mame* New() const final {
    return CreateMaybeMessage<mame>(nullptr);
  }

  mame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const mame& from);
  void MergeFrom(const mame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.mame";
  }
  protected:
  explicit mame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineFieldNumber = 4,
    kBuildFieldNumber = 1,
    kDebugFieldNumber = 2,
    kMameconfigFieldNumber = 3,
  };
  // repeated .infoprotobuf.machine machine = 4;
  int machine_size() const;
  private:
  int _internal_machine_size() const;
  public:
  void clear_machine();
  ::infoprotobuf::machine* mutable_machine(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::machine >*
      mutable_machine();
  private:
  const ::infoprotobuf::machine& _internal_machine(int index) const;
  ::infoprotobuf::machine* _internal_add_machine();
  public:
  const ::infoprotobuf::machine& machine(int index) const;
  ::infoprotobuf::machine* add_machine();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::machine >&
      machine() const;

  // optional string build = 1;
  bool has_build() const;
  private:
  bool _internal_has_build() const;
  public:
  void clear_build();
  const std::string& build() const;
  void set_build(const std::string& value);
  void set_build(std::string&& value);
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  std::string* mutable_build();
  std::string* release_build();
  void set_allocated_build(std::string* build);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_build();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_build(
      std::string* build);
  private:
  const std::string& _internal_build() const;
  void _internal_set_build(const std::string& value);
  std::string* _internal_mutable_build();
  public:

  // optional bool debug = 2 [default = false];
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // required uint32 mameconfig = 3;
  bool has_mameconfig() const;
  private:
  bool _internal_has_mameconfig() const;
  public:
  void clear_mameconfig();
  ::PROTOBUF_NAMESPACE_ID::uint32 mameconfig() const;
  void set_mameconfig(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mameconfig() const;
  void _internal_set_mameconfig(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.mame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::machine > machine_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_;
  bool debug_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mameconfig_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class machine PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.machine) */ {
 public:
  inline machine() : machine(nullptr) {};
  virtual ~machine();

  machine(const machine& from);
  machine(machine&& from) noexcept
    : machine() {
    *this = ::std::move(from);
  }

  inline machine& operator=(const machine& from) {
    CopyFrom(from);
    return *this;
  }
  inline machine& operator=(machine&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const machine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const machine* internal_default_instance() {
    return reinterpret_cast<const machine*>(
               &_machine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(machine& a, machine& b) {
    a.Swap(&b);
  }
  inline void Swap(machine* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(machine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline machine* New() const final {
    return CreateMaybeMessage<machine>(nullptr);
  }

  machine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<machine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const machine& from);
  void MergeFrom(const machine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(machine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.machine";
  }
  protected:
  explicit machine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBiossetFieldNumber = 13,
    kRomFieldNumber = 14,
    kDiskFieldNumber = 15,
    kDeviceRefFieldNumber = 16,
    kSampleFieldNumber = 17,
    kChipFieldNumber = 18,
    kDisplayFieldNumber = 19,
    kDipswitchFieldNumber = 22,
    kConfigurationFieldNumber = 23,
    kPortFieldNumber = 24,
    kAdjusterFieldNumber = 25,
    kDriverFieldNumber = 26,
    kFeatureFieldNumber = 27,
    kDeviceFieldNumber = 28,
    kSlotFieldNumber = 29,
    kSoftwarelistFieldNumber = 30,
    kRamoptionFieldNumber = 31,
    kNameFieldNumber = 1,
    kSourcefileFieldNumber = 2,
    kCloneofFieldNumber = 7,
    kRomofFieldNumber = 8,
    kSampleofFieldNumber = 9,
    kDescriptionFieldNumber = 10,
    kYearFieldNumber = 11,
    kManufacturerFieldNumber = 12,
    kSoundFieldNumber = 20,
    kInputFieldNumber = 21,
    kIsbiosFieldNumber = 3,
    kIsdeviceFieldNumber = 4,
    kIsmechanicalFieldNumber = 5,
    kRunnableFieldNumber = 6,
  };
  // repeated .infoprotobuf.biosset biosset = 13;
  int biosset_size() const;
  private:
  int _internal_biosset_size() const;
  public:
  void clear_biosset();
  ::infoprotobuf::biosset* mutable_biosset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::biosset >*
      mutable_biosset();
  private:
  const ::infoprotobuf::biosset& _internal_biosset(int index) const;
  ::infoprotobuf::biosset* _internal_add_biosset();
  public:
  const ::infoprotobuf::biosset& biosset(int index) const;
  ::infoprotobuf::biosset* add_biosset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::biosset >&
      biosset() const;

  // repeated .infoprotobuf.rom rom = 14;
  int rom_size() const;
  private:
  int _internal_rom_size() const;
  public:
  void clear_rom();
  ::infoprotobuf::rom* mutable_rom(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::rom >*
      mutable_rom();
  private:
  const ::infoprotobuf::rom& _internal_rom(int index) const;
  ::infoprotobuf::rom* _internal_add_rom();
  public:
  const ::infoprotobuf::rom& rom(int index) const;
  ::infoprotobuf::rom* add_rom();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::rom >&
      rom() const;

  // repeated .infoprotobuf.disk disk = 15;
  int disk_size() const;
  private:
  int _internal_disk_size() const;
  public:
  void clear_disk();
  ::infoprotobuf::disk* mutable_disk(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::disk >*
      mutable_disk();
  private:
  const ::infoprotobuf::disk& _internal_disk(int index) const;
  ::infoprotobuf::disk* _internal_add_disk();
  public:
  const ::infoprotobuf::disk& disk(int index) const;
  ::infoprotobuf::disk* add_disk();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::disk >&
      disk() const;

  // repeated .infoprotobuf.device_ref device_ref = 16;
  int device_ref_size() const;
  private:
  int _internal_device_ref_size() const;
  public:
  void clear_device_ref();
  ::infoprotobuf::device_ref* mutable_device_ref(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_ref >*
      mutable_device_ref();
  private:
  const ::infoprotobuf::device_ref& _internal_device_ref(int index) const;
  ::infoprotobuf::device_ref* _internal_add_device_ref();
  public:
  const ::infoprotobuf::device_ref& device_ref(int index) const;
  ::infoprotobuf::device_ref* add_device_ref();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_ref >&
      device_ref() const;

  // repeated .infoprotobuf.sample sample = 17;
  int sample_size() const;
  private:
  int _internal_sample_size() const;
  public:
  void clear_sample();
  ::infoprotobuf::sample* mutable_sample(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::sample >*
      mutable_sample();
  private:
  const ::infoprotobuf::sample& _internal_sample(int index) const;
  ::infoprotobuf::sample* _internal_add_sample();
  public:
  const ::infoprotobuf::sample& sample(int index) const;
  ::infoprotobuf::sample* add_sample();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::sample >&
      sample() const;

  // repeated .infoprotobuf.chip chip = 18;
  int chip_size() const;
  private:
  int _internal_chip_size() const;
  public:
  void clear_chip();
  ::infoprotobuf::chip* mutable_chip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::chip >*
      mutable_chip();
  private:
  const ::infoprotobuf::chip& _internal_chip(int index) const;
  ::infoprotobuf::chip* _internal_add_chip();
  public:
  const ::infoprotobuf::chip& chip(int index) const;
  ::infoprotobuf::chip* add_chip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::chip >&
      chip() const;

  // repeated .infoprotobuf.display display = 19;
  int display_size() const;
  private:
  int _internal_display_size() const;
  public:
  void clear_display();
  ::infoprotobuf::display* mutable_display(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::display >*
      mutable_display();
  private:
  const ::infoprotobuf::display& _internal_display(int index) const;
  ::infoprotobuf::display* _internal_add_display();
  public:
  const ::infoprotobuf::display& display(int index) const;
  ::infoprotobuf::display* add_display();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::display >&
      display() const;

  // repeated .infoprotobuf.dipswitch dipswitch = 22;
  int dipswitch_size() const;
  private:
  int _internal_dipswitch_size() const;
  public:
  void clear_dipswitch();
  ::infoprotobuf::dipswitch* mutable_dipswitch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch >*
      mutable_dipswitch();
  private:
  const ::infoprotobuf::dipswitch& _internal_dipswitch(int index) const;
  ::infoprotobuf::dipswitch* _internal_add_dipswitch();
  public:
  const ::infoprotobuf::dipswitch& dipswitch(int index) const;
  ::infoprotobuf::dipswitch* add_dipswitch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch >&
      dipswitch() const;

  // repeated .infoprotobuf.configuration configuration = 23;
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;
  public:
  void clear_configuration();
  ::infoprotobuf::configuration* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration >*
      mutable_configuration();
  private:
  const ::infoprotobuf::configuration& _internal_configuration(int index) const;
  ::infoprotobuf::configuration* _internal_add_configuration();
  public:
  const ::infoprotobuf::configuration& configuration(int index) const;
  ::infoprotobuf::configuration* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration >&
      configuration() const;

  // repeated .infoprotobuf.port port = 24;
  int port_size() const;
  private:
  int _internal_port_size() const;
  public:
  void clear_port();
  ::infoprotobuf::port* mutable_port(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port >*
      mutable_port();
  private:
  const ::infoprotobuf::port& _internal_port(int index) const;
  ::infoprotobuf::port* _internal_add_port();
  public:
  const ::infoprotobuf::port& port(int index) const;
  ::infoprotobuf::port* add_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port >&
      port() const;

  // repeated .infoprotobuf.adjuster adjuster = 25;
  int adjuster_size() const;
  private:
  int _internal_adjuster_size() const;
  public:
  void clear_adjuster();
  ::infoprotobuf::adjuster* mutable_adjuster(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::adjuster >*
      mutable_adjuster();
  private:
  const ::infoprotobuf::adjuster& _internal_adjuster(int index) const;
  ::infoprotobuf::adjuster* _internal_add_adjuster();
  public:
  const ::infoprotobuf::adjuster& adjuster(int index) const;
  ::infoprotobuf::adjuster* add_adjuster();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::adjuster >&
      adjuster() const;

  // repeated .infoprotobuf.driver driver = 26;
  int driver_size() const;
  private:
  int _internal_driver_size() const;
  public:
  void clear_driver();
  ::infoprotobuf::driver* mutable_driver(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::driver >*
      mutable_driver();
  private:
  const ::infoprotobuf::driver& _internal_driver(int index) const;
  ::infoprotobuf::driver* _internal_add_driver();
  public:
  const ::infoprotobuf::driver& driver(int index) const;
  ::infoprotobuf::driver* add_driver();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::driver >&
      driver() const;

  // repeated .infoprotobuf.feature feature = 27;
  int feature_size() const;
  private:
  int _internal_feature_size() const;
  public:
  void clear_feature();
  ::infoprotobuf::feature* mutable_feature(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::feature >*
      mutable_feature();
  private:
  const ::infoprotobuf::feature& _internal_feature(int index) const;
  ::infoprotobuf::feature* _internal_add_feature();
  public:
  const ::infoprotobuf::feature& feature(int index) const;
  ::infoprotobuf::feature* add_feature();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::feature >&
      feature() const;

  // repeated .infoprotobuf.device device = 28;
  int device_size() const;
  private:
  int _internal_device_size() const;
  public:
  void clear_device();
  ::infoprotobuf::device* mutable_device(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device >*
      mutable_device();
  private:
  const ::infoprotobuf::device& _internal_device(int index) const;
  ::infoprotobuf::device* _internal_add_device();
  public:
  const ::infoprotobuf::device& device(int index) const;
  ::infoprotobuf::device* add_device();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device >&
      device() const;

  // repeated .infoprotobuf.slot slot = 29;
  int slot_size() const;
  private:
  int _internal_slot_size() const;
  public:
  void clear_slot();
  ::infoprotobuf::slot* mutable_slot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot >*
      mutable_slot();
  private:
  const ::infoprotobuf::slot& _internal_slot(int index) const;
  ::infoprotobuf::slot* _internal_add_slot();
  public:
  const ::infoprotobuf::slot& slot(int index) const;
  ::infoprotobuf::slot* add_slot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot >&
      slot() const;

  // repeated .infoprotobuf.softwarelist softwarelist = 30;
  int softwarelist_size() const;
  private:
  int _internal_softwarelist_size() const;
  public:
  void clear_softwarelist();
  ::infoprotobuf::softwarelist* mutable_softwarelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::softwarelist >*
      mutable_softwarelist();
  private:
  const ::infoprotobuf::softwarelist& _internal_softwarelist(int index) const;
  ::infoprotobuf::softwarelist* _internal_add_softwarelist();
  public:
  const ::infoprotobuf::softwarelist& softwarelist(int index) const;
  ::infoprotobuf::softwarelist* add_softwarelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::softwarelist >&
      softwarelist() const;

  // repeated .infoprotobuf.ramoption ramoption = 31;
  int ramoption_size() const;
  private:
  int _internal_ramoption_size() const;
  public:
  void clear_ramoption();
  ::infoprotobuf::ramoption* mutable_ramoption(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::ramoption >*
      mutable_ramoption();
  private:
  const ::infoprotobuf::ramoption& _internal_ramoption(int index) const;
  ::infoprotobuf::ramoption* _internal_add_ramoption();
  public:
  const ::infoprotobuf::ramoption& ramoption(int index) const;
  ::infoprotobuf::ramoption* add_ramoption();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::ramoption >&
      ramoption() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string sourcefile = 2;
  bool has_sourcefile() const;
  private:
  bool _internal_has_sourcefile() const;
  public:
  void clear_sourcefile();
  const std::string& sourcefile() const;
  void set_sourcefile(const std::string& value);
  void set_sourcefile(std::string&& value);
  void set_sourcefile(const char* value);
  void set_sourcefile(const char* value, size_t size);
  std::string* mutable_sourcefile();
  std::string* release_sourcefile();
  void set_allocated_sourcefile(std::string* sourcefile);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sourcefile();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sourcefile(
      std::string* sourcefile);
  private:
  const std::string& _internal_sourcefile() const;
  void _internal_set_sourcefile(const std::string& value);
  std::string* _internal_mutable_sourcefile();
  public:

  // optional string cloneof = 7;
  bool has_cloneof() const;
  private:
  bool _internal_has_cloneof() const;
  public:
  void clear_cloneof();
  const std::string& cloneof() const;
  void set_cloneof(const std::string& value);
  void set_cloneof(std::string&& value);
  void set_cloneof(const char* value);
  void set_cloneof(const char* value, size_t size);
  std::string* mutable_cloneof();
  std::string* release_cloneof();
  void set_allocated_cloneof(std::string* cloneof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_cloneof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_cloneof(
      std::string* cloneof);
  private:
  const std::string& _internal_cloneof() const;
  void _internal_set_cloneof(const std::string& value);
  std::string* _internal_mutable_cloneof();
  public:

  // optional string romof = 8;
  bool has_romof() const;
  private:
  bool _internal_has_romof() const;
  public:
  void clear_romof();
  const std::string& romof() const;
  void set_romof(const std::string& value);
  void set_romof(std::string&& value);
  void set_romof(const char* value);
  void set_romof(const char* value, size_t size);
  std::string* mutable_romof();
  std::string* release_romof();
  void set_allocated_romof(std::string* romof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_romof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_romof(
      std::string* romof);
  private:
  const std::string& _internal_romof() const;
  void _internal_set_romof(const std::string& value);
  std::string* _internal_mutable_romof();
  public:

  // optional string sampleof = 9;
  bool has_sampleof() const;
  private:
  bool _internal_has_sampleof() const;
  public:
  void clear_sampleof();
  const std::string& sampleof() const;
  void set_sampleof(const std::string& value);
  void set_sampleof(std::string&& value);
  void set_sampleof(const char* value);
  void set_sampleof(const char* value, size_t size);
  std::string* mutable_sampleof();
  std::string* release_sampleof();
  void set_allocated_sampleof(std::string* sampleof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sampleof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sampleof(
      std::string* sampleof);
  private:
  const std::string& _internal_sampleof() const;
  void _internal_set_sampleof(const std::string& value);
  std::string* _internal_mutable_sampleof();
  public:

  // required string description = 10;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_description();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_description(
      std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string year = 11;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  const std::string& year() const;
  void set_year(const std::string& value);
  void set_year(std::string&& value);
  void set_year(const char* value);
  void set_year(const char* value, size_t size);
  std::string* mutable_year();
  std::string* release_year();
  void set_allocated_year(std::string* year);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_year();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_year(
      std::string* year);
  private:
  const std::string& _internal_year() const;
  void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // optional string manufacturer = 12;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  void set_manufacturer(const std::string& value);
  void set_manufacturer(std::string&& value);
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  std::string* mutable_manufacturer();
  std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_manufacturer();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_manufacturer(
      std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional .infoprotobuf.sound sound = 20;
  bool has_sound() const;
  private:
  bool _internal_has_sound() const;
  public:
  void clear_sound();
  const ::infoprotobuf::sound& sound() const;
  ::infoprotobuf::sound* release_sound();
  ::infoprotobuf::sound* mutable_sound();
  void set_allocated_sound(::infoprotobuf::sound* sound);
  private:
  const ::infoprotobuf::sound& _internal_sound() const;
  ::infoprotobuf::sound* _internal_mutable_sound();
  public:
  void unsafe_arena_set_allocated_sound(
      ::infoprotobuf::sound* sound);
  ::infoprotobuf::sound* unsafe_arena_release_sound();

  // optional .infoprotobuf.input input = 21;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::infoprotobuf::input& input() const;
  ::infoprotobuf::input* release_input();
  ::infoprotobuf::input* mutable_input();
  void set_allocated_input(::infoprotobuf::input* input);
  private:
  const ::infoprotobuf::input& _internal_input() const;
  ::infoprotobuf::input* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::infoprotobuf::input* input);
  ::infoprotobuf::input* unsafe_arena_release_input();

  // optional bool isbios = 3 [default = false];
  bool has_isbios() const;
  private:
  bool _internal_has_isbios() const;
  public:
  void clear_isbios();
  bool isbios() const;
  void set_isbios(bool value);
  private:
  bool _internal_isbios() const;
  void _internal_set_isbios(bool value);
  public:

  // optional bool isdevice = 4 [default = false];
  bool has_isdevice() const;
  private:
  bool _internal_has_isdevice() const;
  public:
  void clear_isdevice();
  bool isdevice() const;
  void set_isdevice(bool value);
  private:
  bool _internal_isdevice() const;
  void _internal_set_isdevice(bool value);
  public:

  // optional bool ismechanical = 5 [default = false];
  bool has_ismechanical() const;
  private:
  bool _internal_has_ismechanical() const;
  public:
  void clear_ismechanical();
  bool ismechanical() const;
  void set_ismechanical(bool value);
  private:
  bool _internal_ismechanical() const;
  void _internal_set_ismechanical(bool value);
  public:

  // optional bool runnable = 6 [default = true];
  bool has_runnable() const;
  private:
  bool _internal_has_runnable() const;
  public:
  void clear_runnable();
  bool runnable() const;
  void set_runnable(bool value);
  private:
  bool _internal_runnable() const;
  void _internal_set_runnable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.machine)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::biosset > biosset_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::rom > rom_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::disk > disk_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_ref > device_ref_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::sample > sample_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::chip > chip_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::display > display_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch > dipswitch_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration > configuration_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port > port_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::adjuster > adjuster_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::driver > driver_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::feature > feature_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device > device_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot > slot_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::softwarelist > softwarelist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::ramoption > ramoption_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcefile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloneof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr romof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sampleof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::infoprotobuf::sound* sound_;
  ::infoprotobuf::input* input_;
  bool isbios_;
  bool isdevice_;
  bool ismechanical_;
  bool runnable_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class biosset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.biosset) */ {
 public:
  inline biosset() : biosset(nullptr) {};
  virtual ~biosset();

  biosset(const biosset& from);
  biosset(biosset&& from) noexcept
    : biosset() {
    *this = ::std::move(from);
  }

  inline biosset& operator=(const biosset& from) {
    CopyFrom(from);
    return *this;
  }
  inline biosset& operator=(biosset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const biosset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const biosset* internal_default_instance() {
    return reinterpret_cast<const biosset*>(
               &_biosset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(biosset& a, biosset& b) {
    a.Swap(&b);
  }
  inline void Swap(biosset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(biosset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline biosset* New() const final {
    return CreateMaybeMessage<biosset>(nullptr);
  }

  biosset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<biosset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const biosset& from);
  void MergeFrom(const biosset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(biosset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.biosset";
  }
  protected:
  explicit biosset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kDefaultFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_description();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_description(
      std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional bool default = 3 [default = false];
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.biosset)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  bool default__;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class rom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.rom) */ {
 public:
  inline rom() : rom(nullptr) {};
  virtual ~rom();

  rom(const rom& from);
  rom(rom&& from) noexcept
    : rom() {
    *this = ::std::move(from);
  }

  inline rom& operator=(const rom& from) {
    CopyFrom(from);
    return *this;
  }
  inline rom& operator=(rom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rom* internal_default_instance() {
    return reinterpret_cast<const rom*>(
               &_rom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(rom& a, rom& b) {
    a.Swap(&b);
  }
  inline void Swap(rom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rom* New() const final {
    return CreateMaybeMessage<rom>(nullptr);
  }

  rom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rom& from);
  void MergeFrom(const rom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.rom";
  }
  protected:
  explicit rom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSha1FieldNumber = 2,
    kMergeFieldNumber = 3,
    kRegionFieldNumber = 4,
    kBiosFieldNumber = 7,
    kOffsetFieldNumber = 10,
    kOptionalFieldNumber = 6,
    kSizeFieldNumber = 8,
    kCrcFieldNumber = 9,
    kStatusFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string sha1 = 2;
  bool has_sha1() const;
  private:
  bool _internal_has_sha1() const;
  public:
  void clear_sha1();
  const std::string& sha1() const;
  void set_sha1(const std::string& value);
  void set_sha1(std::string&& value);
  void set_sha1(const char* value);
  void set_sha1(const char* value, size_t size);
  std::string* mutable_sha1();
  std::string* release_sha1();
  void set_allocated_sha1(std::string* sha1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sha1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sha1(
      std::string* sha1);
  private:
  const std::string& _internal_sha1() const;
  void _internal_set_sha1(const std::string& value);
  std::string* _internal_mutable_sha1();
  public:

  // optional string merge = 3;
  bool has_merge() const;
  private:
  bool _internal_has_merge() const;
  public:
  void clear_merge();
  const std::string& merge() const;
  void set_merge(const std::string& value);
  void set_merge(std::string&& value);
  void set_merge(const char* value);
  void set_merge(const char* value, size_t size);
  std::string* mutable_merge();
  std::string* release_merge();
  void set_allocated_merge(std::string* merge);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_merge();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_merge(
      std::string* merge);
  private:
  const std::string& _internal_merge() const;
  void _internal_set_merge(const std::string& value);
  std::string* _internal_mutable_merge();
  public:

  // optional string region = 4;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_region();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_region(
      std::string* region);
  private:
  const std::string& _internal_region() const;
  void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string bios = 7;
  bool has_bios() const;
  private:
  bool _internal_has_bios() const;
  public:
  void clear_bios();
  const std::string& bios() const;
  void set_bios(const std::string& value);
  void set_bios(std::string&& value);
  void set_bios(const char* value);
  void set_bios(const char* value, size_t size);
  std::string* mutable_bios();
  std::string* release_bios();
  void set_allocated_bios(std::string* bios);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_bios();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_bios(
      std::string* bios);
  private:
  const std::string& _internal_bios() const;
  void _internal_set_bios(const std::string& value);
  std::string* _internal_mutable_bios();
  public:

  // optional string offset = 10;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  const std::string& offset() const;
  void set_offset(const std::string& value);
  void set_offset(std::string&& value);
  void set_offset(const char* value);
  void set_offset(const char* value, size_t size);
  std::string* mutable_offset();
  std::string* release_offset();
  void set_allocated_offset(std::string* offset);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_offset();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_offset(
      std::string* offset);
  private:
  const std::string& _internal_offset() const;
  void _internal_set_offset(const std::string& value);
  std::string* _internal_mutable_offset();
  public:

  // optional bool optional = 6 [default = false];
  bool has_optional() const;
  private:
  bool _internal_has_optional() const;
  public:
  void clear_optional();
  bool optional() const;
  void set_optional(bool value);
  private:
  bool _internal_optional() const;
  void _internal_set_optional(bool value);
  public:

  // required uint32 size = 8;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 crc = 9;
  bool has_crc() const;
  private:
  bool _internal_has_crc() const;
  public:
  void clear_crc();
  ::PROTOBUF_NAMESPACE_ID::uint32 crc() const;
  void set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_crc() const;
  void _internal_set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .infoprotobuf.status status = 5 [default = good];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::status status() const;
  void set_status(::infoprotobuf::status value);
  private:
  ::infoprotobuf::status _internal_status() const;
  void _internal_set_status(::infoprotobuf::status value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.rom)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merge_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bios_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offset_;
  bool optional_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 crc_;
  int status_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class disk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.disk) */ {
 public:
  inline disk() : disk(nullptr) {};
  virtual ~disk();

  disk(const disk& from);
  disk(disk&& from) noexcept
    : disk() {
    *this = ::std::move(from);
  }

  inline disk& operator=(const disk& from) {
    CopyFrom(from);
    return *this;
  }
  inline disk& operator=(disk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const disk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const disk* internal_default_instance() {
    return reinterpret_cast<const disk*>(
               &_disk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(disk& a, disk& b) {
    a.Swap(&b);
  }
  inline void Swap(disk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(disk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline disk* New() const final {
    return CreateMaybeMessage<disk>(nullptr);
  }

  disk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<disk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const disk& from);
  void MergeFrom(const disk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(disk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.disk";
  }
  protected:
  explicit disk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSha1FieldNumber = 2,
    kMergeFieldNumber = 3,
    kRegionFieldNumber = 4,
    kIndexFieldNumber = 8,
    kSizeFieldNumber = 7,
    kOptionalFieldNumber = 6,
    kWritableFieldNumber = 9,
    kStatusFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string sha1 = 2;
  bool has_sha1() const;
  private:
  bool _internal_has_sha1() const;
  public:
  void clear_sha1();
  const std::string& sha1() const;
  void set_sha1(const std::string& value);
  void set_sha1(std::string&& value);
  void set_sha1(const char* value);
  void set_sha1(const char* value, size_t size);
  std::string* mutable_sha1();
  std::string* release_sha1();
  void set_allocated_sha1(std::string* sha1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sha1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sha1(
      std::string* sha1);
  private:
  const std::string& _internal_sha1() const;
  void _internal_set_sha1(const std::string& value);
  std::string* _internal_mutable_sha1();
  public:

  // optional string merge = 3;
  bool has_merge() const;
  private:
  bool _internal_has_merge() const;
  public:
  void clear_merge();
  const std::string& merge() const;
  void set_merge(const std::string& value);
  void set_merge(std::string&& value);
  void set_merge(const char* value);
  void set_merge(const char* value, size_t size);
  std::string* mutable_merge();
  std::string* release_merge();
  void set_allocated_merge(std::string* merge);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_merge();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_merge(
      std::string* merge);
  private:
  const std::string& _internal_merge() const;
  void _internal_set_merge(const std::string& value);
  std::string* _internal_mutable_merge();
  public:

  // optional string region = 4;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_region();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_region(
      std::string* region);
  private:
  const std::string& _internal_region() const;
  void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string index = 8;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const std::string& index() const;
  void set_index(const std::string& value);
  void set_index(std::string&& value);
  void set_index(const char* value);
  void set_index(const char* value, size_t size);
  std::string* mutable_index();
  std::string* release_index();
  void set_allocated_index(std::string* index);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_index();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_index(
      std::string* index);
  private:
  const std::string& _internal_index() const;
  void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // required uint32 size = 7;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool optional = 6 [default = false];
  bool has_optional() const;
  private:
  bool _internal_has_optional() const;
  public:
  void clear_optional();
  bool optional() const;
  void set_optional(bool value);
  private:
  bool _internal_optional() const;
  void _internal_set_optional(bool value);
  public:

  // optional bool writable = 9 [default = false];
  bool has_writable() const;
  private:
  bool _internal_has_writable() const;
  public:
  void clear_writable();
  bool writable() const;
  void set_writable(bool value);
  private:
  bool _internal_writable() const;
  void _internal_set_writable(bool value);
  public:

  // optional .infoprotobuf.status status = 5 [default = good];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::status status() const;
  void set_status(::infoprotobuf::status value);
  private:
  ::infoprotobuf::status _internal_status() const;
  void _internal_set_status(::infoprotobuf::status value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.disk)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merge_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  bool optional_;
  bool writable_;
  int status_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class hashes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.hashes) */ {
 public:
  inline hashes() : hashes(nullptr) {};
  virtual ~hashes();

  hashes(const hashes& from);
  hashes(hashes&& from) noexcept
    : hashes() {
    *this = ::std::move(from);
  }

  inline hashes& operator=(const hashes& from) {
    CopyFrom(from);
    return *this;
  }
  inline hashes& operator=(hashes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const hashes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const hashes* internal_default_instance() {
    return reinterpret_cast<const hashes*>(
               &_hashes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(hashes& a, hashes& b) {
    a.Swap(&b);
  }
  inline void Swap(hashes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hashes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hashes* New() const final {
    return CreateMaybeMessage<hashes>(nullptr);
  }

  hashes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hashes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const hashes& from);
  void MergeFrom(const hashes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hashes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.hashes";
  }
  protected:
  explicit hashes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSha1FieldNumber = 1,
    kCrcFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional string sha1 = 1;
  bool has_sha1() const;
  private:
  bool _internal_has_sha1() const;
  public:
  void clear_sha1();
  const std::string& sha1() const;
  void set_sha1(const std::string& value);
  void set_sha1(std::string&& value);
  void set_sha1(const char* value);
  void set_sha1(const char* value, size_t size);
  std::string* mutable_sha1();
  std::string* release_sha1();
  void set_allocated_sha1(std::string* sha1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sha1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sha1(
      std::string* sha1);
  private:
  const std::string& _internal_sha1() const;
  void _internal_set_sha1(const std::string& value);
  std::string* _internal_mutable_sha1();
  public:

  // optional uint32 crc = 2;
  bool has_crc() const;
  private:
  bool _internal_has_crc() const;
  public:
  void clear_crc();
  ::PROTOBUF_NAMESPACE_ID::uint32 crc() const;
  void set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_crc() const;
  void _internal_set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .infoprotobuf.status status = 3 [default = good];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::status status() const;
  void set_status(::infoprotobuf::status value);
  private:
  ::infoprotobuf::status _internal_status() const;
  void _internal_set_status(::infoprotobuf::status value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.hashes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 crc_;
  int status_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class device_ref PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.device_ref) */ {
 public:
  inline device_ref() : device_ref(nullptr) {};
  virtual ~device_ref();

  device_ref(const device_ref& from);
  device_ref(device_ref&& from) noexcept
    : device_ref() {
    *this = ::std::move(from);
  }

  inline device_ref& operator=(const device_ref& from) {
    CopyFrom(from);
    return *this;
  }
  inline device_ref& operator=(device_ref&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const device_ref& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const device_ref* internal_default_instance() {
    return reinterpret_cast<const device_ref*>(
               &_device_ref_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(device_ref& a, device_ref& b) {
    a.Swap(&b);
  }
  inline void Swap(device_ref* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(device_ref* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline device_ref* New() const final {
    return CreateMaybeMessage<device_ref>(nullptr);
  }

  device_ref* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<device_ref>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const device_ref& from);
  void MergeFrom(const device_ref& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(device_ref* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.device_ref";
  }
  protected:
  explicit device_ref(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.device_ref)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class chip PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.chip) */ {
 public:
  inline chip() : chip(nullptr) {};
  virtual ~chip();

  chip(const chip& from);
  chip(chip&& from) noexcept
    : chip() {
    *this = ::std::move(from);
  }

  inline chip& operator=(const chip& from) {
    CopyFrom(from);
    return *this;
  }
  inline chip& operator=(chip&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const chip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const chip* internal_default_instance() {
    return reinterpret_cast<const chip*>(
               &_chip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(chip& a, chip& b) {
    a.Swap(&b);
  }
  inline void Swap(chip* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(chip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline chip* New() const final {
    return CreateMaybeMessage<chip>(nullptr);
  }

  chip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<chip>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const chip& from);
  void MergeFrom(const chip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(chip* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.chip";
  }
  protected:
  explicit chip(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTagFieldNumber = 2,
    kClockFieldNumber = 4,
    kTypeFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional uint32 clock = 4;
  bool has_clock() const;
  private:
  bool _internal_has_clock() const;
  public:
  void clear_clock();
  ::PROTOBUF_NAMESPACE_ID::uint32 clock() const;
  void set_clock(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_clock() const;
  void _internal_set_clock(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .infoprotobuf.chip_type type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::infoprotobuf::chip_type type() const;
  void set_type(::infoprotobuf::chip_type value);
  private:
  ::infoprotobuf::chip_type _internal_type() const;
  void _internal_set_type(::infoprotobuf::chip_type value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.chip)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::uint32 clock_;
  int type_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class sample PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.sample) */ {
 public:
  inline sample() : sample(nullptr) {};
  virtual ~sample();

  sample(const sample& from);
  sample(sample&& from) noexcept
    : sample() {
    *this = ::std::move(from);
  }

  inline sample& operator=(const sample& from) {
    CopyFrom(from);
    return *this;
  }
  inline sample& operator=(sample&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sample* internal_default_instance() {
    return reinterpret_cast<const sample*>(
               &_sample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(sample& a, sample& b) {
    a.Swap(&b);
  }
  inline void Swap(sample* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sample* New() const final {
    return CreateMaybeMessage<sample>(nullptr);
  }

  sample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sample>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sample& from);
  void MergeFrom(const sample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.sample";
  }
  protected:
  explicit sample(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.sample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class display PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.display) */ {
 public:
  inline display() : display(nullptr) {};
  virtual ~display();

  display(const display& from);
  display(display&& from) noexcept
    : display() {
    *this = ::std::move(from);
  }

  inline display& operator=(const display& from) {
    CopyFrom(from);
    return *this;
  }
  inline display& operator=(display&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const display& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const display* internal_default_instance() {
    return reinterpret_cast<const display*>(
               &_display_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(display& a, display& b) {
    a.Swap(&b);
  }
  inline void Swap(display* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(display* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline display* New() const final {
    return CreateMaybeMessage<display>(nullptr);
  }

  display* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<display>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const display& from);
  void MergeFrom(const display& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(display* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.display";
  }
  protected:
  explicit display(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kFlipxFieldNumber = 4,
    kWidthFieldNumber = 5,
    kRefreshFieldNumber = 7,
    kHeightFieldNumber = 6,
    kPixclockFieldNumber = 8,
    kHtotalFieldNumber = 9,
    kHbendFieldNumber = 10,
    kHbstartFieldNumber = 11,
    kVtotalFieldNumber = 12,
    kVbendFieldNumber = 13,
    kVbstartFieldNumber = 14,
    kTypeFieldNumber = 2,
    kRotateFieldNumber = 3,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional bool flipx = 4 [default = false];
  bool has_flipx() const;
  private:
  bool _internal_has_flipx() const;
  public:
  void clear_flipx();
  bool flipx() const;
  void set_flipx(bool value);
  private:
  bool _internal_flipx() const;
  void _internal_set_flipx(bool value);
  public:

  // optional uint32 width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required double refresh = 7;
  bool has_refresh() const;
  private:
  bool _internal_has_refresh() const;
  public:
  void clear_refresh();
  double refresh() const;
  void set_refresh(double value);
  private:
  double _internal_refresh() const;
  void _internal_set_refresh(double value);
  public:

  // optional uint32 height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 pixclock = 8;
  bool has_pixclock() const;
  private:
  bool _internal_has_pixclock() const;
  public:
  void clear_pixclock();
  ::PROTOBUF_NAMESPACE_ID::int32 pixclock() const;
  void set_pixclock(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pixclock() const;
  void _internal_set_pixclock(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 htotal = 9;
  bool has_htotal() const;
  private:
  bool _internal_has_htotal() const;
  public:
  void clear_htotal();
  ::PROTOBUF_NAMESPACE_ID::int32 htotal() const;
  void set_htotal(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_htotal() const;
  void _internal_set_htotal(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 hbend = 10;
  bool has_hbend() const;
  private:
  bool _internal_has_hbend() const;
  public:
  void clear_hbend();
  ::PROTOBUF_NAMESPACE_ID::int32 hbend() const;
  void set_hbend(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hbend() const;
  void _internal_set_hbend(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 hbstart = 11;
  bool has_hbstart() const;
  private:
  bool _internal_has_hbstart() const;
  public:
  void clear_hbstart();
  ::PROTOBUF_NAMESPACE_ID::int32 hbstart() const;
  void set_hbstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hbstart() const;
  void _internal_set_hbstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 vtotal = 12;
  bool has_vtotal() const;
  private:
  bool _internal_has_vtotal() const;
  public:
  void clear_vtotal();
  ::PROTOBUF_NAMESPACE_ID::int32 vtotal() const;
  void set_vtotal(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vtotal() const;
  void _internal_set_vtotal(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 vbend = 13;
  bool has_vbend() const;
  private:
  bool _internal_has_vbend() const;
  public:
  void clear_vbend();
  ::PROTOBUF_NAMESPACE_ID::int32 vbend() const;
  void set_vbend(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vbend() const;
  void _internal_set_vbend(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 vbstart = 14;
  bool has_vbstart() const;
  private:
  bool _internal_has_vbstart() const;
  public:
  void clear_vbstart();
  ::PROTOBUF_NAMESPACE_ID::int32 vbstart() const;
  void set_vbstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vbstart() const;
  void _internal_set_vbstart(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .infoprotobuf.display_type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::infoprotobuf::display_type type() const;
  void set_type(::infoprotobuf::display_type value);
  private:
  ::infoprotobuf::display_type _internal_type() const;
  void _internal_set_type(::infoprotobuf::display_type value);
  public:

  // optional .infoprotobuf.display_rotation rotate = 3;
  bool has_rotate() const;
  private:
  bool _internal_has_rotate() const;
  public:
  void clear_rotate();
  ::infoprotobuf::display_rotation rotate() const;
  void set_rotate(::infoprotobuf::display_rotation value);
  private:
  ::infoprotobuf::display_rotation _internal_rotate() const;
  void _internal_set_rotate(::infoprotobuf::display_rotation value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.display)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  bool flipx_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  double refresh_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 pixclock_;
  ::PROTOBUF_NAMESPACE_ID::int32 htotal_;
  ::PROTOBUF_NAMESPACE_ID::int32 hbend_;
  ::PROTOBUF_NAMESPACE_ID::int32 hbstart_;
  ::PROTOBUF_NAMESPACE_ID::int32 vtotal_;
  ::PROTOBUF_NAMESPACE_ID::int32 vbend_;
  ::PROTOBUF_NAMESPACE_ID::int32 vbstart_;
  int type_;
  int rotate_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class sound PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.sound) */ {
 public:
  inline sound() : sound(nullptr) {};
  virtual ~sound();

  sound(const sound& from);
  sound(sound&& from) noexcept
    : sound() {
    *this = ::std::move(from);
  }

  inline sound& operator=(const sound& from) {
    CopyFrom(from);
    return *this;
  }
  inline sound& operator=(sound&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sound* internal_default_instance() {
    return reinterpret_cast<const sound*>(
               &_sound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(sound& a, sound& b) {
    a.Swap(&b);
  }
  inline void Swap(sound* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sound* New() const final {
    return CreateMaybeMessage<sound>(nullptr);
  }

  sound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sound& from);
  void MergeFrom(const sound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.sound";
  }
  protected:
  explicit sound(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // required int32 channels = 1;
  bool has_channels() const;
  private:
  bool _internal_has_channels() const;
  public:
  void clear_channels();
  ::PROTOBUF_NAMESPACE_ID::int32 channels() const;
  void set_channels(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_channels() const;
  void _internal_set_channels(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.sound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 channels_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class condition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.condition) */ {
 public:
  inline condition() : condition(nullptr) {};
  virtual ~condition();

  condition(const condition& from);
  condition(condition&& from) noexcept
    : condition() {
    *this = ::std::move(from);
  }

  inline condition& operator=(const condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline condition& operator=(condition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const condition* internal_default_instance() {
    return reinterpret_cast<const condition*>(
               &_condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(condition& a, condition& b) {
    a.Swap(&b);
  }
  inline void Swap(condition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline condition* New() const final {
    return CreateMaybeMessage<condition>(nullptr);
  }

  condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const condition& from);
  void MergeFrom(const condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.condition";
  }
  protected:
  explicit condition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef condition_condition_relation condition_relation;
  static constexpr condition_relation eq =
    condition_condition_relation_eq;
  static constexpr condition_relation ne =
    condition_condition_relation_ne;
  static constexpr condition_relation gt =
    condition_condition_relation_gt;
  static constexpr condition_relation le =
    condition_condition_relation_le;
  static constexpr condition_relation lt =
    condition_condition_relation_lt;
  static constexpr condition_relation ge =
    condition_condition_relation_ge;
  static inline bool condition_relation_IsValid(int value) {
    return condition_condition_relation_IsValid(value);
  }
  static constexpr condition_relation condition_relation_MIN =
    condition_condition_relation_condition_relation_MIN;
  static constexpr condition_relation condition_relation_MAX =
    condition_condition_relation_condition_relation_MAX;
  static constexpr int condition_relation_ARRAYSIZE =
    condition_condition_relation_condition_relation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  condition_relation_descriptor() {
    return condition_condition_relation_descriptor();
  }
  template<typename T>
  static inline const std::string& condition_relation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, condition_relation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function condition_relation_Name.");
    return condition_condition_relation_Name(enum_t_value);
  }
  static inline bool condition_relation_Parse(const std::string& name,
      condition_relation* value) {
    return condition_condition_relation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kMaskFieldNumber = 2,
    kValueFieldNumber = 4,
    kRelationFieldNumber = 3,
  };
  // required string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // required uint32 mask = 2;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask() const;
  void _internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 value = 4;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .infoprotobuf.condition.condition_relation relation = 3;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  ::infoprotobuf::condition_condition_relation relation() const;
  void set_relation(::infoprotobuf::condition_condition_relation value);
  private:
  ::infoprotobuf::condition_condition_relation _internal_relation() const;
  void _internal_set_relation(::infoprotobuf::condition_condition_relation value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.condition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  int relation_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class input_Control PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.input.Control) */ {
 public:
  inline input_Control() : input_Control(nullptr) {};
  virtual ~input_Control();

  input_Control(const input_Control& from);
  input_Control(input_Control&& from) noexcept
    : input_Control() {
    *this = ::std::move(from);
  }

  inline input_Control& operator=(const input_Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline input_Control& operator=(input_Control&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const input_Control& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const input_Control* internal_default_instance() {
    return reinterpret_cast<const input_Control*>(
               &_input_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(input_Control& a, input_Control& b) {
    a.Swap(&b);
  }
  inline void Swap(input_Control* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(input_Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline input_Control* New() const final {
    return CreateMaybeMessage<input_Control>(nullptr);
  }

  input_Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<input_Control>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const input_Control& from);
  void MergeFrom(const input_Control& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(input_Control* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.input.Control";
  }
  protected:
  explicit input_Control(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kWaysFieldNumber = 10,
    kWays2FieldNumber = 11,
    kWays3FieldNumber = 12,
    kPlayerFieldNumber = 2,
    kButtonsFieldNumber = 3,
    kReqbuttonsFieldNumber = 4,
    kMinimumFieldNumber = 5,
    kMaximumFieldNumber = 6,
    kSensitivityFieldNumber = 7,
    kKeydeltaFieldNumber = 8,
    kReverseFieldNumber = 9,
  };
  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string ways = 10;
  bool has_ways() const;
  private:
  bool _internal_has_ways() const;
  public:
  void clear_ways();
  const std::string& ways() const;
  void set_ways(const std::string& value);
  void set_ways(std::string&& value);
  void set_ways(const char* value);
  void set_ways(const char* value, size_t size);
  std::string* mutable_ways();
  std::string* release_ways();
  void set_allocated_ways(std::string* ways);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ways();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ways(
      std::string* ways);
  private:
  const std::string& _internal_ways() const;
  void _internal_set_ways(const std::string& value);
  std::string* _internal_mutable_ways();
  public:

  // optional string ways2 = 11;
  bool has_ways2() const;
  private:
  bool _internal_has_ways2() const;
  public:
  void clear_ways2();
  const std::string& ways2() const;
  void set_ways2(const std::string& value);
  void set_ways2(std::string&& value);
  void set_ways2(const char* value);
  void set_ways2(const char* value, size_t size);
  std::string* mutable_ways2();
  std::string* release_ways2();
  void set_allocated_ways2(std::string* ways2);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ways2();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ways2(
      std::string* ways2);
  private:
  const std::string& _internal_ways2() const;
  void _internal_set_ways2(const std::string& value);
  std::string* _internal_mutable_ways2();
  public:

  // optional string ways3 = 12;
  bool has_ways3() const;
  private:
  bool _internal_has_ways3() const;
  public:
  void clear_ways3();
  const std::string& ways3() const;
  void set_ways3(const std::string& value);
  void set_ways3(std::string&& value);
  void set_ways3(const char* value);
  void set_ways3(const char* value, size_t size);
  std::string* mutable_ways3();
  std::string* release_ways3();
  void set_allocated_ways3(std::string* ways3);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ways3();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ways3(
      std::string* ways3);
  private:
  const std::string& _internal_ways3() const;
  void _internal_set_ways3(const std::string& value);
  std::string* _internal_mutable_ways3();
  public:

  // optional int32 player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  ::PROTOBUF_NAMESPACE_ID::int32 player() const;
  void set_player(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_player() const;
  void _internal_set_player(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 buttons = 3;
  bool has_buttons() const;
  private:
  bool _internal_has_buttons() const;
  public:
  void clear_buttons();
  ::PROTOBUF_NAMESPACE_ID::int32 buttons() const;
  void set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_buttons() const;
  void _internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 reqbuttons = 4;
  bool has_reqbuttons() const;
  private:
  bool _internal_has_reqbuttons() const;
  public:
  void clear_reqbuttons();
  ::PROTOBUF_NAMESPACE_ID::int32 reqbuttons() const;
  void set_reqbuttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reqbuttons() const;
  void _internal_set_reqbuttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minimum = 5;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  ::PROTOBUF_NAMESPACE_ID::int32 minimum() const;
  void set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minimum() const;
  void _internal_set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 maximum = 6;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  ::PROTOBUF_NAMESPACE_ID::int32 maximum() const;
  void set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maximum() const;
  void _internal_set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 sensitivity = 7;
  bool has_sensitivity() const;
  private:
  bool _internal_has_sensitivity() const;
  public:
  void clear_sensitivity();
  ::PROTOBUF_NAMESPACE_ID::int32 sensitivity() const;
  void set_sensitivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sensitivity() const;
  void _internal_set_sensitivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 keydelta = 8;
  bool has_keydelta() const;
  private:
  bool _internal_has_keydelta() const;
  public:
  void clear_keydelta();
  ::PROTOBUF_NAMESPACE_ID::int32 keydelta() const;
  void set_keydelta(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_keydelta() const;
  void _internal_set_keydelta(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool reverse = 9 [default = false];
  bool has_reverse() const;
  private:
  bool _internal_has_reverse() const;
  public:
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.input.Control)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ways_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ways2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ways3_;
  ::PROTOBUF_NAMESPACE_ID::int32 player_;
  ::PROTOBUF_NAMESPACE_ID::int32 buttons_;
  ::PROTOBUF_NAMESPACE_ID::int32 reqbuttons_;
  ::PROTOBUF_NAMESPACE_ID::int32 minimum_;
  ::PROTOBUF_NAMESPACE_ID::int32 maximum_;
  ::PROTOBUF_NAMESPACE_ID::int32 sensitivity_;
  ::PROTOBUF_NAMESPACE_ID::int32 keydelta_;
  bool reverse_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class input PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.input) */ {
 public:
  inline input() : input(nullptr) {};
  virtual ~input();

  input(const input& from);
  input(input&& from) noexcept
    : input() {
    *this = ::std::move(from);
  }

  inline input& operator=(const input& from) {
    CopyFrom(from);
    return *this;
  }
  inline input& operator=(input&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const input* internal_default_instance() {
    return reinterpret_cast<const input*>(
               &_input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(input& a, input& b) {
    a.Swap(&b);
  }
  inline void Swap(input* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline input* New() const final {
    return CreateMaybeMessage<input>(nullptr);
  }

  input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<input>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const input& from);
  void MergeFrom(const input& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(input* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.input";
  }
  protected:
  explicit input(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef input_Control Control;

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 5,
    kServiceFieldNumber = 1,
    kTiltFieldNumber = 2,
    kPlayersFieldNumber = 3,
    kCoinsFieldNumber = 4,
  };
  // repeated .infoprotobuf.input.Control control = 5;
  int control_size() const;
  private:
  int _internal_control_size() const;
  public:
  void clear_control();
  ::infoprotobuf::input_Control* mutable_control(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::input_Control >*
      mutable_control();
  private:
  const ::infoprotobuf::input_Control& _internal_control(int index) const;
  ::infoprotobuf::input_Control* _internal_add_control();
  public:
  const ::infoprotobuf::input_Control& control(int index) const;
  ::infoprotobuf::input_Control* add_control();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::input_Control >&
      control() const;

  // optional bool service = 1 [default = false];
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  bool service() const;
  void set_service(bool value);
  private:
  bool _internal_service() const;
  void _internal_set_service(bool value);
  public:

  // optional bool tilt = 2 [default = false];
  bool has_tilt() const;
  private:
  bool _internal_has_tilt() const;
  public:
  void clear_tilt();
  bool tilt() const;
  void set_tilt(bool value);
  private:
  bool _internal_tilt() const;
  void _internal_set_tilt(bool value);
  public:

  // required int32 players = 3;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  ::PROTOBUF_NAMESPACE_ID::int32 players() const;
  void set_players(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_players() const;
  void _internal_set_players(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 coins = 4;
  bool has_coins() const;
  private:
  bool _internal_has_coins() const;
  public:
  void clear_coins();
  ::PROTOBUF_NAMESPACE_ID::int32 coins() const;
  void set_coins(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_coins() const;
  void _internal_set_coins(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::input_Control > control_;
  bool service_;
  bool tilt_;
  ::PROTOBUF_NAMESPACE_ID::int32 players_;
  ::PROTOBUF_NAMESPACE_ID::int32 coins_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class dipswitch_DipLocation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.dipswitch.DipLocation) */ {
 public:
  inline dipswitch_DipLocation() : dipswitch_DipLocation(nullptr) {};
  virtual ~dipswitch_DipLocation();

  dipswitch_DipLocation(const dipswitch_DipLocation& from);
  dipswitch_DipLocation(dipswitch_DipLocation&& from) noexcept
    : dipswitch_DipLocation() {
    *this = ::std::move(from);
  }

  inline dipswitch_DipLocation& operator=(const dipswitch_DipLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline dipswitch_DipLocation& operator=(dipswitch_DipLocation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dipswitch_DipLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dipswitch_DipLocation* internal_default_instance() {
    return reinterpret_cast<const dipswitch_DipLocation*>(
               &_dipswitch_DipLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(dipswitch_DipLocation& a, dipswitch_DipLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(dipswitch_DipLocation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(dipswitch_DipLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dipswitch_DipLocation* New() const final {
    return CreateMaybeMessage<dipswitch_DipLocation>(nullptr);
  }

  dipswitch_DipLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dipswitch_DipLocation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dipswitch_DipLocation& from);
  void MergeFrom(const dipswitch_DipLocation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dipswitch_DipLocation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.dipswitch.DipLocation";
  }
  protected:
  explicit dipswitch_DipLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
    kInvertedFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint32 number = 2;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool inverted = 3 [default = false];
  bool has_inverted() const;
  private:
  bool _internal_has_inverted() const;
  public:
  void clear_inverted();
  bool inverted() const;
  void set_inverted(bool value);
  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.dipswitch.DipLocation)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_;
  bool inverted_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class dipswitch_DipValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.dipswitch.DipValue) */ {
 public:
  inline dipswitch_DipValue() : dipswitch_DipValue(nullptr) {};
  virtual ~dipswitch_DipValue();

  dipswitch_DipValue(const dipswitch_DipValue& from);
  dipswitch_DipValue(dipswitch_DipValue&& from) noexcept
    : dipswitch_DipValue() {
    *this = ::std::move(from);
  }

  inline dipswitch_DipValue& operator=(const dipswitch_DipValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline dipswitch_DipValue& operator=(dipswitch_DipValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dipswitch_DipValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dipswitch_DipValue* internal_default_instance() {
    return reinterpret_cast<const dipswitch_DipValue*>(
               &_dipswitch_DipValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(dipswitch_DipValue& a, dipswitch_DipValue& b) {
    a.Swap(&b);
  }
  inline void Swap(dipswitch_DipValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(dipswitch_DipValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dipswitch_DipValue* New() const final {
    return CreateMaybeMessage<dipswitch_DipValue>(nullptr);
  }

  dipswitch_DipValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dipswitch_DipValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dipswitch_DipValue& from);
  void MergeFrom(const dipswitch_DipValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dipswitch_DipValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.dipswitch.DipValue";
  }
  protected:
  explicit dipswitch_DipValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kConditionFieldNumber = 1,
    kValueFieldNumber = 3,
    kDefaultFieldNumber = 4,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .infoprotobuf.condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::infoprotobuf::condition& condition() const;
  ::infoprotobuf::condition* release_condition();
  ::infoprotobuf::condition* mutable_condition();
  void set_allocated_condition(::infoprotobuf::condition* condition);
  private:
  const ::infoprotobuf::condition& _internal_condition() const;
  ::infoprotobuf::condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::infoprotobuf::condition* condition);
  ::infoprotobuf::condition* unsafe_arena_release_condition();

  // required uint32 value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool default = 4 [default = false];
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.dipswitch.DipValue)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::infoprotobuf::condition* condition_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  bool default__;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class dipswitch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.dipswitch) */ {
 public:
  inline dipswitch() : dipswitch(nullptr) {};
  virtual ~dipswitch();

  dipswitch(const dipswitch& from);
  dipswitch(dipswitch&& from) noexcept
    : dipswitch() {
    *this = ::std::move(from);
  }

  inline dipswitch& operator=(const dipswitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline dipswitch& operator=(dipswitch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dipswitch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dipswitch* internal_default_instance() {
    return reinterpret_cast<const dipswitch*>(
               &_dipswitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(dipswitch& a, dipswitch& b) {
    a.Swap(&b);
  }
  inline void Swap(dipswitch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(dipswitch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dipswitch* New() const final {
    return CreateMaybeMessage<dipswitch>(nullptr);
  }

  dipswitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dipswitch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dipswitch& from);
  void MergeFrom(const dipswitch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dipswitch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.dipswitch";
  }
  protected:
  explicit dipswitch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dipswitch_DipLocation DipLocation;
  typedef dipswitch_DipValue DipValue;

  // accessors -------------------------------------------------------

  enum : int {
    kDiplocationFieldNumber = 4,
    kDipvalueFieldNumber = 6,
    kNameFieldNumber = 1,
    kTagFieldNumber = 2,
    kConditionFieldNumber = 5,
    kMaskFieldNumber = 3,
  };
  // repeated .infoprotobuf.dipswitch.DipLocation diplocation = 4;
  int diplocation_size() const;
  private:
  int _internal_diplocation_size() const;
  public:
  void clear_diplocation();
  ::infoprotobuf::dipswitch_DipLocation* mutable_diplocation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipLocation >*
      mutable_diplocation();
  private:
  const ::infoprotobuf::dipswitch_DipLocation& _internal_diplocation(int index) const;
  ::infoprotobuf::dipswitch_DipLocation* _internal_add_diplocation();
  public:
  const ::infoprotobuf::dipswitch_DipLocation& diplocation(int index) const;
  ::infoprotobuf::dipswitch_DipLocation* add_diplocation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipLocation >&
      diplocation() const;

  // repeated .infoprotobuf.dipswitch.DipValue dipvalue = 6;
  int dipvalue_size() const;
  private:
  int _internal_dipvalue_size() const;
  public:
  void clear_dipvalue();
  ::infoprotobuf::dipswitch_DipValue* mutable_dipvalue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipValue >*
      mutable_dipvalue();
  private:
  const ::infoprotobuf::dipswitch_DipValue& _internal_dipvalue(int index) const;
  ::infoprotobuf::dipswitch_DipValue* _internal_add_dipvalue();
  public:
  const ::infoprotobuf::dipswitch_DipValue& dipvalue(int index) const;
  ::infoprotobuf::dipswitch_DipValue* add_dipvalue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipValue >&
      dipvalue() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .infoprotobuf.condition condition = 5;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::infoprotobuf::condition& condition() const;
  ::infoprotobuf::condition* release_condition();
  ::infoprotobuf::condition* mutable_condition();
  void set_allocated_condition(::infoprotobuf::condition* condition);
  private:
  const ::infoprotobuf::condition& _internal_condition() const;
  ::infoprotobuf::condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::infoprotobuf::condition* condition);
  ::infoprotobuf::condition* unsafe_arena_release_condition();

  // required uint32 mask = 3;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask() const;
  void _internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.dipswitch)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipLocation > diplocation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipValue > dipvalue_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::infoprotobuf::condition* condition_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class configuration_ConfLocation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.configuration.ConfLocation) */ {
 public:
  inline configuration_ConfLocation() : configuration_ConfLocation(nullptr) {};
  virtual ~configuration_ConfLocation();

  configuration_ConfLocation(const configuration_ConfLocation& from);
  configuration_ConfLocation(configuration_ConfLocation&& from) noexcept
    : configuration_ConfLocation() {
    *this = ::std::move(from);
  }

  inline configuration_ConfLocation& operator=(const configuration_ConfLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline configuration_ConfLocation& operator=(configuration_ConfLocation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const configuration_ConfLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const configuration_ConfLocation* internal_default_instance() {
    return reinterpret_cast<const configuration_ConfLocation*>(
               &_configuration_ConfLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(configuration_ConfLocation& a, configuration_ConfLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(configuration_ConfLocation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(configuration_ConfLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline configuration_ConfLocation* New() const final {
    return CreateMaybeMessage<configuration_ConfLocation>(nullptr);
  }

  configuration_ConfLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<configuration_ConfLocation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const configuration_ConfLocation& from);
  void MergeFrom(const configuration_ConfLocation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(configuration_ConfLocation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.configuration.ConfLocation";
  }
  protected:
  explicit configuration_ConfLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
    kInvertedFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint32 number = 2;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool inverted = 3 [default = false];
  bool has_inverted() const;
  private:
  bool _internal_has_inverted() const;
  public:
  void clear_inverted();
  bool inverted() const;
  void set_inverted(bool value);
  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.configuration.ConfLocation)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_;
  bool inverted_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class configuration_ConfSetting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.configuration.ConfSetting) */ {
 public:
  inline configuration_ConfSetting() : configuration_ConfSetting(nullptr) {};
  virtual ~configuration_ConfSetting();

  configuration_ConfSetting(const configuration_ConfSetting& from);
  configuration_ConfSetting(configuration_ConfSetting&& from) noexcept
    : configuration_ConfSetting() {
    *this = ::std::move(from);
  }

  inline configuration_ConfSetting& operator=(const configuration_ConfSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline configuration_ConfSetting& operator=(configuration_ConfSetting&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const configuration_ConfSetting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const configuration_ConfSetting* internal_default_instance() {
    return reinterpret_cast<const configuration_ConfSetting*>(
               &_configuration_ConfSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(configuration_ConfSetting& a, configuration_ConfSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(configuration_ConfSetting* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(configuration_ConfSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline configuration_ConfSetting* New() const final {
    return CreateMaybeMessage<configuration_ConfSetting>(nullptr);
  }

  configuration_ConfSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<configuration_ConfSetting>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const configuration_ConfSetting& from);
  void MergeFrom(const configuration_ConfSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(configuration_ConfSetting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.configuration.ConfSetting";
  }
  protected:
  explicit configuration_ConfSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kValueFieldNumber = 3,
    kConditionFieldNumber = 1,
    kDefaultFieldNumber = 4,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .infoprotobuf.condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::infoprotobuf::condition& condition() const;
  ::infoprotobuf::condition* release_condition();
  ::infoprotobuf::condition* mutable_condition();
  void set_allocated_condition(::infoprotobuf::condition* condition);
  private:
  const ::infoprotobuf::condition& _internal_condition() const;
  ::infoprotobuf::condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::infoprotobuf::condition* condition);
  ::infoprotobuf::condition* unsafe_arena_release_condition();

  // optional bool default = 4 [default = false];
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.configuration.ConfSetting)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::infoprotobuf::condition* condition_;
  bool default__;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class configuration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.configuration) */ {
 public:
  inline configuration() : configuration(nullptr) {};
  virtual ~configuration();

  configuration(const configuration& from);
  configuration(configuration&& from) noexcept
    : configuration() {
    *this = ::std::move(from);
  }

  inline configuration& operator=(const configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline configuration& operator=(configuration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const configuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const configuration* internal_default_instance() {
    return reinterpret_cast<const configuration*>(
               &_configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(configuration& a, configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(configuration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(configuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline configuration* New() const final {
    return CreateMaybeMessage<configuration>(nullptr);
  }

  configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<configuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const configuration& from);
  void MergeFrom(const configuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(configuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.configuration";
  }
  protected:
  explicit configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef configuration_ConfLocation ConfLocation;
  typedef configuration_ConfSetting ConfSetting;

  // accessors -------------------------------------------------------

  enum : int {
    kConflocationFieldNumber = 5,
    kConfsettingFieldNumber = 6,
    kNameFieldNumber = 2,
    kTagFieldNumber = 3,
    kMaskFieldNumber = 4,
    kConditionFieldNumber = 1,
  };
  // repeated .infoprotobuf.configuration.ConfLocation conflocation = 5;
  int conflocation_size() const;
  private:
  int _internal_conflocation_size() const;
  public:
  void clear_conflocation();
  ::infoprotobuf::configuration_ConfLocation* mutable_conflocation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfLocation >*
      mutable_conflocation();
  private:
  const ::infoprotobuf::configuration_ConfLocation& _internal_conflocation(int index) const;
  ::infoprotobuf::configuration_ConfLocation* _internal_add_conflocation();
  public:
  const ::infoprotobuf::configuration_ConfLocation& conflocation(int index) const;
  ::infoprotobuf::configuration_ConfLocation* add_conflocation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfLocation >&
      conflocation() const;

  // repeated .infoprotobuf.configuration.ConfSetting confsetting = 6;
  int confsetting_size() const;
  private:
  int _internal_confsetting_size() const;
  public:
  void clear_confsetting();
  ::infoprotobuf::configuration_ConfSetting* mutable_confsetting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfSetting >*
      mutable_confsetting();
  private:
  const ::infoprotobuf::configuration_ConfSetting& _internal_confsetting(int index) const;
  ::infoprotobuf::configuration_ConfSetting* _internal_add_confsetting();
  public:
  const ::infoprotobuf::configuration_ConfSetting& confsetting(int index) const;
  ::infoprotobuf::configuration_ConfSetting* add_confsetting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfSetting >&
      confsetting() const;

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // required string mask = 4;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const std::string& mask() const;
  void set_mask(const std::string& value);
  void set_mask(std::string&& value);
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  std::string* mutable_mask();
  std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mask();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mask(
      std::string* mask);
  private:
  const std::string& _internal_mask() const;
  void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // optional .infoprotobuf.condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::infoprotobuf::condition& condition() const;
  ::infoprotobuf::condition* release_condition();
  ::infoprotobuf::condition* mutable_condition();
  void set_allocated_condition(::infoprotobuf::condition* condition);
  private:
  const ::infoprotobuf::condition& _internal_condition() const;
  ::infoprotobuf::condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::infoprotobuf::condition* condition);
  ::infoprotobuf::condition* unsafe_arena_release_condition();

  // @@protoc_insertion_point(class_scope:infoprotobuf.configuration)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfLocation > conflocation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfSetting > confsetting_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
  ::infoprotobuf::condition* condition_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class port_Analog PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.port.Analog) */ {
 public:
  inline port_Analog() : port_Analog(nullptr) {};
  virtual ~port_Analog();

  port_Analog(const port_Analog& from);
  port_Analog(port_Analog&& from) noexcept
    : port_Analog() {
    *this = ::std::move(from);
  }

  inline port_Analog& operator=(const port_Analog& from) {
    CopyFrom(from);
    return *this;
  }
  inline port_Analog& operator=(port_Analog&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const port_Analog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const port_Analog* internal_default_instance() {
    return reinterpret_cast<const port_Analog*>(
               &_port_Analog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(port_Analog& a, port_Analog& b) {
    a.Swap(&b);
  }
  inline void Swap(port_Analog* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(port_Analog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline port_Analog* New() const final {
    return CreateMaybeMessage<port_Analog>(nullptr);
  }

  port_Analog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<port_Analog>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const port_Analog& from);
  void MergeFrom(const port_Analog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(port_Analog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.port.Analog";
  }
  protected:
  explicit port_Analog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskFieldNumber = 1,
  };
  // required uint32 mask = 1;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask() const;
  void _internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.port.Analog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class port PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.port) */ {
 public:
  inline port() : port(nullptr) {};
  virtual ~port();

  port(const port& from);
  port(port&& from) noexcept
    : port() {
    *this = ::std::move(from);
  }

  inline port& operator=(const port& from) {
    CopyFrom(from);
    return *this;
  }
  inline port& operator=(port&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const port* internal_default_instance() {
    return reinterpret_cast<const port*>(
               &_port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(port& a, port& b) {
    a.Swap(&b);
  }
  inline void Swap(port* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline port* New() const final {
    return CreateMaybeMessage<port>(nullptr);
  }

  port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<port>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const port& from);
  void MergeFrom(const port& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(port* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.port";
  }
  protected:
  explicit port(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef port_Analog Analog;

  // accessors -------------------------------------------------------

  enum : int {
    kAnalogFieldNumber = 2,
    kTagFieldNumber = 1,
  };
  // repeated .infoprotobuf.port.Analog analog = 2;
  int analog_size() const;
  private:
  int _internal_analog_size() const;
  public:
  void clear_analog();
  ::infoprotobuf::port_Analog* mutable_analog(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port_Analog >*
      mutable_analog();
  private:
  const ::infoprotobuf::port_Analog& _internal_analog(int index) const;
  ::infoprotobuf::port_Analog* _internal_add_analog();
  public:
  const ::infoprotobuf::port_Analog& analog(int index) const;
  ::infoprotobuf::port_Analog* add_analog();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port_Analog >&
      analog() const;

  // required string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port_Analog > analog_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class adjuster PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.adjuster) */ {
 public:
  inline adjuster() : adjuster(nullptr) {};
  virtual ~adjuster();

  adjuster(const adjuster& from);
  adjuster(adjuster&& from) noexcept
    : adjuster() {
    *this = ::std::move(from);
  }

  inline adjuster& operator=(const adjuster& from) {
    CopyFrom(from);
    return *this;
  }
  inline adjuster& operator=(adjuster&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const adjuster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const adjuster* internal_default_instance() {
    return reinterpret_cast<const adjuster*>(
               &_adjuster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(adjuster& a, adjuster& b) {
    a.Swap(&b);
  }
  inline void Swap(adjuster* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(adjuster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline adjuster* New() const final {
    return CreateMaybeMessage<adjuster>(nullptr);
  }

  adjuster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<adjuster>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const adjuster& from);
  void MergeFrom(const adjuster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(adjuster* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.adjuster";
  }
  protected:
  explicit adjuster(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kConditionFieldNumber = 1,
    kDefaultFieldNumber = 3,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .infoprotobuf.condition condition = 1;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::infoprotobuf::condition& condition() const;
  ::infoprotobuf::condition* release_condition();
  ::infoprotobuf::condition* mutable_condition();
  void set_allocated_condition(::infoprotobuf::condition* condition);
  private:
  const ::infoprotobuf::condition& _internal_condition() const;
  ::infoprotobuf::condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::infoprotobuf::condition* condition);
  ::infoprotobuf::condition* unsafe_arena_release_condition();

  // required uint32 default = 3;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  ::PROTOBUF_NAMESPACE_ID::uint32 default_() const;
  void set_default_(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_default_() const;
  void _internal_set_default_(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.adjuster)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::infoprotobuf::condition* condition_;
  ::PROTOBUF_NAMESPACE_ID::uint32 default__;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class driver PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.driver) */ {
 public:
  inline driver() : driver(nullptr) {};
  virtual ~driver();

  driver(const driver& from);
  driver(driver&& from) noexcept
    : driver() {
    *this = ::std::move(from);
  }

  inline driver& operator=(const driver& from) {
    CopyFrom(from);
    return *this;
  }
  inline driver& operator=(driver&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const driver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const driver* internal_default_instance() {
    return reinterpret_cast<const driver*>(
               &_driver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(driver& a, driver& b) {
    a.Swap(&b);
  }
  inline void Swap(driver* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(driver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline driver* New() const final {
    return CreateMaybeMessage<driver>(nullptr);
  }

  driver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<driver>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const driver& from);
  void MergeFrom(const driver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(driver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.driver";
  }
  protected:
  explicit driver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef driver_driver_status driver_status;
  static constexpr driver_status good =
    driver_driver_status_good;
  static constexpr driver_status imperfect =
    driver_driver_status_imperfect;
  static constexpr driver_status preliminary =
    driver_driver_status_preliminary;
  static inline bool driver_status_IsValid(int value) {
    return driver_driver_status_IsValid(value);
  }
  static constexpr driver_status driver_status_MIN =
    driver_driver_status_driver_status_MIN;
  static constexpr driver_status driver_status_MAX =
    driver_driver_status_driver_status_MAX;
  static constexpr int driver_status_ARRAYSIZE =
    driver_driver_status_driver_status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  driver_status_descriptor() {
    return driver_driver_status_descriptor();
  }
  template<typename T>
  static inline const std::string& driver_status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, driver_status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function driver_status_Name.");
    return driver_driver_status_Name(enum_t_value);
  }
  static inline bool driver_status_Parse(const std::string& name,
      driver_status* value) {
    return driver_driver_status_Parse(name, value);
  }

  typedef driver_Supported Supported;
  static constexpr Supported supported =
    driver_Supported_supported;
  static constexpr Supported unsupported =
    driver_Supported_unsupported;
  static inline bool Supported_IsValid(int value) {
    return driver_Supported_IsValid(value);
  }
  static constexpr Supported Supported_MIN =
    driver_Supported_Supported_MIN;
  static constexpr Supported Supported_MAX =
    driver_Supported_Supported_MAX;
  static constexpr int Supported_ARRAYSIZE =
    driver_Supported_Supported_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Supported_descriptor() {
    return driver_Supported_descriptor();
  }
  template<typename T>
  static inline const std::string& Supported_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Supported>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Supported_Name.");
    return driver_Supported_Name(enum_t_value);
  }
  static inline bool Supported_Parse(const std::string& name,
      Supported* value) {
    return driver_Supported_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequireartworkFieldNumber = 5,
    kUnofficialFieldNumber = 6,
    kNosoundhardwareFieldNumber = 7,
    kIncompleteFieldNumber = 8,
    kStatusFieldNumber = 1,
    kEmulationFieldNumber = 2,
    kCocktailFieldNumber = 3,
    kSavestateFieldNumber = 4,
  };
  // optional bool requireartwork = 5 [default = false];
  bool has_requireartwork() const;
  private:
  bool _internal_has_requireartwork() const;
  public:
  void clear_requireartwork();
  bool requireartwork() const;
  void set_requireartwork(bool value);
  private:
  bool _internal_requireartwork() const;
  void _internal_set_requireartwork(bool value);
  public:

  // optional bool unofficial = 6 [default = false];
  bool has_unofficial() const;
  private:
  bool _internal_has_unofficial() const;
  public:
  void clear_unofficial();
  bool unofficial() const;
  void set_unofficial(bool value);
  private:
  bool _internal_unofficial() const;
  void _internal_set_unofficial(bool value);
  public:

  // optional bool nosoundhardware = 7 [default = false];
  bool has_nosoundhardware() const;
  private:
  bool _internal_has_nosoundhardware() const;
  public:
  void clear_nosoundhardware();
  bool nosoundhardware() const;
  void set_nosoundhardware(bool value);
  private:
  bool _internal_nosoundhardware() const;
  void _internal_set_nosoundhardware(bool value);
  public:

  // optional bool incomplete = 8 [default = false];
  bool has_incomplete() const;
  private:
  bool _internal_has_incomplete() const;
  public:
  void clear_incomplete();
  bool incomplete() const;
  void set_incomplete(bool value);
  private:
  bool _internal_incomplete() const;
  void _internal_set_incomplete(bool value);
  public:

  // required .infoprotobuf.driver.driver_status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::driver_driver_status status() const;
  void set_status(::infoprotobuf::driver_driver_status value);
  private:
  ::infoprotobuf::driver_driver_status _internal_status() const;
  void _internal_set_status(::infoprotobuf::driver_driver_status value);
  public:

  // required .infoprotobuf.driver.driver_status emulation = 2;
  bool has_emulation() const;
  private:
  bool _internal_has_emulation() const;
  public:
  void clear_emulation();
  ::infoprotobuf::driver_driver_status emulation() const;
  void set_emulation(::infoprotobuf::driver_driver_status value);
  private:
  ::infoprotobuf::driver_driver_status _internal_emulation() const;
  void _internal_set_emulation(::infoprotobuf::driver_driver_status value);
  public:

  // optional .infoprotobuf.driver.driver_status cocktail = 3;
  bool has_cocktail() const;
  private:
  bool _internal_has_cocktail() const;
  public:
  void clear_cocktail();
  ::infoprotobuf::driver_driver_status cocktail() const;
  void set_cocktail(::infoprotobuf::driver_driver_status value);
  private:
  ::infoprotobuf::driver_driver_status _internal_cocktail() const;
  void _internal_set_cocktail(::infoprotobuf::driver_driver_status value);
  public:

  // required .infoprotobuf.driver.Supported savestate = 4;
  bool has_savestate() const;
  private:
  bool _internal_has_savestate() const;
  public:
  void clear_savestate();
  ::infoprotobuf::driver_Supported savestate() const;
  void set_savestate(::infoprotobuf::driver_Supported value);
  private:
  ::infoprotobuf::driver_Supported _internal_savestate() const;
  void _internal_set_savestate(::infoprotobuf::driver_Supported value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.driver)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool requireartwork_;
  bool unofficial_;
  bool nosoundhardware_;
  bool incomplete_;
  int status_;
  int emulation_;
  int cocktail_;
  int savestate_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class feature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.feature) */ {
 public:
  inline feature() : feature(nullptr) {};
  virtual ~feature();

  feature(const feature& from);
  feature(feature&& from) noexcept
    : feature() {
    *this = ::std::move(from);
  }

  inline feature& operator=(const feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline feature& operator=(feature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const feature* internal_default_instance() {
    return reinterpret_cast<const feature*>(
               &_feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(feature& a, feature& b) {
    a.Swap(&b);
  }
  inline void Swap(feature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline feature* New() const final {
    return CreateMaybeMessage<feature>(nullptr);
  }

  feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<feature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const feature& from);
  void MergeFrom(const feature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(feature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.feature";
  }
  protected:
  explicit feature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef feature_Type Type;
  static constexpr Type protection =
    feature_Type_protection;
  static constexpr Type timing =
    feature_Type_timing;
  static constexpr Type graphics =
    feature_Type_graphics;
  static constexpr Type palette =
    feature_Type_palette;
  static constexpr Type sound =
    feature_Type_sound;
  static constexpr Type capture =
    feature_Type_capture;
  static constexpr Type camera =
    feature_Type_camera;
  static constexpr Type microphone =
    feature_Type_microphone;
  static constexpr Type controls =
    feature_Type_controls;
  static constexpr Type keyboard =
    feature_Type_keyboard;
  static constexpr Type mouse =
    feature_Type_mouse;
  static constexpr Type media =
    feature_Type_media;
  static constexpr Type disk =
    feature_Type_disk;
  static constexpr Type printer =
    feature_Type_printer;
  static constexpr Type tape =
    feature_Type_tape;
  static constexpr Type punch =
    feature_Type_punch;
  static constexpr Type drum =
    feature_Type_drum;
  static constexpr Type rom =
    feature_Type_rom;
  static constexpr Type comms =
    feature_Type_comms;
  static constexpr Type lan =
    feature_Type_lan;
  static constexpr Type wan =
    feature_Type_wan;
  static inline bool Type_IsValid(int value) {
    return feature_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    feature_Type_Type_MIN;
  static constexpr Type Type_MAX =
    feature_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    feature_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return feature_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return feature_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return feature_Type_Parse(name, value);
  }

  typedef feature_feature_status feature_status;
  static constexpr feature_status unemulated =
    feature_feature_status_unemulated;
  static constexpr feature_status imperfect =
    feature_feature_status_imperfect;
  static inline bool feature_status_IsValid(int value) {
    return feature_feature_status_IsValid(value);
  }
  static constexpr feature_status feature_status_MIN =
    feature_feature_status_feature_status_MIN;
  static constexpr feature_status feature_status_MAX =
    feature_feature_status_feature_status_MAX;
  static constexpr int feature_status_ARRAYSIZE =
    feature_feature_status_feature_status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  feature_status_descriptor() {
    return feature_feature_status_descriptor();
  }
  template<typename T>
  static inline const std::string& feature_status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, feature_status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function feature_status_Name.");
    return feature_feature_status_Name(enum_t_value);
  }
  static inline bool feature_status_Parse(const std::string& name,
      feature_status* value) {
    return feature_feature_status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStatusFieldNumber = 2,
    kOverallFieldNumber = 3,
  };
  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .infoprotobuf.feature.feature_status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::feature_feature_status status() const;
  void set_status(::infoprotobuf::feature_feature_status value);
  private:
  ::infoprotobuf::feature_feature_status _internal_status() const;
  void _internal_set_status(::infoprotobuf::feature_feature_status value);
  public:

  // optional .infoprotobuf.feature.feature_status overall = 3;
  bool has_overall() const;
  private:
  bool _internal_has_overall() const;
  public:
  void clear_overall();
  ::infoprotobuf::feature_feature_status overall() const;
  void set_overall(::infoprotobuf::feature_feature_status value);
  private:
  ::infoprotobuf::feature_feature_status _internal_overall() const;
  void _internal_set_overall(::infoprotobuf::feature_feature_status value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.feature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  int status_;
  int overall_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class device_DeviceInstance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.device.DeviceInstance) */ {
 public:
  inline device_DeviceInstance() : device_DeviceInstance(nullptr) {};
  virtual ~device_DeviceInstance();

  device_DeviceInstance(const device_DeviceInstance& from);
  device_DeviceInstance(device_DeviceInstance&& from) noexcept
    : device_DeviceInstance() {
    *this = ::std::move(from);
  }

  inline device_DeviceInstance& operator=(const device_DeviceInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline device_DeviceInstance& operator=(device_DeviceInstance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const device_DeviceInstance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const device_DeviceInstance* internal_default_instance() {
    return reinterpret_cast<const device_DeviceInstance*>(
               &_device_DeviceInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(device_DeviceInstance& a, device_DeviceInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(device_DeviceInstance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(device_DeviceInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline device_DeviceInstance* New() const final {
    return CreateMaybeMessage<device_DeviceInstance>(nullptr);
  }

  device_DeviceInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<device_DeviceInstance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const device_DeviceInstance& from);
  void MergeFrom(const device_DeviceInstance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(device_DeviceInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.device.DeviceInstance";
  }
  protected:
  explicit device_DeviceInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBriefnameFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string briefname = 2;
  bool has_briefname() const;
  private:
  bool _internal_has_briefname() const;
  public:
  void clear_briefname();
  const std::string& briefname() const;
  void set_briefname(const std::string& value);
  void set_briefname(std::string&& value);
  void set_briefname(const char* value);
  void set_briefname(const char* value, size_t size);
  std::string* mutable_briefname();
  std::string* release_briefname();
  void set_allocated_briefname(std::string* briefname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_briefname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_briefname(
      std::string* briefname);
  private:
  const std::string& _internal_briefname() const;
  void _internal_set_briefname(const std::string& value);
  std::string* _internal_mutable_briefname();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.device.DeviceInstance)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr briefname_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class device_Extension PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.device.Extension) */ {
 public:
  inline device_Extension() : device_Extension(nullptr) {};
  virtual ~device_Extension();

  device_Extension(const device_Extension& from);
  device_Extension(device_Extension&& from) noexcept
    : device_Extension() {
    *this = ::std::move(from);
  }

  inline device_Extension& operator=(const device_Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline device_Extension& operator=(device_Extension&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const device_Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const device_Extension* internal_default_instance() {
    return reinterpret_cast<const device_Extension*>(
               &_device_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(device_Extension& a, device_Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(device_Extension* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(device_Extension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline device_Extension* New() const final {
    return CreateMaybeMessage<device_Extension>(nullptr);
  }

  device_Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<device_Extension>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const device_Extension& from);
  void MergeFrom(const device_Extension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(device_Extension* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.device.Extension";
  }
  protected:
  explicit device_Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.device.Extension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class device PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.device) */ {
 public:
  inline device() : device(nullptr) {};
  virtual ~device();

  device(const device& from);
  device(device&& from) noexcept
    : device() {
    *this = ::std::move(from);
  }

  inline device& operator=(const device& from) {
    CopyFrom(from);
    return *this;
  }
  inline device& operator=(device&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const device& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const device* internal_default_instance() {
    return reinterpret_cast<const device*>(
               &_device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(device& a, device& b) {
    a.Swap(&b);
  }
  inline void Swap(device* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline device* New() const final {
    return CreateMaybeMessage<device>(nullptr);
  }

  device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<device>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const device& from);
  void MergeFrom(const device& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(device* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.device";
  }
  protected:
  explicit device(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef device_DeviceInstance DeviceInstance;
  typedef device_Extension Extension;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 7,
    kTypeFieldNumber = 1,
    kTagFieldNumber = 2,
    kFixedImageFieldNumber = 3,
    kMandatoryFieldNumber = 4,
    kInterfaceFieldNumber = 5,
    kDeviceInstanceFieldNumber = 6,
  };
  // repeated .infoprotobuf.device.Extension extension = 7;
  int extension_size() const;
  private:
  int _internal_extension_size() const;
  public:
  void clear_extension();
  ::infoprotobuf::device_Extension* mutable_extension(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_Extension >*
      mutable_extension();
  private:
  const ::infoprotobuf::device_Extension& _internal_extension(int index) const;
  ::infoprotobuf::device_Extension* _internal_add_extension();
  public:
  const ::infoprotobuf::device_Extension& extension(int index) const;
  ::infoprotobuf::device_Extension* add_extension();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_Extension >&
      extension() const;

  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_type(
      std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string fixed_image = 3;
  bool has_fixed_image() const;
  private:
  bool _internal_has_fixed_image() const;
  public:
  void clear_fixed_image();
  const std::string& fixed_image() const;
  void set_fixed_image(const std::string& value);
  void set_fixed_image(std::string&& value);
  void set_fixed_image(const char* value);
  void set_fixed_image(const char* value, size_t size);
  std::string* mutable_fixed_image();
  std::string* release_fixed_image();
  void set_allocated_fixed_image(std::string* fixed_image);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_fixed_image();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fixed_image(
      std::string* fixed_image);
  private:
  const std::string& _internal_fixed_image() const;
  void _internal_set_fixed_image(const std::string& value);
  std::string* _internal_mutable_fixed_image();
  public:

  // optional string mandatory = 4;
  bool has_mandatory() const;
  private:
  bool _internal_has_mandatory() const;
  public:
  void clear_mandatory();
  const std::string& mandatory() const;
  void set_mandatory(const std::string& value);
  void set_mandatory(std::string&& value);
  void set_mandatory(const char* value);
  void set_mandatory(const char* value, size_t size);
  std::string* mutable_mandatory();
  std::string* release_mandatory();
  void set_allocated_mandatory(std::string* mandatory);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mandatory();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mandatory(
      std::string* mandatory);
  private:
  const std::string& _internal_mandatory() const;
  void _internal_set_mandatory(const std::string& value);
  std::string* _internal_mutable_mandatory();
  public:

  // optional string interface = 5;
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const std::string& interface() const;
  void set_interface(const std::string& value);
  void set_interface(std::string&& value);
  void set_interface(const char* value);
  void set_interface(const char* value, size_t size);
  std::string* mutable_interface();
  std::string* release_interface();
  void set_allocated_interface(std::string* interface);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_interface();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_interface(
      std::string* interface);
  private:
  const std::string& _internal_interface() const;
  void _internal_set_interface(const std::string& value);
  std::string* _internal_mutable_interface();
  public:

  // optional .infoprotobuf.device.DeviceInstance device_instance = 6;
  bool has_device_instance() const;
  private:
  bool _internal_has_device_instance() const;
  public:
  void clear_device_instance();
  const ::infoprotobuf::device_DeviceInstance& device_instance() const;
  ::infoprotobuf::device_DeviceInstance* release_device_instance();
  ::infoprotobuf::device_DeviceInstance* mutable_device_instance();
  void set_allocated_device_instance(::infoprotobuf::device_DeviceInstance* device_instance);
  private:
  const ::infoprotobuf::device_DeviceInstance& _internal_device_instance() const;
  ::infoprotobuf::device_DeviceInstance* _internal_mutable_device_instance();
  public:
  void unsafe_arena_set_allocated_device_instance(
      ::infoprotobuf::device_DeviceInstance* device_instance);
  ::infoprotobuf::device_DeviceInstance* unsafe_arena_release_device_instance();

  // @@protoc_insertion_point(class_scope:infoprotobuf.device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_Extension > extension_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fixed_image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mandatory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_;
  ::infoprotobuf::device_DeviceInstance* device_instance_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class slot_SlotOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.slot.SlotOption) */ {
 public:
  inline slot_SlotOption() : slot_SlotOption(nullptr) {};
  virtual ~slot_SlotOption();

  slot_SlotOption(const slot_SlotOption& from);
  slot_SlotOption(slot_SlotOption&& from) noexcept
    : slot_SlotOption() {
    *this = ::std::move(from);
  }

  inline slot_SlotOption& operator=(const slot_SlotOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline slot_SlotOption& operator=(slot_SlotOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const slot_SlotOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const slot_SlotOption* internal_default_instance() {
    return reinterpret_cast<const slot_SlotOption*>(
               &_slot_SlotOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(slot_SlotOption& a, slot_SlotOption& b) {
    a.Swap(&b);
  }
  inline void Swap(slot_SlotOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(slot_SlotOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline slot_SlotOption* New() const final {
    return CreateMaybeMessage<slot_SlotOption>(nullptr);
  }

  slot_SlotOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<slot_SlotOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const slot_SlotOption& from);
  void MergeFrom(const slot_SlotOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(slot_SlotOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.slot.SlotOption";
  }
  protected:
  explicit slot_SlotOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDevnameFieldNumber = 2,
    kDefaultFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string devname = 2;
  bool has_devname() const;
  private:
  bool _internal_has_devname() const;
  public:
  void clear_devname();
  const std::string& devname() const;
  void set_devname(const std::string& value);
  void set_devname(std::string&& value);
  void set_devname(const char* value);
  void set_devname(const char* value, size_t size);
  std::string* mutable_devname();
  std::string* release_devname();
  void set_allocated_devname(std::string* devname);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_devname();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_devname(
      std::string* devname);
  private:
  const std::string& _internal_devname() const;
  void _internal_set_devname(const std::string& value);
  std::string* _internal_mutable_devname();
  public:

  // optional bool default = 3 [default = false];
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.slot.SlotOption)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devname_;
  bool default__;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class slot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.slot) */ {
 public:
  inline slot() : slot(nullptr) {};
  virtual ~slot();

  slot(const slot& from);
  slot(slot&& from) noexcept
    : slot() {
    *this = ::std::move(from);
  }

  inline slot& operator=(const slot& from) {
    CopyFrom(from);
    return *this;
  }
  inline slot& operator=(slot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const slot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const slot* internal_default_instance() {
    return reinterpret_cast<const slot*>(
               &_slot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(slot& a, slot& b) {
    a.Swap(&b);
  }
  inline void Swap(slot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(slot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline slot* New() const final {
    return CreateMaybeMessage<slot>(nullptr);
  }

  slot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<slot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const slot& from);
  void MergeFrom(const slot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(slot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.slot";
  }
  protected:
  explicit slot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef slot_SlotOption SlotOption;

  // accessors -------------------------------------------------------

  enum : int {
    kSlotoptionFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .infoprotobuf.slot.SlotOption slotoption = 2;
  int slotoption_size() const;
  private:
  int _internal_slotoption_size() const;
  public:
  void clear_slotoption();
  ::infoprotobuf::slot_SlotOption* mutable_slotoption(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot_SlotOption >*
      mutable_slotoption();
  private:
  const ::infoprotobuf::slot_SlotOption& _internal_slotoption(int index) const;
  ::infoprotobuf::slot_SlotOption* _internal_add_slotoption();
  public:
  const ::infoprotobuf::slot_SlotOption& slotoption(int index) const;
  ::infoprotobuf::slot_SlotOption* add_slotoption();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot_SlotOption >&
      slotoption() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.slot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot_SlotOption > slotoption_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class softwarelist PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.softwarelist) */ {
 public:
  inline softwarelist() : softwarelist(nullptr) {};
  virtual ~softwarelist();

  softwarelist(const softwarelist& from);
  softwarelist(softwarelist&& from) noexcept
    : softwarelist() {
    *this = ::std::move(from);
  }

  inline softwarelist& operator=(const softwarelist& from) {
    CopyFrom(from);
    return *this;
  }
  inline softwarelist& operator=(softwarelist&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const softwarelist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const softwarelist* internal_default_instance() {
    return reinterpret_cast<const softwarelist*>(
               &_softwarelist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(softwarelist& a, softwarelist& b) {
    a.Swap(&b);
  }
  inline void Swap(softwarelist* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(softwarelist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline softwarelist* New() const final {
    return CreateMaybeMessage<softwarelist>(nullptr);
  }

  softwarelist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<softwarelist>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const softwarelist& from);
  void MergeFrom(const softwarelist& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(softwarelist* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.softwarelist";
  }
  protected:
  explicit softwarelist(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef softwarelist_Status Status;
  static constexpr Status original =
    softwarelist_Status_original;
  static constexpr Status compatibile =
    softwarelist_Status_compatibile;
  static inline bool Status_IsValid(int value) {
    return softwarelist_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    softwarelist_Status_Status_MIN;
  static constexpr Status Status_MAX =
    softwarelist_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    softwarelist_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return softwarelist_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return softwarelist_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return softwarelist_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kNameFieldNumber = 2,
    kFilterFieldNumber = 4,
    kStatusFieldNumber = 3,
  };
  // required string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_tag();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_tag(
      std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string filter = 4;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  void set_filter(const std::string& value);
  void set_filter(std::string&& value);
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  std::string* mutable_filter();
  std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_filter();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_filter(
      std::string* filter);
  private:
  const std::string& _internal_filter() const;
  void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // required .infoprotobuf.softwarelist.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::infoprotobuf::softwarelist_Status status() const;
  void set_status(::infoprotobuf::softwarelist_Status value);
  private:
  ::infoprotobuf::softwarelist_Status _internal_status() const;
  void _internal_set_status(::infoprotobuf::softwarelist_Status value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.softwarelist)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  int status_;
  friend struct ::TableStruct_info_2eproto;
};
// -------------------------------------------------------------------

class ramoption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infoprotobuf.ramoption) */ {
 public:
  inline ramoption() : ramoption(nullptr) {};
  virtual ~ramoption();

  ramoption(const ramoption& from);
  ramoption(ramoption&& from) noexcept
    : ramoption() {
    *this = ::std::move(from);
  }

  inline ramoption& operator=(const ramoption& from) {
    CopyFrom(from);
    return *this;
  }
  inline ramoption& operator=(ramoption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ramoption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ramoption* internal_default_instance() {
    return reinterpret_cast<const ramoption*>(
               &_ramoption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ramoption& a, ramoption& b) {
    a.Swap(&b);
  }
  inline void Swap(ramoption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ramoption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ramoption* New() const final {
    return CreateMaybeMessage<ramoption>(nullptr);
  }

  ramoption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ramoption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ramoption& from);
  void MergeFrom(const ramoption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ramoption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infoprotobuf.ramoption";
  }
  protected:
  explicit ramoption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_info_2eproto);
    return ::descriptor_table_info_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool default = 2;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  bool default_() const;
  void set_default_(bool value);
  private:
  bool _internal_default_() const;
  void _internal_set_default_(bool value);
  public:

  // optional uint32 value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:infoprotobuf.ramoption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool default__;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  friend struct ::TableStruct_info_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// mame

// optional string build = 1;
inline bool mame::_internal_has_build() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mame::has_build() const {
  return _internal_has_build();
}
inline void mame::clear_build() {
  build_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mame::build() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.mame.build)
  return _internal_build();
}
inline void mame::set_build(const std::string& value) {
  _internal_set_build(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.mame.build)
}
inline std::string* mame::mutable_build() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.mame.build)
  return _internal_mutable_build();
}
inline const std::string& mame::_internal_build() const {
  return build_.Get();
}
inline void mame::_internal_set_build(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void mame::set_build(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  build_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.mame.build)
}
inline void mame::set_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.mame.build)
}
inline void mame::set_build(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.mame.build)
}
inline std::string* mame::_internal_mutable_build() {
  _has_bits_[0] |= 0x00000001u;
  return build_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* mame::release_build() {
  // @@protoc_insertion_point(field_release:infoprotobuf.mame.build)
  if (!_internal_has_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return build_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void mame::set_allocated_build(std::string* build) {
  if (build != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  build_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.mame.build)
}
inline std::string* mame::unsafe_arena_release_build() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.mame.build)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return build_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void mame::unsafe_arena_set_allocated_build(
    std::string* build) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (build != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  build_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      build, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.mame.build)
}

// optional bool debug = 2 [default = false];
inline bool mame::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mame::has_debug() const {
  return _internal_has_debug();
}
inline void mame::clear_debug() {
  debug_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool mame::_internal_debug() const {
  return debug_;
}
inline bool mame::debug() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.mame.debug)
  return _internal_debug();
}
inline void mame::_internal_set_debug(bool value) {
  _has_bits_[0] |= 0x00000002u;
  debug_ = value;
}
inline void mame::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.mame.debug)
}

// required uint32 mameconfig = 3;
inline bool mame::_internal_has_mameconfig() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool mame::has_mameconfig() const {
  return _internal_has_mameconfig();
}
inline void mame::clear_mameconfig() {
  mameconfig_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 mame::_internal_mameconfig() const {
  return mameconfig_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 mame::mameconfig() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.mame.mameconfig)
  return _internal_mameconfig();
}
inline void mame::_internal_set_mameconfig(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  mameconfig_ = value;
}
inline void mame::set_mameconfig(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mameconfig(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.mame.mameconfig)
}

// repeated .infoprotobuf.machine machine = 4;
inline int mame::_internal_machine_size() const {
  return machine_.size();
}
inline int mame::machine_size() const {
  return _internal_machine_size();
}
inline void mame::clear_machine() {
  machine_.Clear();
}
inline ::infoprotobuf::machine* mame::mutable_machine(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.mame.machine)
  return machine_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::machine >*
mame::mutable_machine() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.mame.machine)
  return &machine_;
}
inline const ::infoprotobuf::machine& mame::_internal_machine(int index) const {
  return machine_.Get(index);
}
inline const ::infoprotobuf::machine& mame::machine(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.mame.machine)
  return _internal_machine(index);
}
inline ::infoprotobuf::machine* mame::_internal_add_machine() {
  return machine_.Add();
}
inline ::infoprotobuf::machine* mame::add_machine() {
  // @@protoc_insertion_point(field_add:infoprotobuf.mame.machine)
  return _internal_add_machine();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::machine >&
mame::machine() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.mame.machine)
  return machine_;
}

// -------------------------------------------------------------------

// machine

// required string name = 1;
inline bool machine::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool machine::has_name() const {
  return _internal_has_name();
}
inline void machine::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& machine::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.name)
  return _internal_name();
}
inline void machine::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.name)
}
inline std::string* machine::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.name)
  return _internal_mutable_name();
}
inline const std::string& machine::_internal_name() const {
  return name_.Get();
}
inline void machine::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.name)
}
inline void machine::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.name)
}
inline void machine::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.name)
}
inline std::string* machine::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.name)
}
inline std::string* machine::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.name)
}

// optional string sourcefile = 2;
inline bool machine::_internal_has_sourcefile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool machine::has_sourcefile() const {
  return _internal_has_sourcefile();
}
inline void machine::clear_sourcefile() {
  sourcefile_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& machine::sourcefile() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.sourcefile)
  return _internal_sourcefile();
}
inline void machine::set_sourcefile(const std::string& value) {
  _internal_set_sourcefile(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.sourcefile)
}
inline std::string* machine::mutable_sourcefile() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.sourcefile)
  return _internal_mutable_sourcefile();
}
inline const std::string& machine::_internal_sourcefile() const {
  return sourcefile_.Get();
}
inline void machine::_internal_set_sourcefile(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sourcefile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_sourcefile(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sourcefile_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.sourcefile)
}
inline void machine::set_sourcefile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sourcefile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.sourcefile)
}
inline void machine::set_sourcefile(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sourcefile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.sourcefile)
}
inline std::string* machine::_internal_mutable_sourcefile() {
  _has_bits_[0] |= 0x00000002u;
  return sourcefile_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_sourcefile() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.sourcefile)
  if (!_internal_has_sourcefile()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sourcefile_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_sourcefile(std::string* sourcefile) {
  if (sourcefile != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourcefile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcefile,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.sourcefile)
}
inline std::string* machine::unsafe_arena_release_sourcefile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.sourcefile)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return sourcefile_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_sourcefile(
    std::string* sourcefile) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sourcefile != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourcefile_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sourcefile, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.sourcefile)
}

// optional bool isbios = 3 [default = false];
inline bool machine::_internal_has_isbios() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool machine::has_isbios() const {
  return _internal_has_isbios();
}
inline void machine::clear_isbios() {
  isbios_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool machine::_internal_isbios() const {
  return isbios_;
}
inline bool machine::isbios() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.isbios)
  return _internal_isbios();
}
inline void machine::_internal_set_isbios(bool value) {
  _has_bits_[0] |= 0x00000400u;
  isbios_ = value;
}
inline void machine::set_isbios(bool value) {
  _internal_set_isbios(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.isbios)
}

// optional bool isdevice = 4 [default = false];
inline bool machine::_internal_has_isdevice() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool machine::has_isdevice() const {
  return _internal_has_isdevice();
}
inline void machine::clear_isdevice() {
  isdevice_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool machine::_internal_isdevice() const {
  return isdevice_;
}
inline bool machine::isdevice() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.isdevice)
  return _internal_isdevice();
}
inline void machine::_internal_set_isdevice(bool value) {
  _has_bits_[0] |= 0x00000800u;
  isdevice_ = value;
}
inline void machine::set_isdevice(bool value) {
  _internal_set_isdevice(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.isdevice)
}

// optional bool ismechanical = 5 [default = false];
inline bool machine::_internal_has_ismechanical() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool machine::has_ismechanical() const {
  return _internal_has_ismechanical();
}
inline void machine::clear_ismechanical() {
  ismechanical_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool machine::_internal_ismechanical() const {
  return ismechanical_;
}
inline bool machine::ismechanical() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.ismechanical)
  return _internal_ismechanical();
}
inline void machine::_internal_set_ismechanical(bool value) {
  _has_bits_[0] |= 0x00001000u;
  ismechanical_ = value;
}
inline void machine::set_ismechanical(bool value) {
  _internal_set_ismechanical(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.ismechanical)
}

// optional bool runnable = 6 [default = true];
inline bool machine::_internal_has_runnable() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool machine::has_runnable() const {
  return _internal_has_runnable();
}
inline void machine::clear_runnable() {
  runnable_ = true;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool machine::_internal_runnable() const {
  return runnable_;
}
inline bool machine::runnable() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.runnable)
  return _internal_runnable();
}
inline void machine::_internal_set_runnable(bool value) {
  _has_bits_[0] |= 0x00002000u;
  runnable_ = value;
}
inline void machine::set_runnable(bool value) {
  _internal_set_runnable(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.runnable)
}

// optional string cloneof = 7;
inline bool machine::_internal_has_cloneof() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool machine::has_cloneof() const {
  return _internal_has_cloneof();
}
inline void machine::clear_cloneof() {
  cloneof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& machine::cloneof() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.cloneof)
  return _internal_cloneof();
}
inline void machine::set_cloneof(const std::string& value) {
  _internal_set_cloneof(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.cloneof)
}
inline std::string* machine::mutable_cloneof() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.cloneof)
  return _internal_mutable_cloneof();
}
inline const std::string& machine::_internal_cloneof() const {
  return cloneof_.Get();
}
inline void machine::_internal_set_cloneof(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cloneof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_cloneof(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  cloneof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.cloneof)
}
inline void machine::set_cloneof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  cloneof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.cloneof)
}
inline void machine::set_cloneof(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  cloneof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.cloneof)
}
inline std::string* machine::_internal_mutable_cloneof() {
  _has_bits_[0] |= 0x00000004u;
  return cloneof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_cloneof() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.cloneof)
  if (!_internal_has_cloneof()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return cloneof_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_cloneof(std::string* cloneof) {
  if (cloneof != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cloneof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cloneof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.cloneof)
}
inline std::string* machine::unsafe_arena_release_cloneof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.cloneof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return cloneof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_cloneof(
    std::string* cloneof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (cloneof != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cloneof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      cloneof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.cloneof)
}

// optional string romof = 8;
inline bool machine::_internal_has_romof() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool machine::has_romof() const {
  return _internal_has_romof();
}
inline void machine::clear_romof() {
  romof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& machine::romof() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.romof)
  return _internal_romof();
}
inline void machine::set_romof(const std::string& value) {
  _internal_set_romof(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.romof)
}
inline std::string* machine::mutable_romof() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.romof)
  return _internal_mutable_romof();
}
inline const std::string& machine::_internal_romof() const {
  return romof_.Get();
}
inline void machine::_internal_set_romof(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  romof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_romof(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  romof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.romof)
}
inline void machine::set_romof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  romof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.romof)
}
inline void machine::set_romof(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  romof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.romof)
}
inline std::string* machine::_internal_mutable_romof() {
  _has_bits_[0] |= 0x00000008u;
  return romof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_romof() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.romof)
  if (!_internal_has_romof()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return romof_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_romof(std::string* romof) {
  if (romof != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  romof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), romof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.romof)
}
inline std::string* machine::unsafe_arena_release_romof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.romof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return romof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_romof(
    std::string* romof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (romof != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  romof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      romof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.romof)
}

// optional string sampleof = 9;
inline bool machine::_internal_has_sampleof() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool machine::has_sampleof() const {
  return _internal_has_sampleof();
}
inline void machine::clear_sampleof() {
  sampleof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& machine::sampleof() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.sampleof)
  return _internal_sampleof();
}
inline void machine::set_sampleof(const std::string& value) {
  _internal_set_sampleof(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.sampleof)
}
inline std::string* machine::mutable_sampleof() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.sampleof)
  return _internal_mutable_sampleof();
}
inline const std::string& machine::_internal_sampleof() const {
  return sampleof_.Get();
}
inline void machine::_internal_set_sampleof(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  sampleof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_sampleof(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  sampleof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.sampleof)
}
inline void machine::set_sampleof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  sampleof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.sampleof)
}
inline void machine::set_sampleof(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  sampleof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.sampleof)
}
inline std::string* machine::_internal_mutable_sampleof() {
  _has_bits_[0] |= 0x00000010u;
  return sampleof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_sampleof() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.sampleof)
  if (!_internal_has_sampleof()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return sampleof_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_sampleof(std::string* sampleof) {
  if (sampleof != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sampleof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sampleof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.sampleof)
}
inline std::string* machine::unsafe_arena_release_sampleof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.sampleof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return sampleof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_sampleof(
    std::string* sampleof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sampleof != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sampleof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sampleof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.sampleof)
}

// required string description = 10;
inline bool machine::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool machine::has_description() const {
  return _internal_has_description();
}
inline void machine::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& machine::description() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.description)
  return _internal_description();
}
inline void machine::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.description)
}
inline std::string* machine::mutable_description() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.description)
  return _internal_mutable_description();
}
inline const std::string& machine::_internal_description() const {
  return description_.Get();
}
inline void machine::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.description)
}
inline void machine::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.description)
}
inline void machine::set_description(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.description)
}
inline std::string* machine::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000020u;
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_description() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.description)
}
inline std::string* machine::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.description)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000020u;
  return description_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_description(
    std::string* description) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  description_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      description, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.description)
}

// optional string year = 11;
inline bool machine::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool machine::has_year() const {
  return _internal_has_year();
}
inline void machine::clear_year() {
  year_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& machine::year() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.year)
  return _internal_year();
}
inline void machine::set_year(const std::string& value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.year)
}
inline std::string* machine::mutable_year() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.year)
  return _internal_mutable_year();
}
inline const std::string& machine::_internal_year() const {
  return year_.Get();
}
inline void machine::_internal_set_year(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_year(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  year_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.year)
}
inline void machine::set_year(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.year)
}
inline void machine::set_year(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.year)
}
inline std::string* machine::_internal_mutable_year() {
  _has_bits_[0] |= 0x00000040u;
  return year_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_year() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.year)
  if (!_internal_has_year()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return year_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.year)
}
inline std::string* machine::unsafe_arena_release_year() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.year)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000040u;
  return year_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_year(
    std::string* year) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (year != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  year_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      year, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.year)
}

// optional string manufacturer = 12;
inline bool machine::_internal_has_manufacturer() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool machine::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void machine::clear_manufacturer() {
  manufacturer_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& machine::manufacturer() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.manufacturer)
  return _internal_manufacturer();
}
inline void machine::set_manufacturer(const std::string& value) {
  _internal_set_manufacturer(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.machine.manufacturer)
}
inline std::string* machine::mutable_manufacturer() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.manufacturer)
  return _internal_mutable_manufacturer();
}
inline const std::string& machine::_internal_manufacturer() const {
  return manufacturer_.Get();
}
inline void machine::_internal_set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  manufacturer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void machine::set_manufacturer(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  manufacturer_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.machine.manufacturer)
}
inline void machine::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  manufacturer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.machine.manufacturer)
}
inline void machine::set_manufacturer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  manufacturer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.machine.manufacturer)
}
inline std::string* machine::_internal_mutable_manufacturer() {
  _has_bits_[0] |= 0x00000080u;
  return manufacturer_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* machine::release_manufacturer() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return manufacturer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void machine::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  manufacturer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manufacturer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.manufacturer)
}
inline std::string* machine::unsafe_arena_release_manufacturer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.machine.manufacturer)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000080u;
  return manufacturer_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void machine::unsafe_arena_set_allocated_manufacturer(
    std::string* manufacturer) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  manufacturer_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      manufacturer, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.manufacturer)
}

// repeated .infoprotobuf.biosset biosset = 13;
inline int machine::_internal_biosset_size() const {
  return biosset_.size();
}
inline int machine::biosset_size() const {
  return _internal_biosset_size();
}
inline void machine::clear_biosset() {
  biosset_.Clear();
}
inline ::infoprotobuf::biosset* machine::mutable_biosset(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.biosset)
  return biosset_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::biosset >*
machine::mutable_biosset() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.biosset)
  return &biosset_;
}
inline const ::infoprotobuf::biosset& machine::_internal_biosset(int index) const {
  return biosset_.Get(index);
}
inline const ::infoprotobuf::biosset& machine::biosset(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.biosset)
  return _internal_biosset(index);
}
inline ::infoprotobuf::biosset* machine::_internal_add_biosset() {
  return biosset_.Add();
}
inline ::infoprotobuf::biosset* machine::add_biosset() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.biosset)
  return _internal_add_biosset();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::biosset >&
machine::biosset() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.biosset)
  return biosset_;
}

// repeated .infoprotobuf.rom rom = 14;
inline int machine::_internal_rom_size() const {
  return rom_.size();
}
inline int machine::rom_size() const {
  return _internal_rom_size();
}
inline void machine::clear_rom() {
  rom_.Clear();
}
inline ::infoprotobuf::rom* machine::mutable_rom(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.rom)
  return rom_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::rom >*
machine::mutable_rom() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.rom)
  return &rom_;
}
inline const ::infoprotobuf::rom& machine::_internal_rom(int index) const {
  return rom_.Get(index);
}
inline const ::infoprotobuf::rom& machine::rom(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.rom)
  return _internal_rom(index);
}
inline ::infoprotobuf::rom* machine::_internal_add_rom() {
  return rom_.Add();
}
inline ::infoprotobuf::rom* machine::add_rom() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.rom)
  return _internal_add_rom();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::rom >&
machine::rom() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.rom)
  return rom_;
}

// repeated .infoprotobuf.disk disk = 15;
inline int machine::_internal_disk_size() const {
  return disk_.size();
}
inline int machine::disk_size() const {
  return _internal_disk_size();
}
inline void machine::clear_disk() {
  disk_.Clear();
}
inline ::infoprotobuf::disk* machine::mutable_disk(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.disk)
  return disk_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::disk >*
machine::mutable_disk() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.disk)
  return &disk_;
}
inline const ::infoprotobuf::disk& machine::_internal_disk(int index) const {
  return disk_.Get(index);
}
inline const ::infoprotobuf::disk& machine::disk(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.disk)
  return _internal_disk(index);
}
inline ::infoprotobuf::disk* machine::_internal_add_disk() {
  return disk_.Add();
}
inline ::infoprotobuf::disk* machine::add_disk() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.disk)
  return _internal_add_disk();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::disk >&
machine::disk() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.disk)
  return disk_;
}

// repeated .infoprotobuf.device_ref device_ref = 16;
inline int machine::_internal_device_ref_size() const {
  return device_ref_.size();
}
inline int machine::device_ref_size() const {
  return _internal_device_ref_size();
}
inline void machine::clear_device_ref() {
  device_ref_.Clear();
}
inline ::infoprotobuf::device_ref* machine::mutable_device_ref(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.device_ref)
  return device_ref_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_ref >*
machine::mutable_device_ref() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.device_ref)
  return &device_ref_;
}
inline const ::infoprotobuf::device_ref& machine::_internal_device_ref(int index) const {
  return device_ref_.Get(index);
}
inline const ::infoprotobuf::device_ref& machine::device_ref(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.device_ref)
  return _internal_device_ref(index);
}
inline ::infoprotobuf::device_ref* machine::_internal_add_device_ref() {
  return device_ref_.Add();
}
inline ::infoprotobuf::device_ref* machine::add_device_ref() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.device_ref)
  return _internal_add_device_ref();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_ref >&
machine::device_ref() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.device_ref)
  return device_ref_;
}

// repeated .infoprotobuf.sample sample = 17;
inline int machine::_internal_sample_size() const {
  return sample_.size();
}
inline int machine::sample_size() const {
  return _internal_sample_size();
}
inline void machine::clear_sample() {
  sample_.Clear();
}
inline ::infoprotobuf::sample* machine::mutable_sample(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.sample)
  return sample_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::sample >*
machine::mutable_sample() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.sample)
  return &sample_;
}
inline const ::infoprotobuf::sample& machine::_internal_sample(int index) const {
  return sample_.Get(index);
}
inline const ::infoprotobuf::sample& machine::sample(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.sample)
  return _internal_sample(index);
}
inline ::infoprotobuf::sample* machine::_internal_add_sample() {
  return sample_.Add();
}
inline ::infoprotobuf::sample* machine::add_sample() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.sample)
  return _internal_add_sample();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::sample >&
machine::sample() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.sample)
  return sample_;
}

// repeated .infoprotobuf.chip chip = 18;
inline int machine::_internal_chip_size() const {
  return chip_.size();
}
inline int machine::chip_size() const {
  return _internal_chip_size();
}
inline void machine::clear_chip() {
  chip_.Clear();
}
inline ::infoprotobuf::chip* machine::mutable_chip(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.chip)
  return chip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::chip >*
machine::mutable_chip() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.chip)
  return &chip_;
}
inline const ::infoprotobuf::chip& machine::_internal_chip(int index) const {
  return chip_.Get(index);
}
inline const ::infoprotobuf::chip& machine::chip(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.chip)
  return _internal_chip(index);
}
inline ::infoprotobuf::chip* machine::_internal_add_chip() {
  return chip_.Add();
}
inline ::infoprotobuf::chip* machine::add_chip() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.chip)
  return _internal_add_chip();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::chip >&
machine::chip() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.chip)
  return chip_;
}

// repeated .infoprotobuf.display display = 19;
inline int machine::_internal_display_size() const {
  return display_.size();
}
inline int machine::display_size() const {
  return _internal_display_size();
}
inline void machine::clear_display() {
  display_.Clear();
}
inline ::infoprotobuf::display* machine::mutable_display(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.display)
  return display_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::display >*
machine::mutable_display() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.display)
  return &display_;
}
inline const ::infoprotobuf::display& machine::_internal_display(int index) const {
  return display_.Get(index);
}
inline const ::infoprotobuf::display& machine::display(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.display)
  return _internal_display(index);
}
inline ::infoprotobuf::display* machine::_internal_add_display() {
  return display_.Add();
}
inline ::infoprotobuf::display* machine::add_display() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.display)
  return _internal_add_display();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::display >&
machine::display() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.display)
  return display_;
}

// optional .infoprotobuf.sound sound = 20;
inline bool machine::_internal_has_sound() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || sound_ != nullptr);
  return value;
}
inline bool machine::has_sound() const {
  return _internal_has_sound();
}
inline void machine::clear_sound() {
  if (sound_ != nullptr) sound_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::infoprotobuf::sound& machine::_internal_sound() const {
  const ::infoprotobuf::sound* p = sound_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::sound*>(
      &::infoprotobuf::_sound_default_instance_);
}
inline const ::infoprotobuf::sound& machine::sound() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.sound)
  return _internal_sound();
}
inline void machine::unsafe_arena_set_allocated_sound(
    ::infoprotobuf::sound* sound) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sound_);
  }
  sound_ = sound;
  if (sound) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.sound)
}
inline ::infoprotobuf::sound* machine::release_sound() {
  auto temp = unsafe_arena_release_sound();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::sound* machine::unsafe_arena_release_sound() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.sound)
  _has_bits_[0] &= ~0x00000100u;
  ::infoprotobuf::sound* temp = sound_;
  sound_ = nullptr;
  return temp;
}
inline ::infoprotobuf::sound* machine::_internal_mutable_sound() {
  _has_bits_[0] |= 0x00000100u;
  if (sound_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::sound>(GetArena());
    sound_ = p;
  }
  return sound_;
}
inline ::infoprotobuf::sound* machine::mutable_sound() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.sound)
  return _internal_mutable_sound();
}
inline void machine::set_allocated_sound(::infoprotobuf::sound* sound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sound_;
  }
  if (sound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sound);
    if (message_arena != submessage_arena) {
      sound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sound, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  sound_ = sound;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.sound)
}

// optional .infoprotobuf.input input = 21;
inline bool machine::_internal_has_input() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || input_ != nullptr);
  return value;
}
inline bool machine::has_input() const {
  return _internal_has_input();
}
inline void machine::clear_input() {
  if (input_ != nullptr) input_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::infoprotobuf::input& machine::_internal_input() const {
  const ::infoprotobuf::input* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::input*>(
      &::infoprotobuf::_input_default_instance_);
}
inline const ::infoprotobuf::input& machine::input() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.input)
  return _internal_input();
}
inline void machine::unsafe_arena_set_allocated_input(
    ::infoprotobuf::input* input) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_);
  }
  input_ = input;
  if (input) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.machine.input)
}
inline ::infoprotobuf::input* machine::release_input() {
  auto temp = unsafe_arena_release_input();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::input* machine::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:infoprotobuf.machine.input)
  _has_bits_[0] &= ~0x00000200u;
  ::infoprotobuf::input* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::infoprotobuf::input* machine::_internal_mutable_input() {
  _has_bits_[0] |= 0x00000200u;
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::input>(GetArena());
    input_ = p;
  }
  return input_;
}
inline ::infoprotobuf::input* machine::mutable_input() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.input)
  return _internal_mutable_input();
}
inline void machine::set_allocated_input(::infoprotobuf::input* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.machine.input)
}

// repeated .infoprotobuf.dipswitch dipswitch = 22;
inline int machine::_internal_dipswitch_size() const {
  return dipswitch_.size();
}
inline int machine::dipswitch_size() const {
  return _internal_dipswitch_size();
}
inline void machine::clear_dipswitch() {
  dipswitch_.Clear();
}
inline ::infoprotobuf::dipswitch* machine::mutable_dipswitch(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.dipswitch)
  return dipswitch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch >*
machine::mutable_dipswitch() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.dipswitch)
  return &dipswitch_;
}
inline const ::infoprotobuf::dipswitch& machine::_internal_dipswitch(int index) const {
  return dipswitch_.Get(index);
}
inline const ::infoprotobuf::dipswitch& machine::dipswitch(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.dipswitch)
  return _internal_dipswitch(index);
}
inline ::infoprotobuf::dipswitch* machine::_internal_add_dipswitch() {
  return dipswitch_.Add();
}
inline ::infoprotobuf::dipswitch* machine::add_dipswitch() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.dipswitch)
  return _internal_add_dipswitch();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch >&
machine::dipswitch() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.dipswitch)
  return dipswitch_;
}

// repeated .infoprotobuf.configuration configuration = 23;
inline int machine::_internal_configuration_size() const {
  return configuration_.size();
}
inline int machine::configuration_size() const {
  return _internal_configuration_size();
}
inline void machine::clear_configuration() {
  configuration_.Clear();
}
inline ::infoprotobuf::configuration* machine::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration >*
machine::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.configuration)
  return &configuration_;
}
inline const ::infoprotobuf::configuration& machine::_internal_configuration(int index) const {
  return configuration_.Get(index);
}
inline const ::infoprotobuf::configuration& machine::configuration(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.configuration)
  return _internal_configuration(index);
}
inline ::infoprotobuf::configuration* machine::_internal_add_configuration() {
  return configuration_.Add();
}
inline ::infoprotobuf::configuration* machine::add_configuration() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.configuration)
  return _internal_add_configuration();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration >&
machine::configuration() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.configuration)
  return configuration_;
}

// repeated .infoprotobuf.port port = 24;
inline int machine::_internal_port_size() const {
  return port_.size();
}
inline int machine::port_size() const {
  return _internal_port_size();
}
inline void machine::clear_port() {
  port_.Clear();
}
inline ::infoprotobuf::port* machine::mutable_port(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.port)
  return port_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port >*
machine::mutable_port() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.port)
  return &port_;
}
inline const ::infoprotobuf::port& machine::_internal_port(int index) const {
  return port_.Get(index);
}
inline const ::infoprotobuf::port& machine::port(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.port)
  return _internal_port(index);
}
inline ::infoprotobuf::port* machine::_internal_add_port() {
  return port_.Add();
}
inline ::infoprotobuf::port* machine::add_port() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.port)
  return _internal_add_port();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port >&
machine::port() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.port)
  return port_;
}

// repeated .infoprotobuf.adjuster adjuster = 25;
inline int machine::_internal_adjuster_size() const {
  return adjuster_.size();
}
inline int machine::adjuster_size() const {
  return _internal_adjuster_size();
}
inline void machine::clear_adjuster() {
  adjuster_.Clear();
}
inline ::infoprotobuf::adjuster* machine::mutable_adjuster(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.adjuster)
  return adjuster_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::adjuster >*
machine::mutable_adjuster() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.adjuster)
  return &adjuster_;
}
inline const ::infoprotobuf::adjuster& machine::_internal_adjuster(int index) const {
  return adjuster_.Get(index);
}
inline const ::infoprotobuf::adjuster& machine::adjuster(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.adjuster)
  return _internal_adjuster(index);
}
inline ::infoprotobuf::adjuster* machine::_internal_add_adjuster() {
  return adjuster_.Add();
}
inline ::infoprotobuf::adjuster* machine::add_adjuster() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.adjuster)
  return _internal_add_adjuster();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::adjuster >&
machine::adjuster() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.adjuster)
  return adjuster_;
}

// repeated .infoprotobuf.driver driver = 26;
inline int machine::_internal_driver_size() const {
  return driver_.size();
}
inline int machine::driver_size() const {
  return _internal_driver_size();
}
inline void machine::clear_driver() {
  driver_.Clear();
}
inline ::infoprotobuf::driver* machine::mutable_driver(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.driver)
  return driver_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::driver >*
machine::mutable_driver() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.driver)
  return &driver_;
}
inline const ::infoprotobuf::driver& machine::_internal_driver(int index) const {
  return driver_.Get(index);
}
inline const ::infoprotobuf::driver& machine::driver(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.driver)
  return _internal_driver(index);
}
inline ::infoprotobuf::driver* machine::_internal_add_driver() {
  return driver_.Add();
}
inline ::infoprotobuf::driver* machine::add_driver() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.driver)
  return _internal_add_driver();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::driver >&
machine::driver() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.driver)
  return driver_;
}

// repeated .infoprotobuf.feature feature = 27;
inline int machine::_internal_feature_size() const {
  return feature_.size();
}
inline int machine::feature_size() const {
  return _internal_feature_size();
}
inline void machine::clear_feature() {
  feature_.Clear();
}
inline ::infoprotobuf::feature* machine::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.feature)
  return feature_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::feature >*
machine::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.feature)
  return &feature_;
}
inline const ::infoprotobuf::feature& machine::_internal_feature(int index) const {
  return feature_.Get(index);
}
inline const ::infoprotobuf::feature& machine::feature(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.feature)
  return _internal_feature(index);
}
inline ::infoprotobuf::feature* machine::_internal_add_feature() {
  return feature_.Add();
}
inline ::infoprotobuf::feature* machine::add_feature() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.feature)
  return _internal_add_feature();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::feature >&
machine::feature() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.feature)
  return feature_;
}

// repeated .infoprotobuf.device device = 28;
inline int machine::_internal_device_size() const {
  return device_.size();
}
inline int machine::device_size() const {
  return _internal_device_size();
}
inline void machine::clear_device() {
  device_.Clear();
}
inline ::infoprotobuf::device* machine::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.device)
  return device_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device >*
machine::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.device)
  return &device_;
}
inline const ::infoprotobuf::device& machine::_internal_device(int index) const {
  return device_.Get(index);
}
inline const ::infoprotobuf::device& machine::device(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.device)
  return _internal_device(index);
}
inline ::infoprotobuf::device* machine::_internal_add_device() {
  return device_.Add();
}
inline ::infoprotobuf::device* machine::add_device() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.device)
  return _internal_add_device();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device >&
machine::device() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.device)
  return device_;
}

// repeated .infoprotobuf.slot slot = 29;
inline int machine::_internal_slot_size() const {
  return slot_.size();
}
inline int machine::slot_size() const {
  return _internal_slot_size();
}
inline void machine::clear_slot() {
  slot_.Clear();
}
inline ::infoprotobuf::slot* machine::mutable_slot(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.slot)
  return slot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot >*
machine::mutable_slot() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.slot)
  return &slot_;
}
inline const ::infoprotobuf::slot& machine::_internal_slot(int index) const {
  return slot_.Get(index);
}
inline const ::infoprotobuf::slot& machine::slot(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.slot)
  return _internal_slot(index);
}
inline ::infoprotobuf::slot* machine::_internal_add_slot() {
  return slot_.Add();
}
inline ::infoprotobuf::slot* machine::add_slot() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.slot)
  return _internal_add_slot();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot >&
machine::slot() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.slot)
  return slot_;
}

// repeated .infoprotobuf.softwarelist softwarelist = 30;
inline int machine::_internal_softwarelist_size() const {
  return softwarelist_.size();
}
inline int machine::softwarelist_size() const {
  return _internal_softwarelist_size();
}
inline void machine::clear_softwarelist() {
  softwarelist_.Clear();
}
inline ::infoprotobuf::softwarelist* machine::mutable_softwarelist(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.softwarelist)
  return softwarelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::softwarelist >*
machine::mutable_softwarelist() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.softwarelist)
  return &softwarelist_;
}
inline const ::infoprotobuf::softwarelist& machine::_internal_softwarelist(int index) const {
  return softwarelist_.Get(index);
}
inline const ::infoprotobuf::softwarelist& machine::softwarelist(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.softwarelist)
  return _internal_softwarelist(index);
}
inline ::infoprotobuf::softwarelist* machine::_internal_add_softwarelist() {
  return softwarelist_.Add();
}
inline ::infoprotobuf::softwarelist* machine::add_softwarelist() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.softwarelist)
  return _internal_add_softwarelist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::softwarelist >&
machine::softwarelist() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.softwarelist)
  return softwarelist_;
}

// repeated .infoprotobuf.ramoption ramoption = 31;
inline int machine::_internal_ramoption_size() const {
  return ramoption_.size();
}
inline int machine::ramoption_size() const {
  return _internal_ramoption_size();
}
inline void machine::clear_ramoption() {
  ramoption_.Clear();
}
inline ::infoprotobuf::ramoption* machine::mutable_ramoption(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.machine.ramoption)
  return ramoption_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::ramoption >*
machine::mutable_ramoption() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.machine.ramoption)
  return &ramoption_;
}
inline const ::infoprotobuf::ramoption& machine::_internal_ramoption(int index) const {
  return ramoption_.Get(index);
}
inline const ::infoprotobuf::ramoption& machine::ramoption(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.machine.ramoption)
  return _internal_ramoption(index);
}
inline ::infoprotobuf::ramoption* machine::_internal_add_ramoption() {
  return ramoption_.Add();
}
inline ::infoprotobuf::ramoption* machine::add_ramoption() {
  // @@protoc_insertion_point(field_add:infoprotobuf.machine.ramoption)
  return _internal_add_ramoption();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::ramoption >&
machine::ramoption() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.machine.ramoption)
  return ramoption_;
}

// -------------------------------------------------------------------

// biosset

// required string name = 1;
inline bool biosset::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool biosset::has_name() const {
  return _internal_has_name();
}
inline void biosset::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& biosset::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.biosset.name)
  return _internal_name();
}
inline void biosset::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.biosset.name)
}
inline std::string* biosset::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.biosset.name)
  return _internal_mutable_name();
}
inline const std::string& biosset::_internal_name() const {
  return name_.Get();
}
inline void biosset::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void biosset::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.biosset.name)
}
inline void biosset::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.biosset.name)
}
inline void biosset::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.biosset.name)
}
inline std::string* biosset::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* biosset::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.biosset.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void biosset::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.biosset.name)
}
inline std::string* biosset::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.biosset.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void biosset::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.biosset.name)
}

// required string description = 2;
inline bool biosset::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool biosset::has_description() const {
  return _internal_has_description();
}
inline void biosset::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& biosset::description() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.biosset.description)
  return _internal_description();
}
inline void biosset::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.biosset.description)
}
inline std::string* biosset::mutable_description() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.biosset.description)
  return _internal_mutable_description();
}
inline const std::string& biosset::_internal_description() const {
  return description_.Get();
}
inline void biosset::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void biosset::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.biosset.description)
}
inline void biosset::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.biosset.description)
}
inline void biosset::set_description(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.biosset.description)
}
inline std::string* biosset::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* biosset::release_description() {
  // @@protoc_insertion_point(field_release:infoprotobuf.biosset.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void biosset::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.biosset.description)
}
inline std::string* biosset::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.biosset.description)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return description_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void biosset::unsafe_arena_set_allocated_description(
    std::string* description) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      description, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.biosset.description)
}

// optional bool default = 3 [default = false];
inline bool biosset::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool biosset::has_default_() const {
  return _internal_has_default_();
}
inline void biosset::clear_default_() {
  default__ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool biosset::_internal_default_() const {
  return default__;
}
inline bool biosset::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.biosset.default)
  return _internal_default_();
}
inline void biosset::_internal_set_default_(bool value) {
  _has_bits_[0] |= 0x00000004u;
  default__ = value;
}
inline void biosset::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.biosset.default)
}

// -------------------------------------------------------------------

// rom

// required string name = 1;
inline bool rom::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rom::has_name() const {
  return _internal_has_name();
}
inline void rom::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& rom::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.name)
  return _internal_name();
}
inline void rom::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.name)
}
inline std::string* rom::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.name)
  return _internal_mutable_name();
}
inline const std::string& rom::_internal_name() const {
  return name_.Get();
}
inline void rom::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.name)
}
inline void rom::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.name)
}
inline void rom::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.name)
}
inline std::string* rom::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.name)
}
inline std::string* rom::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.name)
}

// optional string sha1 = 2;
inline bool rom::_internal_has_sha1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rom::has_sha1() const {
  return _internal_has_sha1();
}
inline void rom::clear_sha1() {
  sha1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& rom::sha1() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.sha1)
  return _internal_sha1();
}
inline void rom::set_sha1(const std::string& value) {
  _internal_set_sha1(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.sha1)
}
inline std::string* rom::mutable_sha1() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.sha1)
  return _internal_mutable_sha1();
}
inline const std::string& rom::_internal_sha1() const {
  return sha1_.Get();
}
inline void rom::_internal_set_sha1(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_sha1(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.sha1)
}
inline void rom::set_sha1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.sha1)
}
inline void rom::set_sha1(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.sha1)
}
inline std::string* rom::_internal_mutable_sha1() {
  _has_bits_[0] |= 0x00000002u;
  return sha1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_sha1() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.sha1)
  if (!_internal_has_sha1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sha1_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_sha1(std::string* sha1) {
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sha1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.sha1)
}
inline std::string* rom::unsafe_arena_release_sha1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.sha1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return sha1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_sha1(
    std::string* sha1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sha1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sha1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.sha1)
}

// optional string merge = 3;
inline bool rom::_internal_has_merge() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool rom::has_merge() const {
  return _internal_has_merge();
}
inline void rom::clear_merge() {
  merge_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& rom::merge() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.merge)
  return _internal_merge();
}
inline void rom::set_merge(const std::string& value) {
  _internal_set_merge(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.merge)
}
inline std::string* rom::mutable_merge() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.merge)
  return _internal_mutable_merge();
}
inline const std::string& rom::_internal_merge() const {
  return merge_.Get();
}
inline void rom::_internal_set_merge(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_merge(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.merge)
}
inline void rom::set_merge(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.merge)
}
inline void rom::set_merge(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.merge)
}
inline std::string* rom::_internal_mutable_merge() {
  _has_bits_[0] |= 0x00000004u;
  return merge_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_merge() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.merge)
  if (!_internal_has_merge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return merge_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_merge(std::string* merge) {
  if (merge != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  merge_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merge,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.merge)
}
inline std::string* rom::unsafe_arena_release_merge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.merge)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return merge_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_merge(
    std::string* merge) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (merge != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  merge_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      merge, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.merge)
}

// optional string region = 4;
inline bool rom::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool rom::has_region() const {
  return _internal_has_region();
}
inline void rom::clear_region() {
  region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& rom::region() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.region)
  return _internal_region();
}
inline void rom::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.region)
}
inline std::string* rom::mutable_region() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.region)
  return _internal_mutable_region();
}
inline const std::string& rom::_internal_region() const {
  return region_.Get();
}
inline void rom::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.region)
}
inline void rom::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.region)
}
inline void rom::set_region(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.region)
}
inline std::string* rom::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000008u;
  return region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_region() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return region_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.region)
}
inline std::string* rom::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.region)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return region_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_region(
    std::string* region) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      region, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.region)
}

// optional .infoprotobuf.status status = 5 [default = good];
inline bool rom::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool rom::has_status() const {
  return _internal_has_status();
}
inline void rom::clear_status() {
  status_ = 3;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::infoprotobuf::status rom::_internal_status() const {
  return static_cast< ::infoprotobuf::status >(status_);
}
inline ::infoprotobuf::status rom::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.status)
  return _internal_status();
}
inline void rom::_internal_set_status(::infoprotobuf::status value) {
  assert(::infoprotobuf::status_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  status_ = value;
}
inline void rom::set_status(::infoprotobuf::status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.status)
}

// optional bool optional = 6 [default = false];
inline bool rom::_internal_has_optional() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool rom::has_optional() const {
  return _internal_has_optional();
}
inline void rom::clear_optional() {
  optional_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool rom::_internal_optional() const {
  return optional_;
}
inline bool rom::optional() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.optional)
  return _internal_optional();
}
inline void rom::_internal_set_optional(bool value) {
  _has_bits_[0] |= 0x00000040u;
  optional_ = value;
}
inline void rom::set_optional(bool value) {
  _internal_set_optional(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.optional)
}

// optional string bios = 7;
inline bool rom::_internal_has_bios() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool rom::has_bios() const {
  return _internal_has_bios();
}
inline void rom::clear_bios() {
  bios_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& rom::bios() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.bios)
  return _internal_bios();
}
inline void rom::set_bios(const std::string& value) {
  _internal_set_bios(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.bios)
}
inline std::string* rom::mutable_bios() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.bios)
  return _internal_mutable_bios();
}
inline const std::string& rom::_internal_bios() const {
  return bios_.Get();
}
inline void rom::_internal_set_bios(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  bios_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_bios(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  bios_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.bios)
}
inline void rom::set_bios(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  bios_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.bios)
}
inline void rom::set_bios(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  bios_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.bios)
}
inline std::string* rom::_internal_mutable_bios() {
  _has_bits_[0] |= 0x00000010u;
  return bios_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_bios() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.bios)
  if (!_internal_has_bios()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return bios_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_bios(std::string* bios) {
  if (bios != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  bios_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bios,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.bios)
}
inline std::string* rom::unsafe_arena_release_bios() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.bios)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return bios_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_bios(
    std::string* bios) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (bios != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  bios_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      bios, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.bios)
}

// required uint32 size = 8;
inline bool rom::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool rom::has_size() const {
  return _internal_has_size();
}
inline void rom::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 rom::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 rom::size() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.size)
  return _internal_size();
}
inline void rom::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  size_ = value;
}
inline void rom::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.size)
}

// optional uint32 crc = 9;
inline bool rom::_internal_has_crc() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool rom::has_crc() const {
  return _internal_has_crc();
}
inline void rom::clear_crc() {
  crc_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 rom::_internal_crc() const {
  return crc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 rom::crc() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.crc)
  return _internal_crc();
}
inline void rom::_internal_set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  crc_ = value;
}
inline void rom::set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_crc(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.crc)
}

// optional string offset = 10;
inline bool rom::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool rom::has_offset() const {
  return _internal_has_offset();
}
inline void rom::clear_offset() {
  offset_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& rom::offset() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.rom.offset)
  return _internal_offset();
}
inline void rom::set_offset(const std::string& value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.rom.offset)
}
inline std::string* rom::mutable_offset() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.rom.offset)
  return _internal_mutable_offset();
}
inline const std::string& rom::_internal_offset() const {
  return offset_.Get();
}
inline void rom::_internal_set_offset(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  offset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rom::set_offset(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  offset_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.rom.offset)
}
inline void rom::set_offset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  offset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.rom.offset)
}
inline void rom::set_offset(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  offset_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.rom.offset)
}
inline std::string* rom::_internal_mutable_offset() {
  _has_bits_[0] |= 0x00000020u;
  return offset_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rom::release_offset() {
  // @@protoc_insertion_point(field_release:infoprotobuf.rom.offset)
  if (!_internal_has_offset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return offset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rom::set_allocated_offset(std::string* offset) {
  if (offset != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  offset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), offset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.rom.offset)
}
inline std::string* rom::unsafe_arena_release_offset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.rom.offset)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000020u;
  return offset_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rom::unsafe_arena_set_allocated_offset(
    std::string* offset) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (offset != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  offset_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      offset, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.rom.offset)
}

// -------------------------------------------------------------------

// disk

// required string name = 1;
inline bool disk::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool disk::has_name() const {
  return _internal_has_name();
}
inline void disk::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& disk::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.name)
  return _internal_name();
}
inline void disk::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.name)
}
inline std::string* disk::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.disk.name)
  return _internal_mutable_name();
}
inline const std::string& disk::_internal_name() const {
  return name_.Get();
}
inline void disk::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void disk::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.disk.name)
}
inline void disk::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.disk.name)
}
inline void disk::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.disk.name)
}
inline std::string* disk::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* disk::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.disk.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void disk::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.disk.name)
}
inline std::string* disk::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.disk.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void disk::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.disk.name)
}

// optional string sha1 = 2;
inline bool disk::_internal_has_sha1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool disk::has_sha1() const {
  return _internal_has_sha1();
}
inline void disk::clear_sha1() {
  sha1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& disk::sha1() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.sha1)
  return _internal_sha1();
}
inline void disk::set_sha1(const std::string& value) {
  _internal_set_sha1(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.sha1)
}
inline std::string* disk::mutable_sha1() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.disk.sha1)
  return _internal_mutable_sha1();
}
inline const std::string& disk::_internal_sha1() const {
  return sha1_.Get();
}
inline void disk::_internal_set_sha1(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void disk::set_sha1(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.disk.sha1)
}
inline void disk::set_sha1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.disk.sha1)
}
inline void disk::set_sha1(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.disk.sha1)
}
inline std::string* disk::_internal_mutable_sha1() {
  _has_bits_[0] |= 0x00000002u;
  return sha1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* disk::release_sha1() {
  // @@protoc_insertion_point(field_release:infoprotobuf.disk.sha1)
  if (!_internal_has_sha1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sha1_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void disk::set_allocated_sha1(std::string* sha1) {
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sha1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.disk.sha1)
}
inline std::string* disk::unsafe_arena_release_sha1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.disk.sha1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return sha1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void disk::unsafe_arena_set_allocated_sha1(
    std::string* sha1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sha1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sha1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.disk.sha1)
}

// optional string merge = 3;
inline bool disk::_internal_has_merge() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool disk::has_merge() const {
  return _internal_has_merge();
}
inline void disk::clear_merge() {
  merge_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& disk::merge() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.merge)
  return _internal_merge();
}
inline void disk::set_merge(const std::string& value) {
  _internal_set_merge(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.merge)
}
inline std::string* disk::mutable_merge() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.disk.merge)
  return _internal_mutable_merge();
}
inline const std::string& disk::_internal_merge() const {
  return merge_.Get();
}
inline void disk::_internal_set_merge(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void disk::set_merge(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.disk.merge)
}
inline void disk::set_merge(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.disk.merge)
}
inline void disk::set_merge(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  merge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.disk.merge)
}
inline std::string* disk::_internal_mutable_merge() {
  _has_bits_[0] |= 0x00000004u;
  return merge_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* disk::release_merge() {
  // @@protoc_insertion_point(field_release:infoprotobuf.disk.merge)
  if (!_internal_has_merge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return merge_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void disk::set_allocated_merge(std::string* merge) {
  if (merge != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  merge_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), merge,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.disk.merge)
}
inline std::string* disk::unsafe_arena_release_merge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.disk.merge)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return merge_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void disk::unsafe_arena_set_allocated_merge(
    std::string* merge) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (merge != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  merge_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      merge, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.disk.merge)
}

// optional string region = 4;
inline bool disk::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool disk::has_region() const {
  return _internal_has_region();
}
inline void disk::clear_region() {
  region_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& disk::region() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.region)
  return _internal_region();
}
inline void disk::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.region)
}
inline std::string* disk::mutable_region() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.disk.region)
  return _internal_mutable_region();
}
inline const std::string& disk::_internal_region() const {
  return region_.Get();
}
inline void disk::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void disk::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.disk.region)
}
inline void disk::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.disk.region)
}
inline void disk::set_region(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.disk.region)
}
inline std::string* disk::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000008u;
  return region_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* disk::release_region() {
  // @@protoc_insertion_point(field_release:infoprotobuf.disk.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return region_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void disk::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.disk.region)
}
inline std::string* disk::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.disk.region)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return region_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void disk::unsafe_arena_set_allocated_region(
    std::string* region) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      region, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.disk.region)
}

// optional .infoprotobuf.status status = 5 [default = good];
inline bool disk::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool disk::has_status() const {
  return _internal_has_status();
}
inline void disk::clear_status() {
  status_ = 3;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::infoprotobuf::status disk::_internal_status() const {
  return static_cast< ::infoprotobuf::status >(status_);
}
inline ::infoprotobuf::status disk::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.status)
  return _internal_status();
}
inline void disk::_internal_set_status(::infoprotobuf::status value) {
  assert(::infoprotobuf::status_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  status_ = value;
}
inline void disk::set_status(::infoprotobuf::status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.status)
}

// optional bool optional = 6 [default = false];
inline bool disk::_internal_has_optional() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool disk::has_optional() const {
  return _internal_has_optional();
}
inline void disk::clear_optional() {
  optional_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool disk::_internal_optional() const {
  return optional_;
}
inline bool disk::optional() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.optional)
  return _internal_optional();
}
inline void disk::_internal_set_optional(bool value) {
  _has_bits_[0] |= 0x00000040u;
  optional_ = value;
}
inline void disk::set_optional(bool value) {
  _internal_set_optional(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.optional)
}

// required uint32 size = 7;
inline bool disk::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool disk::has_size() const {
  return _internal_has_size();
}
inline void disk::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 disk::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 disk::size() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.size)
  return _internal_size();
}
inline void disk::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  size_ = value;
}
inline void disk::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.size)
}

// optional string index = 8;
inline bool disk::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool disk::has_index() const {
  return _internal_has_index();
}
inline void disk::clear_index() {
  index_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& disk::index() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.index)
  return _internal_index();
}
inline void disk::set_index(const std::string& value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.index)
}
inline std::string* disk::mutable_index() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.disk.index)
  return _internal_mutable_index();
}
inline const std::string& disk::_internal_index() const {
  return index_.Get();
}
inline void disk::_internal_set_index(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void disk::set_index(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  index_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.disk.index)
}
inline void disk::set_index(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.disk.index)
}
inline void disk::set_index(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.disk.index)
}
inline std::string* disk::_internal_mutable_index() {
  _has_bits_[0] |= 0x00000010u;
  return index_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* disk::release_index() {
  // @@protoc_insertion_point(field_release:infoprotobuf.disk.index)
  if (!_internal_has_index()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return index_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void disk::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  index_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.disk.index)
}
inline std::string* disk::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.disk.index)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return index_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void disk::unsafe_arena_set_allocated_index(
    std::string* index) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (index != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  index_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      index, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.disk.index)
}

// optional bool writable = 9 [default = false];
inline bool disk::_internal_has_writable() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool disk::has_writable() const {
  return _internal_has_writable();
}
inline void disk::clear_writable() {
  writable_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool disk::_internal_writable() const {
  return writable_;
}
inline bool disk::writable() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.disk.writable)
  return _internal_writable();
}
inline void disk::_internal_set_writable(bool value) {
  _has_bits_[0] |= 0x00000080u;
  writable_ = value;
}
inline void disk::set_writable(bool value) {
  _internal_set_writable(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.disk.writable)
}

// -------------------------------------------------------------------

// hashes

// optional string sha1 = 1;
inline bool hashes::_internal_has_sha1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool hashes::has_sha1() const {
  return _internal_has_sha1();
}
inline void hashes::clear_sha1() {
  sha1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& hashes::sha1() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.hashes.sha1)
  return _internal_sha1();
}
inline void hashes::set_sha1(const std::string& value) {
  _internal_set_sha1(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.hashes.sha1)
}
inline std::string* hashes::mutable_sha1() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.hashes.sha1)
  return _internal_mutable_sha1();
}
inline const std::string& hashes::_internal_sha1() const {
  return sha1_.Get();
}
inline void hashes::_internal_set_sha1(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void hashes::set_sha1(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sha1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.hashes.sha1)
}
inline void hashes::set_sha1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.hashes.sha1)
}
inline void hashes::set_sha1(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sha1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.hashes.sha1)
}
inline std::string* hashes::_internal_mutable_sha1() {
  _has_bits_[0] |= 0x00000001u;
  return sha1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* hashes::release_sha1() {
  // @@protoc_insertion_point(field_release:infoprotobuf.hashes.sha1)
  if (!_internal_has_sha1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sha1_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void hashes::set_allocated_sha1(std::string* sha1) {
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sha1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.hashes.sha1)
}
inline std::string* hashes::unsafe_arena_release_sha1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.hashes.sha1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return sha1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void hashes::unsafe_arena_set_allocated_sha1(
    std::string* sha1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sha1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sha1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.hashes.sha1)
}

// optional uint32 crc = 2;
inline bool hashes::_internal_has_crc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool hashes::has_crc() const {
  return _internal_has_crc();
}
inline void hashes::clear_crc() {
  crc_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 hashes::_internal_crc() const {
  return crc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 hashes::crc() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.hashes.crc)
  return _internal_crc();
}
inline void hashes::_internal_set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  crc_ = value;
}
inline void hashes::set_crc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_crc(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.hashes.crc)
}

// optional .infoprotobuf.status status = 3 [default = good];
inline bool hashes::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool hashes::has_status() const {
  return _internal_has_status();
}
inline void hashes::clear_status() {
  status_ = 3;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::infoprotobuf::status hashes::_internal_status() const {
  return static_cast< ::infoprotobuf::status >(status_);
}
inline ::infoprotobuf::status hashes::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.hashes.status)
  return _internal_status();
}
inline void hashes::_internal_set_status(::infoprotobuf::status value) {
  assert(::infoprotobuf::status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void hashes::set_status(::infoprotobuf::status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.hashes.status)
}

// -------------------------------------------------------------------

// device_ref

// required string name = 1;
inline bool device_ref::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool device_ref::has_name() const {
  return _internal_has_name();
}
inline void device_ref::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& device_ref::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device_ref.name)
  return _internal_name();
}
inline void device_ref::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device_ref.name)
}
inline std::string* device_ref::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device_ref.name)
  return _internal_mutable_name();
}
inline const std::string& device_ref::_internal_name() const {
  return name_.Get();
}
inline void device_ref::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device_ref::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device_ref.name)
}
inline void device_ref::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device_ref.name)
}
inline void device_ref::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device_ref.name)
}
inline std::string* device_ref::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device_ref::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device_ref.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device_ref::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device_ref.name)
}
inline std::string* device_ref::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device_ref.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device_ref::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device_ref.name)
}

// -------------------------------------------------------------------

// chip

// required string name = 1;
inline bool chip::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool chip::has_name() const {
  return _internal_has_name();
}
inline void chip::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& chip::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.chip.name)
  return _internal_name();
}
inline void chip::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.chip.name)
}
inline std::string* chip::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.chip.name)
  return _internal_mutable_name();
}
inline const std::string& chip::_internal_name() const {
  return name_.Get();
}
inline void chip::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void chip::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.chip.name)
}
inline void chip::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.chip.name)
}
inline void chip::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.chip.name)
}
inline std::string* chip::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* chip::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.chip.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void chip::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.chip.name)
}
inline std::string* chip::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.chip.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void chip::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.chip.name)
}

// optional string tag = 2;
inline bool chip::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool chip::has_tag() const {
  return _internal_has_tag();
}
inline void chip::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& chip::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.chip.tag)
  return _internal_tag();
}
inline void chip::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.chip.tag)
}
inline std::string* chip::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.chip.tag)
  return _internal_mutable_tag();
}
inline const std::string& chip::_internal_tag() const {
  return tag_.Get();
}
inline void chip::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void chip::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.chip.tag)
}
inline void chip::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.chip.tag)
}
inline void chip::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.chip.tag)
}
inline std::string* chip::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* chip::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.chip.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void chip::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.chip.tag)
}
inline std::string* chip::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.chip.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void chip::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.chip.tag)
}

// required .infoprotobuf.chip_type type = 3;
inline bool chip::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool chip::has_type() const {
  return _internal_has_type();
}
inline void chip::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::infoprotobuf::chip_type chip::_internal_type() const {
  return static_cast< ::infoprotobuf::chip_type >(type_);
}
inline ::infoprotobuf::chip_type chip::type() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.chip.type)
  return _internal_type();
}
inline void chip::_internal_set_type(::infoprotobuf::chip_type value) {
  assert(::infoprotobuf::chip_type_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void chip::set_type(::infoprotobuf::chip_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.chip.type)
}

// optional uint32 clock = 4;
inline bool chip::_internal_has_clock() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool chip::has_clock() const {
  return _internal_has_clock();
}
inline void chip::clear_clock() {
  clock_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 chip::_internal_clock() const {
  return clock_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 chip::clock() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.chip.clock)
  return _internal_clock();
}
inline void chip::_internal_set_clock(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  clock_ = value;
}
inline void chip::set_clock(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_clock(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.chip.clock)
}

// -------------------------------------------------------------------

// sample

// required string name = 1;
inline bool sample::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sample::has_name() const {
  return _internal_has_name();
}
inline void sample::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& sample::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.sample.name)
  return _internal_name();
}
inline void sample::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.sample.name)
}
inline std::string* sample::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.sample.name)
  return _internal_mutable_name();
}
inline const std::string& sample::_internal_name() const {
  return name_.Get();
}
inline void sample::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void sample::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.sample.name)
}
inline void sample::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.sample.name)
}
inline void sample::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.sample.name)
}
inline std::string* sample::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* sample::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.sample.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void sample::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.sample.name)
}
inline std::string* sample::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.sample.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void sample::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.sample.name)
}

// -------------------------------------------------------------------

// display

// optional string tag = 1;
inline bool display::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool display::has_tag() const {
  return _internal_has_tag();
}
inline void display::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& display::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.tag)
  return _internal_tag();
}
inline void display::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.tag)
}
inline std::string* display::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.display.tag)
  return _internal_mutable_tag();
}
inline const std::string& display::_internal_tag() const {
  return tag_.Get();
}
inline void display::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void display::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.display.tag)
}
inline void display::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.display.tag)
}
inline void display::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.display.tag)
}
inline std::string* display::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* display::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.display.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void display::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.display.tag)
}
inline std::string* display::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.display.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void display::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.display.tag)
}

// required .infoprotobuf.display_type type = 2;
inline bool display::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool display::has_type() const {
  return _internal_has_type();
}
inline void display::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::infoprotobuf::display_type display::_internal_type() const {
  return static_cast< ::infoprotobuf::display_type >(type_);
}
inline ::infoprotobuf::display_type display::type() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.type)
  return _internal_type();
}
inline void display::_internal_set_type(::infoprotobuf::display_type value) {
  assert(::infoprotobuf::display_type_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  type_ = value;
}
inline void display::set_type(::infoprotobuf::display_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.type)
}

// optional .infoprotobuf.display_rotation rotate = 3;
inline bool display::_internal_has_rotate() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool display::has_rotate() const {
  return _internal_has_rotate();
}
inline void display::clear_rotate() {
  rotate_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::infoprotobuf::display_rotation display::_internal_rotate() const {
  return static_cast< ::infoprotobuf::display_rotation >(rotate_);
}
inline ::infoprotobuf::display_rotation display::rotate() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.rotate)
  return _internal_rotate();
}
inline void display::_internal_set_rotate(::infoprotobuf::display_rotation value) {
  assert(::infoprotobuf::display_rotation_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  rotate_ = value;
}
inline void display::set_rotate(::infoprotobuf::display_rotation value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.rotate)
}

// optional bool flipx = 4 [default = false];
inline bool display::_internal_has_flipx() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool display::has_flipx() const {
  return _internal_has_flipx();
}
inline void display::clear_flipx() {
  flipx_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool display::_internal_flipx() const {
  return flipx_;
}
inline bool display::flipx() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.flipx)
  return _internal_flipx();
}
inline void display::_internal_set_flipx(bool value) {
  _has_bits_[0] |= 0x00000002u;
  flipx_ = value;
}
inline void display::set_flipx(bool value) {
  _internal_set_flipx(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.flipx)
}

// optional uint32 width = 5;
inline bool display::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool display::has_width() const {
  return _internal_has_width();
}
inline void display::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 display::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 display::width() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.width)
  return _internal_width();
}
inline void display::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void display::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.width)
}

// optional uint32 height = 6;
inline bool display::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool display::has_height() const {
  return _internal_has_height();
}
inline void display::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 display::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 display::height() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.height)
  return _internal_height();
}
inline void display::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  height_ = value;
}
inline void display::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.height)
}

// required double refresh = 7;
inline bool display::_internal_has_refresh() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool display::has_refresh() const {
  return _internal_has_refresh();
}
inline void display::clear_refresh() {
  refresh_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double display::_internal_refresh() const {
  return refresh_;
}
inline double display::refresh() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.refresh)
  return _internal_refresh();
}
inline void display::_internal_set_refresh(double value) {
  _has_bits_[0] |= 0x00000008u;
  refresh_ = value;
}
inline void display::set_refresh(double value) {
  _internal_set_refresh(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.refresh)
}

// optional int32 pixclock = 8;
inline bool display::_internal_has_pixclock() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool display::has_pixclock() const {
  return _internal_has_pixclock();
}
inline void display::clear_pixclock() {
  pixclock_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_pixclock() const {
  return pixclock_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::pixclock() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.pixclock)
  return _internal_pixclock();
}
inline void display::_internal_set_pixclock(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  pixclock_ = value;
}
inline void display::set_pixclock(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pixclock(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.pixclock)
}

// optional int32 htotal = 9;
inline bool display::_internal_has_htotal() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool display::has_htotal() const {
  return _internal_has_htotal();
}
inline void display::clear_htotal() {
  htotal_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_htotal() const {
  return htotal_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::htotal() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.htotal)
  return _internal_htotal();
}
inline void display::_internal_set_htotal(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  htotal_ = value;
}
inline void display::set_htotal(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_htotal(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.htotal)
}

// optional int32 hbend = 10;
inline bool display::_internal_has_hbend() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool display::has_hbend() const {
  return _internal_has_hbend();
}
inline void display::clear_hbend() {
  hbend_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_hbend() const {
  return hbend_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::hbend() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.hbend)
  return _internal_hbend();
}
inline void display::_internal_set_hbend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  hbend_ = value;
}
inline void display::set_hbend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hbend(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.hbend)
}

// optional int32 hbstart = 11;
inline bool display::_internal_has_hbstart() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool display::has_hbstart() const {
  return _internal_has_hbstart();
}
inline void display::clear_hbstart() {
  hbstart_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_hbstart() const {
  return hbstart_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::hbstart() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.hbstart)
  return _internal_hbstart();
}
inline void display::_internal_set_hbstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  hbstart_ = value;
}
inline void display::set_hbstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hbstart(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.hbstart)
}

// optional int32 vtotal = 12;
inline bool display::_internal_has_vtotal() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool display::has_vtotal() const {
  return _internal_has_vtotal();
}
inline void display::clear_vtotal() {
  vtotal_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_vtotal() const {
  return vtotal_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::vtotal() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.vtotal)
  return _internal_vtotal();
}
inline void display::_internal_set_vtotal(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  vtotal_ = value;
}
inline void display::set_vtotal(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vtotal(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.vtotal)
}

// optional int32 vbend = 13;
inline bool display::_internal_has_vbend() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool display::has_vbend() const {
  return _internal_has_vbend();
}
inline void display::clear_vbend() {
  vbend_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_vbend() const {
  return vbend_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::vbend() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.vbend)
  return _internal_vbend();
}
inline void display::_internal_set_vbend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  vbend_ = value;
}
inline void display::set_vbend(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vbend(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.vbend)
}

// optional int32 vbstart = 14;
inline bool display::_internal_has_vbstart() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool display::has_vbstart() const {
  return _internal_has_vbstart();
}
inline void display::clear_vbstart() {
  vbstart_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::_internal_vbstart() const {
  return vbstart_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 display::vbstart() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.display.vbstart)
  return _internal_vbstart();
}
inline void display::_internal_set_vbstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  vbstart_ = value;
}
inline void display::set_vbstart(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vbstart(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.display.vbstart)
}

// -------------------------------------------------------------------

// sound

// required int32 channels = 1;
inline bool sound::_internal_has_channels() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sound::has_channels() const {
  return _internal_has_channels();
}
inline void sound::clear_channels() {
  channels_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 sound::_internal_channels() const {
  return channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 sound::channels() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.sound.channels)
  return _internal_channels();
}
inline void sound::_internal_set_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  channels_ = value;
}
inline void sound::set_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.sound.channels)
}

// -------------------------------------------------------------------

// condition

// required string tag = 1;
inline bool condition::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool condition::has_tag() const {
  return _internal_has_tag();
}
inline void condition::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& condition::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.condition.tag)
  return _internal_tag();
}
inline void condition::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.condition.tag)
}
inline std::string* condition::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.condition.tag)
  return _internal_mutable_tag();
}
inline const std::string& condition::_internal_tag() const {
  return tag_.Get();
}
inline void condition::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void condition::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.condition.tag)
}
inline void condition::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.condition.tag)
}
inline void condition::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.condition.tag)
}
inline std::string* condition::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* condition::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.condition.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void condition::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.condition.tag)
}
inline std::string* condition::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.condition.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void condition::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.condition.tag)
}

// required uint32 mask = 2;
inline bool condition::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool condition::has_mask() const {
  return _internal_has_mask();
}
inline void condition::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 condition::_internal_mask() const {
  return mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 condition::mask() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.condition.mask)
  return _internal_mask();
}
inline void condition::_internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  mask_ = value;
}
inline void condition::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.condition.mask)
}

// required .infoprotobuf.condition.condition_relation relation = 3;
inline bool condition::_internal_has_relation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool condition::has_relation() const {
  return _internal_has_relation();
}
inline void condition::clear_relation() {
  relation_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::infoprotobuf::condition_condition_relation condition::_internal_relation() const {
  return static_cast< ::infoprotobuf::condition_condition_relation >(relation_);
}
inline ::infoprotobuf::condition_condition_relation condition::relation() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.condition.relation)
  return _internal_relation();
}
inline void condition::_internal_set_relation(::infoprotobuf::condition_condition_relation value) {
  assert(::infoprotobuf::condition_condition_relation_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  relation_ = value;
}
inline void condition::set_relation(::infoprotobuf::condition_condition_relation value) {
  _internal_set_relation(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.condition.relation)
}

// required uint32 value = 4;
inline bool condition::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool condition::has_value() const {
  return _internal_has_value();
}
inline void condition::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 condition::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 condition::value() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.condition.value)
  return _internal_value();
}
inline void condition::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void condition::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.condition.value)
}

// -------------------------------------------------------------------

// input_Control

// required string type = 1;
inline bool input_Control::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool input_Control::has_type() const {
  return _internal_has_type();
}
inline void input_Control::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& input_Control::type() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.type)
  return _internal_type();
}
inline void input_Control::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.type)
}
inline std::string* input_Control::mutable_type() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.input.Control.type)
  return _internal_mutable_type();
}
inline const std::string& input_Control::_internal_type() const {
  return type_.Get();
}
inline void input_Control::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void input_Control::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.input.Control.type)
}
inline void input_Control::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.input.Control.type)
}
inline void input_Control::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.input.Control.type)
}
inline std::string* input_Control::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* input_Control::release_type() {
  // @@protoc_insertion_point(field_release:infoprotobuf.input.Control.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void input_Control::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.input.Control.type)
}
inline std::string* input_Control::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.input.Control.type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void input_Control::unsafe_arena_set_allocated_type(
    std::string* type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.input.Control.type)
}

// optional int32 player = 2;
inline bool input_Control::_internal_has_player() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool input_Control::has_player() const {
  return _internal_has_player();
}
inline void input_Control::clear_player() {
  player_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_player() const {
  return player_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::player() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.player)
  return _internal_player();
}
inline void input_Control::_internal_set_player(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  player_ = value;
}
inline void input_Control::set_player(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.player)
}

// optional int32 buttons = 3;
inline bool input_Control::_internal_has_buttons() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool input_Control::has_buttons() const {
  return _internal_has_buttons();
}
inline void input_Control::clear_buttons() {
  buttons_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_buttons() const {
  return buttons_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::buttons() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.buttons)
  return _internal_buttons();
}
inline void input_Control::_internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  buttons_ = value;
}
inline void input_Control::set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_buttons(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.buttons)
}

// optional int32 reqbuttons = 4;
inline bool input_Control::_internal_has_reqbuttons() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool input_Control::has_reqbuttons() const {
  return _internal_has_reqbuttons();
}
inline void input_Control::clear_reqbuttons() {
  reqbuttons_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_reqbuttons() const {
  return reqbuttons_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::reqbuttons() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.reqbuttons)
  return _internal_reqbuttons();
}
inline void input_Control::_internal_set_reqbuttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  reqbuttons_ = value;
}
inline void input_Control::set_reqbuttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reqbuttons(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.reqbuttons)
}

// optional int32 minimum = 5;
inline bool input_Control::_internal_has_minimum() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool input_Control::has_minimum() const {
  return _internal_has_minimum();
}
inline void input_Control::clear_minimum() {
  minimum_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_minimum() const {
  return minimum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::minimum() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.minimum)
  return _internal_minimum();
}
inline void input_Control::_internal_set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  minimum_ = value;
}
inline void input_Control::set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.minimum)
}

// optional int32 maximum = 6;
inline bool input_Control::_internal_has_maximum() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool input_Control::has_maximum() const {
  return _internal_has_maximum();
}
inline void input_Control::clear_maximum() {
  maximum_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_maximum() const {
  return maximum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::maximum() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.maximum)
  return _internal_maximum();
}
inline void input_Control::_internal_set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  maximum_ = value;
}
inline void input_Control::set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.maximum)
}

// optional int32 sensitivity = 7;
inline bool input_Control::_internal_has_sensitivity() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool input_Control::has_sensitivity() const {
  return _internal_has_sensitivity();
}
inline void input_Control::clear_sensitivity() {
  sensitivity_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_sensitivity() const {
  return sensitivity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::sensitivity() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.sensitivity)
  return _internal_sensitivity();
}
inline void input_Control::_internal_set_sensitivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  sensitivity_ = value;
}
inline void input_Control::set_sensitivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sensitivity(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.sensitivity)
}

// optional int32 keydelta = 8;
inline bool input_Control::_internal_has_keydelta() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool input_Control::has_keydelta() const {
  return _internal_has_keydelta();
}
inline void input_Control::clear_keydelta() {
  keydelta_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::_internal_keydelta() const {
  return keydelta_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input_Control::keydelta() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.keydelta)
  return _internal_keydelta();
}
inline void input_Control::_internal_set_keydelta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  keydelta_ = value;
}
inline void input_Control::set_keydelta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_keydelta(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.keydelta)
}

// optional bool reverse = 9 [default = false];
inline bool input_Control::_internal_has_reverse() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool input_Control::has_reverse() const {
  return _internal_has_reverse();
}
inline void input_Control::clear_reverse() {
  reverse_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool input_Control::_internal_reverse() const {
  return reverse_;
}
inline bool input_Control::reverse() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.reverse)
  return _internal_reverse();
}
inline void input_Control::_internal_set_reverse(bool value) {
  _has_bits_[0] |= 0x00000800u;
  reverse_ = value;
}
inline void input_Control::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.reverse)
}

// optional string ways = 10;
inline bool input_Control::_internal_has_ways() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool input_Control::has_ways() const {
  return _internal_has_ways();
}
inline void input_Control::clear_ways() {
  ways_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& input_Control::ways() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.ways)
  return _internal_ways();
}
inline void input_Control::set_ways(const std::string& value) {
  _internal_set_ways(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.ways)
}
inline std::string* input_Control::mutable_ways() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.input.Control.ways)
  return _internal_mutable_ways();
}
inline const std::string& input_Control::_internal_ways() const {
  return ways_.Get();
}
inline void input_Control::_internal_set_ways(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ways_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void input_Control::set_ways(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ways_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.input.Control.ways)
}
inline void input_Control::set_ways(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ways_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.input.Control.ways)
}
inline void input_Control::set_ways(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ways_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.input.Control.ways)
}
inline std::string* input_Control::_internal_mutable_ways() {
  _has_bits_[0] |= 0x00000002u;
  return ways_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* input_Control::release_ways() {
  // @@protoc_insertion_point(field_release:infoprotobuf.input.Control.ways)
  if (!_internal_has_ways()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ways_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void input_Control::set_allocated_ways(std::string* ways) {
  if (ways != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ways_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ways,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.input.Control.ways)
}
inline std::string* input_Control::unsafe_arena_release_ways() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.input.Control.ways)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ways_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void input_Control::unsafe_arena_set_allocated_ways(
    std::string* ways) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ways != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ways_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ways, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.input.Control.ways)
}

// optional string ways2 = 11;
inline bool input_Control::_internal_has_ways2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool input_Control::has_ways2() const {
  return _internal_has_ways2();
}
inline void input_Control::clear_ways2() {
  ways2_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& input_Control::ways2() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.ways2)
  return _internal_ways2();
}
inline void input_Control::set_ways2(const std::string& value) {
  _internal_set_ways2(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.ways2)
}
inline std::string* input_Control::mutable_ways2() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.input.Control.ways2)
  return _internal_mutable_ways2();
}
inline const std::string& input_Control::_internal_ways2() const {
  return ways2_.Get();
}
inline void input_Control::_internal_set_ways2(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ways2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void input_Control::set_ways2(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ways2_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.input.Control.ways2)
}
inline void input_Control::set_ways2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ways2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.input.Control.ways2)
}
inline void input_Control::set_ways2(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ways2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.input.Control.ways2)
}
inline std::string* input_Control::_internal_mutable_ways2() {
  _has_bits_[0] |= 0x00000004u;
  return ways2_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* input_Control::release_ways2() {
  // @@protoc_insertion_point(field_release:infoprotobuf.input.Control.ways2)
  if (!_internal_has_ways2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ways2_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void input_Control::set_allocated_ways2(std::string* ways2) {
  if (ways2 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ways2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ways2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.input.Control.ways2)
}
inline std::string* input_Control::unsafe_arena_release_ways2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.input.Control.ways2)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return ways2_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void input_Control::unsafe_arena_set_allocated_ways2(
    std::string* ways2) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ways2 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ways2_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ways2, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.input.Control.ways2)
}

// optional string ways3 = 12;
inline bool input_Control::_internal_has_ways3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool input_Control::has_ways3() const {
  return _internal_has_ways3();
}
inline void input_Control::clear_ways3() {
  ways3_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& input_Control::ways3() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.Control.ways3)
  return _internal_ways3();
}
inline void input_Control::set_ways3(const std::string& value) {
  _internal_set_ways3(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.Control.ways3)
}
inline std::string* input_Control::mutable_ways3() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.input.Control.ways3)
  return _internal_mutable_ways3();
}
inline const std::string& input_Control::_internal_ways3() const {
  return ways3_.Get();
}
inline void input_Control::_internal_set_ways3(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ways3_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void input_Control::set_ways3(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  ways3_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.input.Control.ways3)
}
inline void input_Control::set_ways3(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  ways3_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.input.Control.ways3)
}
inline void input_Control::set_ways3(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  ways3_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.input.Control.ways3)
}
inline std::string* input_Control::_internal_mutable_ways3() {
  _has_bits_[0] |= 0x00000008u;
  return ways3_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* input_Control::release_ways3() {
  // @@protoc_insertion_point(field_release:infoprotobuf.input.Control.ways3)
  if (!_internal_has_ways3()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return ways3_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void input_Control::set_allocated_ways3(std::string* ways3) {
  if (ways3 != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ways3_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ways3,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.input.Control.ways3)
}
inline std::string* input_Control::unsafe_arena_release_ways3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.input.Control.ways3)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return ways3_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void input_Control::unsafe_arena_set_allocated_ways3(
    std::string* ways3) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ways3 != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ways3_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ways3, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.input.Control.ways3)
}

// -------------------------------------------------------------------

// input

// optional bool service = 1 [default = false];
inline bool input::_internal_has_service() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool input::has_service() const {
  return _internal_has_service();
}
inline void input::clear_service() {
  service_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool input::_internal_service() const {
  return service_;
}
inline bool input::service() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.service)
  return _internal_service();
}
inline void input::_internal_set_service(bool value) {
  _has_bits_[0] |= 0x00000001u;
  service_ = value;
}
inline void input::set_service(bool value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.service)
}

// optional bool tilt = 2 [default = false];
inline bool input::_internal_has_tilt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool input::has_tilt() const {
  return _internal_has_tilt();
}
inline void input::clear_tilt() {
  tilt_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool input::_internal_tilt() const {
  return tilt_;
}
inline bool input::tilt() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.tilt)
  return _internal_tilt();
}
inline void input::_internal_set_tilt(bool value) {
  _has_bits_[0] |= 0x00000002u;
  tilt_ = value;
}
inline void input::set_tilt(bool value) {
  _internal_set_tilt(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.tilt)
}

// required int32 players = 3;
inline bool input::_internal_has_players() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool input::has_players() const {
  return _internal_has_players();
}
inline void input::clear_players() {
  players_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input::_internal_players() const {
  return players_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input::players() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.players)
  return _internal_players();
}
inline void input::_internal_set_players(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  players_ = value;
}
inline void input::set_players(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_players(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.players)
}

// optional int32 coins = 4;
inline bool input::_internal_has_coins() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool input::has_coins() const {
  return _internal_has_coins();
}
inline void input::clear_coins() {
  coins_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input::_internal_coins() const {
  return coins_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 input::coins() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.coins)
  return _internal_coins();
}
inline void input::_internal_set_coins(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  coins_ = value;
}
inline void input::set_coins(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_coins(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.input.coins)
}

// repeated .infoprotobuf.input.Control control = 5;
inline int input::_internal_control_size() const {
  return control_.size();
}
inline int input::control_size() const {
  return _internal_control_size();
}
inline void input::clear_control() {
  control_.Clear();
}
inline ::infoprotobuf::input_Control* input::mutable_control(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.input.control)
  return control_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::input_Control >*
input::mutable_control() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.input.control)
  return &control_;
}
inline const ::infoprotobuf::input_Control& input::_internal_control(int index) const {
  return control_.Get(index);
}
inline const ::infoprotobuf::input_Control& input::control(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.input.control)
  return _internal_control(index);
}
inline ::infoprotobuf::input_Control* input::_internal_add_control() {
  return control_.Add();
}
inline ::infoprotobuf::input_Control* input::add_control() {
  // @@protoc_insertion_point(field_add:infoprotobuf.input.control)
  return _internal_add_control();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::input_Control >&
input::control() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.input.control)
  return control_;
}

// -------------------------------------------------------------------

// dipswitch_DipLocation

// required string name = 1;
inline bool dipswitch_DipLocation::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool dipswitch_DipLocation::has_name() const {
  return _internal_has_name();
}
inline void dipswitch_DipLocation::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dipswitch_DipLocation::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipLocation.name)
  return _internal_name();
}
inline void dipswitch_DipLocation::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipLocation.name)
}
inline std::string* dipswitch_DipLocation::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.DipLocation.name)
  return _internal_mutable_name();
}
inline const std::string& dipswitch_DipLocation::_internal_name() const {
  return name_.Get();
}
inline void dipswitch_DipLocation::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void dipswitch_DipLocation::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.dipswitch.DipLocation.name)
}
inline void dipswitch_DipLocation::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.dipswitch.DipLocation.name)
}
inline void dipswitch_DipLocation::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.dipswitch.DipLocation.name)
}
inline std::string* dipswitch_DipLocation::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* dipswitch_DipLocation::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.DipLocation.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void dipswitch_DipLocation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.DipLocation.name)
}
inline std::string* dipswitch_DipLocation::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.dipswitch.DipLocation.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void dipswitch_DipLocation::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.DipLocation.name)
}

// required uint32 number = 2;
inline bool dipswitch_DipLocation::_internal_has_number() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool dipswitch_DipLocation::has_number() const {
  return _internal_has_number();
}
inline void dipswitch_DipLocation::clear_number() {
  number_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch_DipLocation::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch_DipLocation::number() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipLocation.number)
  return _internal_number();
}
inline void dipswitch_DipLocation::_internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  number_ = value;
}
inline void dipswitch_DipLocation::set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipLocation.number)
}

// optional bool inverted = 3 [default = false];
inline bool dipswitch_DipLocation::_internal_has_inverted() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool dipswitch_DipLocation::has_inverted() const {
  return _internal_has_inverted();
}
inline void dipswitch_DipLocation::clear_inverted() {
  inverted_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool dipswitch_DipLocation::_internal_inverted() const {
  return inverted_;
}
inline bool dipswitch_DipLocation::inverted() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipLocation.inverted)
  return _internal_inverted();
}
inline void dipswitch_DipLocation::_internal_set_inverted(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inverted_ = value;
}
inline void dipswitch_DipLocation::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipLocation.inverted)
}

// -------------------------------------------------------------------

// dipswitch_DipValue

// optional .infoprotobuf.condition condition = 1;
inline bool dipswitch_DipValue::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool dipswitch_DipValue::has_condition() const {
  return _internal_has_condition();
}
inline void dipswitch_DipValue::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::infoprotobuf::condition& dipswitch_DipValue::_internal_condition() const {
  const ::infoprotobuf::condition* p = condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::condition*>(
      &::infoprotobuf::_condition_default_instance_);
}
inline const ::infoprotobuf::condition& dipswitch_DipValue::condition() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipValue.condition)
  return _internal_condition();
}
inline void dipswitch_DipValue::unsafe_arena_set_allocated_condition(
    ::infoprotobuf::condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.DipValue.condition)
}
inline ::infoprotobuf::condition* dipswitch_DipValue::release_condition() {
  auto temp = unsafe_arena_release_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::condition* dipswitch_DipValue::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.DipValue.condition)
  _has_bits_[0] &= ~0x00000002u;
  ::infoprotobuf::condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::infoprotobuf::condition* dipswitch_DipValue::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000002u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::infoprotobuf::condition* dipswitch_DipValue::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.DipValue.condition)
  return _internal_mutable_condition();
}
inline void dipswitch_DipValue::set_allocated_condition(::infoprotobuf::condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.DipValue.condition)
}

// required string name = 2;
inline bool dipswitch_DipValue::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool dipswitch_DipValue::has_name() const {
  return _internal_has_name();
}
inline void dipswitch_DipValue::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dipswitch_DipValue::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipValue.name)
  return _internal_name();
}
inline void dipswitch_DipValue::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipValue.name)
}
inline std::string* dipswitch_DipValue::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.DipValue.name)
  return _internal_mutable_name();
}
inline const std::string& dipswitch_DipValue::_internal_name() const {
  return name_.Get();
}
inline void dipswitch_DipValue::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void dipswitch_DipValue::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.dipswitch.DipValue.name)
}
inline void dipswitch_DipValue::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.dipswitch.DipValue.name)
}
inline void dipswitch_DipValue::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.dipswitch.DipValue.name)
}
inline std::string* dipswitch_DipValue::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* dipswitch_DipValue::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.DipValue.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void dipswitch_DipValue::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.DipValue.name)
}
inline std::string* dipswitch_DipValue::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.dipswitch.DipValue.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void dipswitch_DipValue::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.DipValue.name)
}

// required uint32 value = 3;
inline bool dipswitch_DipValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool dipswitch_DipValue::has_value() const {
  return _internal_has_value();
}
inline void dipswitch_DipValue::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch_DipValue::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch_DipValue::value() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipValue.value)
  return _internal_value();
}
inline void dipswitch_DipValue::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void dipswitch_DipValue::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipValue.value)
}

// optional bool default = 4 [default = false];
inline bool dipswitch_DipValue::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool dipswitch_DipValue::has_default_() const {
  return _internal_has_default_();
}
inline void dipswitch_DipValue::clear_default_() {
  default__ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool dipswitch_DipValue::_internal_default_() const {
  return default__;
}
inline bool dipswitch_DipValue::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.DipValue.default)
  return _internal_default_();
}
inline void dipswitch_DipValue::_internal_set_default_(bool value) {
  _has_bits_[0] |= 0x00000008u;
  default__ = value;
}
inline void dipswitch_DipValue::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.DipValue.default)
}

// -------------------------------------------------------------------

// dipswitch

// required string name = 1;
inline bool dipswitch::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool dipswitch::has_name() const {
  return _internal_has_name();
}
inline void dipswitch::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dipswitch::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.name)
  return _internal_name();
}
inline void dipswitch::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.name)
}
inline std::string* dipswitch::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.name)
  return _internal_mutable_name();
}
inline const std::string& dipswitch::_internal_name() const {
  return name_.Get();
}
inline void dipswitch::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void dipswitch::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.dipswitch.name)
}
inline void dipswitch::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.dipswitch.name)
}
inline void dipswitch::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.dipswitch.name)
}
inline std::string* dipswitch::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* dipswitch::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void dipswitch::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.name)
}
inline std::string* dipswitch::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.dipswitch.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void dipswitch::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.name)
}

// required string tag = 2;
inline bool dipswitch::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool dipswitch::has_tag() const {
  return _internal_has_tag();
}
inline void dipswitch::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& dipswitch::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.tag)
  return _internal_tag();
}
inline void dipswitch::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.tag)
}
inline std::string* dipswitch::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.tag)
  return _internal_mutable_tag();
}
inline const std::string& dipswitch::_internal_tag() const {
  return tag_.Get();
}
inline void dipswitch::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void dipswitch::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.dipswitch.tag)
}
inline void dipswitch::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.dipswitch.tag)
}
inline void dipswitch::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.dipswitch.tag)
}
inline std::string* dipswitch::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* dipswitch::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void dipswitch::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.tag)
}
inline std::string* dipswitch::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.dipswitch.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void dipswitch::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.tag)
}

// required uint32 mask = 3;
inline bool dipswitch::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool dipswitch::has_mask() const {
  return _internal_has_mask();
}
inline void dipswitch::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch::_internal_mask() const {
  return mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dipswitch::mask() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.mask)
  return _internal_mask();
}
inline void dipswitch::_internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  mask_ = value;
}
inline void dipswitch::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.dipswitch.mask)
}

// repeated .infoprotobuf.dipswitch.DipLocation diplocation = 4;
inline int dipswitch::_internal_diplocation_size() const {
  return diplocation_.size();
}
inline int dipswitch::diplocation_size() const {
  return _internal_diplocation_size();
}
inline void dipswitch::clear_diplocation() {
  diplocation_.Clear();
}
inline ::infoprotobuf::dipswitch_DipLocation* dipswitch::mutable_diplocation(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.diplocation)
  return diplocation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipLocation >*
dipswitch::mutable_diplocation() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.dipswitch.diplocation)
  return &diplocation_;
}
inline const ::infoprotobuf::dipswitch_DipLocation& dipswitch::_internal_diplocation(int index) const {
  return diplocation_.Get(index);
}
inline const ::infoprotobuf::dipswitch_DipLocation& dipswitch::diplocation(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.diplocation)
  return _internal_diplocation(index);
}
inline ::infoprotobuf::dipswitch_DipLocation* dipswitch::_internal_add_diplocation() {
  return diplocation_.Add();
}
inline ::infoprotobuf::dipswitch_DipLocation* dipswitch::add_diplocation() {
  // @@protoc_insertion_point(field_add:infoprotobuf.dipswitch.diplocation)
  return _internal_add_diplocation();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipLocation >&
dipswitch::diplocation() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.dipswitch.diplocation)
  return diplocation_;
}

// optional .infoprotobuf.condition condition = 5;
inline bool dipswitch::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool dipswitch::has_condition() const {
  return _internal_has_condition();
}
inline void dipswitch::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::infoprotobuf::condition& dipswitch::_internal_condition() const {
  const ::infoprotobuf::condition* p = condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::condition*>(
      &::infoprotobuf::_condition_default_instance_);
}
inline const ::infoprotobuf::condition& dipswitch::condition() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.condition)
  return _internal_condition();
}
inline void dipswitch::unsafe_arena_set_allocated_condition(
    ::infoprotobuf::condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.dipswitch.condition)
}
inline ::infoprotobuf::condition* dipswitch::release_condition() {
  auto temp = unsafe_arena_release_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::condition* dipswitch::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:infoprotobuf.dipswitch.condition)
  _has_bits_[0] &= ~0x00000004u;
  ::infoprotobuf::condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::infoprotobuf::condition* dipswitch::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000004u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::infoprotobuf::condition* dipswitch::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.condition)
  return _internal_mutable_condition();
}
inline void dipswitch::set_allocated_condition(::infoprotobuf::condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.dipswitch.condition)
}

// repeated .infoprotobuf.dipswitch.DipValue dipvalue = 6;
inline int dipswitch::_internal_dipvalue_size() const {
  return dipvalue_.size();
}
inline int dipswitch::dipvalue_size() const {
  return _internal_dipvalue_size();
}
inline void dipswitch::clear_dipvalue() {
  dipvalue_.Clear();
}
inline ::infoprotobuf::dipswitch_DipValue* dipswitch::mutable_dipvalue(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.dipswitch.dipvalue)
  return dipvalue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipValue >*
dipswitch::mutable_dipvalue() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.dipswitch.dipvalue)
  return &dipvalue_;
}
inline const ::infoprotobuf::dipswitch_DipValue& dipswitch::_internal_dipvalue(int index) const {
  return dipvalue_.Get(index);
}
inline const ::infoprotobuf::dipswitch_DipValue& dipswitch::dipvalue(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.dipswitch.dipvalue)
  return _internal_dipvalue(index);
}
inline ::infoprotobuf::dipswitch_DipValue* dipswitch::_internal_add_dipvalue() {
  return dipvalue_.Add();
}
inline ::infoprotobuf::dipswitch_DipValue* dipswitch::add_dipvalue() {
  // @@protoc_insertion_point(field_add:infoprotobuf.dipswitch.dipvalue)
  return _internal_add_dipvalue();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::dipswitch_DipValue >&
dipswitch::dipvalue() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.dipswitch.dipvalue)
  return dipvalue_;
}

// -------------------------------------------------------------------

// configuration_ConfLocation

// required string name = 1;
inline bool configuration_ConfLocation::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool configuration_ConfLocation::has_name() const {
  return _internal_has_name();
}
inline void configuration_ConfLocation::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& configuration_ConfLocation::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfLocation.name)
  return _internal_name();
}
inline void configuration_ConfLocation::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfLocation.name)
}
inline std::string* configuration_ConfLocation::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.ConfLocation.name)
  return _internal_mutable_name();
}
inline const std::string& configuration_ConfLocation::_internal_name() const {
  return name_.Get();
}
inline void configuration_ConfLocation::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration_ConfLocation::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.ConfLocation.name)
}
inline void configuration_ConfLocation::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.ConfLocation.name)
}
inline void configuration_ConfLocation::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.ConfLocation.name)
}
inline std::string* configuration_ConfLocation::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration_ConfLocation::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.ConfLocation.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration_ConfLocation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.ConfLocation.name)
}
inline std::string* configuration_ConfLocation::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.ConfLocation.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration_ConfLocation::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.ConfLocation.name)
}

// required uint32 number = 2;
inline bool configuration_ConfLocation::_internal_has_number() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool configuration_ConfLocation::has_number() const {
  return _internal_has_number();
}
inline void configuration_ConfLocation::clear_number() {
  number_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configuration_ConfLocation::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configuration_ConfLocation::number() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfLocation.number)
  return _internal_number();
}
inline void configuration_ConfLocation::_internal_set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  number_ = value;
}
inline void configuration_ConfLocation::set_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfLocation.number)
}

// optional bool inverted = 3 [default = false];
inline bool configuration_ConfLocation::_internal_has_inverted() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool configuration_ConfLocation::has_inverted() const {
  return _internal_has_inverted();
}
inline void configuration_ConfLocation::clear_inverted() {
  inverted_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool configuration_ConfLocation::_internal_inverted() const {
  return inverted_;
}
inline bool configuration_ConfLocation::inverted() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfLocation.inverted)
  return _internal_inverted();
}
inline void configuration_ConfLocation::_internal_set_inverted(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inverted_ = value;
}
inline void configuration_ConfLocation::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfLocation.inverted)
}

// -------------------------------------------------------------------

// configuration_ConfSetting

// optional .infoprotobuf.condition condition = 1;
inline bool configuration_ConfSetting::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool configuration_ConfSetting::has_condition() const {
  return _internal_has_condition();
}
inline void configuration_ConfSetting::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::infoprotobuf::condition& configuration_ConfSetting::_internal_condition() const {
  const ::infoprotobuf::condition* p = condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::condition*>(
      &::infoprotobuf::_condition_default_instance_);
}
inline const ::infoprotobuf::condition& configuration_ConfSetting::condition() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfSetting.condition)
  return _internal_condition();
}
inline void configuration_ConfSetting::unsafe_arena_set_allocated_condition(
    ::infoprotobuf::condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.ConfSetting.condition)
}
inline ::infoprotobuf::condition* configuration_ConfSetting::release_condition() {
  auto temp = unsafe_arena_release_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::condition* configuration_ConfSetting::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.ConfSetting.condition)
  _has_bits_[0] &= ~0x00000004u;
  ::infoprotobuf::condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::infoprotobuf::condition* configuration_ConfSetting::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000004u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::infoprotobuf::condition* configuration_ConfSetting::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.ConfSetting.condition)
  return _internal_mutable_condition();
}
inline void configuration_ConfSetting::set_allocated_condition(::infoprotobuf::condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.ConfSetting.condition)
}

// required string name = 2;
inline bool configuration_ConfSetting::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool configuration_ConfSetting::has_name() const {
  return _internal_has_name();
}
inline void configuration_ConfSetting::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& configuration_ConfSetting::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfSetting.name)
  return _internal_name();
}
inline void configuration_ConfSetting::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfSetting.name)
}
inline std::string* configuration_ConfSetting::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.ConfSetting.name)
  return _internal_mutable_name();
}
inline const std::string& configuration_ConfSetting::_internal_name() const {
  return name_.Get();
}
inline void configuration_ConfSetting::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration_ConfSetting::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.ConfSetting.name)
}
inline void configuration_ConfSetting::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.ConfSetting.name)
}
inline void configuration_ConfSetting::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.ConfSetting.name)
}
inline std::string* configuration_ConfSetting::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration_ConfSetting::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.ConfSetting.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration_ConfSetting::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.ConfSetting.name)
}
inline std::string* configuration_ConfSetting::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.ConfSetting.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration_ConfSetting::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.ConfSetting.name)
}

// required string value = 3;
inline bool configuration_ConfSetting::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool configuration_ConfSetting::has_value() const {
  return _internal_has_value();
}
inline void configuration_ConfSetting::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& configuration_ConfSetting::value() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfSetting.value)
  return _internal_value();
}
inline void configuration_ConfSetting::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfSetting.value)
}
inline std::string* configuration_ConfSetting::mutable_value() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.ConfSetting.value)
  return _internal_mutable_value();
}
inline const std::string& configuration_ConfSetting::_internal_value() const {
  return value_.Get();
}
inline void configuration_ConfSetting::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration_ConfSetting::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.ConfSetting.value)
}
inline void configuration_ConfSetting::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.ConfSetting.value)
}
inline void configuration_ConfSetting::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.ConfSetting.value)
}
inline std::string* configuration_ConfSetting::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration_ConfSetting::release_value() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.ConfSetting.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration_ConfSetting::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.ConfSetting.value)
}
inline std::string* configuration_ConfSetting::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.ConfSetting.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration_ConfSetting::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.ConfSetting.value)
}

// optional bool default = 4 [default = false];
inline bool configuration_ConfSetting::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool configuration_ConfSetting::has_default_() const {
  return _internal_has_default_();
}
inline void configuration_ConfSetting::clear_default_() {
  default__ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool configuration_ConfSetting::_internal_default_() const {
  return default__;
}
inline bool configuration_ConfSetting::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.ConfSetting.default)
  return _internal_default_();
}
inline void configuration_ConfSetting::_internal_set_default_(bool value) {
  _has_bits_[0] |= 0x00000008u;
  default__ = value;
}
inline void configuration_ConfSetting::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.ConfSetting.default)
}

// -------------------------------------------------------------------

// configuration

// optional .infoprotobuf.condition condition = 1;
inline bool configuration::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool configuration::has_condition() const {
  return _internal_has_condition();
}
inline void configuration::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::infoprotobuf::condition& configuration::_internal_condition() const {
  const ::infoprotobuf::condition* p = condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::condition*>(
      &::infoprotobuf::_condition_default_instance_);
}
inline const ::infoprotobuf::condition& configuration::condition() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.condition)
  return _internal_condition();
}
inline void configuration::unsafe_arena_set_allocated_condition(
    ::infoprotobuf::condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.condition)
}
inline ::infoprotobuf::condition* configuration::release_condition() {
  auto temp = unsafe_arena_release_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::condition* configuration::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.condition)
  _has_bits_[0] &= ~0x00000008u;
  ::infoprotobuf::condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::infoprotobuf::condition* configuration::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000008u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::infoprotobuf::condition* configuration::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.condition)
  return _internal_mutable_condition();
}
inline void configuration::set_allocated_condition(::infoprotobuf::condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.condition)
}

// required string name = 2;
inline bool configuration::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool configuration::has_name() const {
  return _internal_has_name();
}
inline void configuration::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& configuration::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.name)
  return _internal_name();
}
inline void configuration::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.name)
}
inline std::string* configuration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.name)
  return _internal_mutable_name();
}
inline const std::string& configuration::_internal_name() const {
  return name_.Get();
}
inline void configuration::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.name)
}
inline void configuration::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.name)
}
inline void configuration::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.name)
}
inline std::string* configuration::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.name)
}
inline std::string* configuration::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.name)
}

// required string tag = 3;
inline bool configuration::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool configuration::has_tag() const {
  return _internal_has_tag();
}
inline void configuration::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& configuration::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.tag)
  return _internal_tag();
}
inline void configuration::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.tag)
}
inline std::string* configuration::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.tag)
  return _internal_mutable_tag();
}
inline const std::string& configuration::_internal_tag() const {
  return tag_.Get();
}
inline void configuration::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.tag)
}
inline void configuration::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.tag)
}
inline void configuration::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.tag)
}
inline std::string* configuration::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.tag)
}
inline std::string* configuration::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.tag)
}

// required string mask = 4;
inline bool configuration::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool configuration::has_mask() const {
  return _internal_has_mask();
}
inline void configuration::clear_mask() {
  mask_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& configuration::mask() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.mask)
  return _internal_mask();
}
inline void configuration::set_mask(const std::string& value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.configuration.mask)
}
inline std::string* configuration::mutable_mask() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.mask)
  return _internal_mutable_mask();
}
inline const std::string& configuration::_internal_mask() const {
  return mask_.Get();
}
inline void configuration::_internal_set_mask(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void configuration::set_mask(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  mask_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.configuration.mask)
}
inline void configuration::set_mask(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.configuration.mask)
}
inline void configuration::set_mask(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  mask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.configuration.mask)
}
inline std::string* configuration::_internal_mutable_mask() {
  _has_bits_[0] |= 0x00000004u;
  return mask_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* configuration::release_mask() {
  // @@protoc_insertion_point(field_release:infoprotobuf.configuration.mask)
  if (!_internal_has_mask()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return mask_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void configuration::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mask,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.configuration.mask)
}
inline std::string* configuration::unsafe_arena_release_mask() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.configuration.mask)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return mask_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void configuration::unsafe_arena_set_allocated_mask(
    std::string* mask) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mask != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mask_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mask, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.configuration.mask)
}

// repeated .infoprotobuf.configuration.ConfLocation conflocation = 5;
inline int configuration::_internal_conflocation_size() const {
  return conflocation_.size();
}
inline int configuration::conflocation_size() const {
  return _internal_conflocation_size();
}
inline void configuration::clear_conflocation() {
  conflocation_.Clear();
}
inline ::infoprotobuf::configuration_ConfLocation* configuration::mutable_conflocation(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.conflocation)
  return conflocation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfLocation >*
configuration::mutable_conflocation() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.configuration.conflocation)
  return &conflocation_;
}
inline const ::infoprotobuf::configuration_ConfLocation& configuration::_internal_conflocation(int index) const {
  return conflocation_.Get(index);
}
inline const ::infoprotobuf::configuration_ConfLocation& configuration::conflocation(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.conflocation)
  return _internal_conflocation(index);
}
inline ::infoprotobuf::configuration_ConfLocation* configuration::_internal_add_conflocation() {
  return conflocation_.Add();
}
inline ::infoprotobuf::configuration_ConfLocation* configuration::add_conflocation() {
  // @@protoc_insertion_point(field_add:infoprotobuf.configuration.conflocation)
  return _internal_add_conflocation();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfLocation >&
configuration::conflocation() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.configuration.conflocation)
  return conflocation_;
}

// repeated .infoprotobuf.configuration.ConfSetting confsetting = 6;
inline int configuration::_internal_confsetting_size() const {
  return confsetting_.size();
}
inline int configuration::confsetting_size() const {
  return _internal_confsetting_size();
}
inline void configuration::clear_confsetting() {
  confsetting_.Clear();
}
inline ::infoprotobuf::configuration_ConfSetting* configuration::mutable_confsetting(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.configuration.confsetting)
  return confsetting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfSetting >*
configuration::mutable_confsetting() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.configuration.confsetting)
  return &confsetting_;
}
inline const ::infoprotobuf::configuration_ConfSetting& configuration::_internal_confsetting(int index) const {
  return confsetting_.Get(index);
}
inline const ::infoprotobuf::configuration_ConfSetting& configuration::confsetting(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.configuration.confsetting)
  return _internal_confsetting(index);
}
inline ::infoprotobuf::configuration_ConfSetting* configuration::_internal_add_confsetting() {
  return confsetting_.Add();
}
inline ::infoprotobuf::configuration_ConfSetting* configuration::add_confsetting() {
  // @@protoc_insertion_point(field_add:infoprotobuf.configuration.confsetting)
  return _internal_add_confsetting();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::configuration_ConfSetting >&
configuration::confsetting() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.configuration.confsetting)
  return confsetting_;
}

// -------------------------------------------------------------------

// port_Analog

// required uint32 mask = 1;
inline bool port_Analog::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool port_Analog::has_mask() const {
  return _internal_has_mask();
}
inline void port_Analog::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 port_Analog::_internal_mask() const {
  return mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 port_Analog::mask() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.port.Analog.mask)
  return _internal_mask();
}
inline void port_Analog::_internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  mask_ = value;
}
inline void port_Analog::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.port.Analog.mask)
}

// -------------------------------------------------------------------

// port

// required string tag = 1;
inline bool port::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool port::has_tag() const {
  return _internal_has_tag();
}
inline void port::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& port::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.port.tag)
  return _internal_tag();
}
inline void port::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.port.tag)
}
inline std::string* port::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.port.tag)
  return _internal_mutable_tag();
}
inline const std::string& port::_internal_tag() const {
  return tag_.Get();
}
inline void port::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void port::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.port.tag)
}
inline void port::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.port.tag)
}
inline void port::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.port.tag)
}
inline std::string* port::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* port::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.port.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void port::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.port.tag)
}
inline std::string* port::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.port.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void port::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.port.tag)
}

// repeated .infoprotobuf.port.Analog analog = 2;
inline int port::_internal_analog_size() const {
  return analog_.size();
}
inline int port::analog_size() const {
  return _internal_analog_size();
}
inline void port::clear_analog() {
  analog_.Clear();
}
inline ::infoprotobuf::port_Analog* port::mutable_analog(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.port.analog)
  return analog_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port_Analog >*
port::mutable_analog() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.port.analog)
  return &analog_;
}
inline const ::infoprotobuf::port_Analog& port::_internal_analog(int index) const {
  return analog_.Get(index);
}
inline const ::infoprotobuf::port_Analog& port::analog(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.port.analog)
  return _internal_analog(index);
}
inline ::infoprotobuf::port_Analog* port::_internal_add_analog() {
  return analog_.Add();
}
inline ::infoprotobuf::port_Analog* port::add_analog() {
  // @@protoc_insertion_point(field_add:infoprotobuf.port.analog)
  return _internal_add_analog();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::port_Analog >&
port::analog() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.port.analog)
  return analog_;
}

// -------------------------------------------------------------------

// adjuster

// optional .infoprotobuf.condition condition = 1;
inline bool adjuster::_internal_has_condition() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || condition_ != nullptr);
  return value;
}
inline bool adjuster::has_condition() const {
  return _internal_has_condition();
}
inline void adjuster::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::infoprotobuf::condition& adjuster::_internal_condition() const {
  const ::infoprotobuf::condition* p = condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::condition*>(
      &::infoprotobuf::_condition_default_instance_);
}
inline const ::infoprotobuf::condition& adjuster::condition() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.adjuster.condition)
  return _internal_condition();
}
inline void adjuster::unsafe_arena_set_allocated_condition(
    ::infoprotobuf::condition* condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.adjuster.condition)
}
inline ::infoprotobuf::condition* adjuster::release_condition() {
  auto temp = unsafe_arena_release_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::condition* adjuster::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:infoprotobuf.adjuster.condition)
  _has_bits_[0] &= ~0x00000002u;
  ::infoprotobuf::condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::infoprotobuf::condition* adjuster::_internal_mutable_condition() {
  _has_bits_[0] |= 0x00000002u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::condition>(GetArena());
    condition_ = p;
  }
  return condition_;
}
inline ::infoprotobuf::condition* adjuster::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.adjuster.condition)
  return _internal_mutable_condition();
}
inline void adjuster::set_allocated_condition(::infoprotobuf::condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.adjuster.condition)
}

// required string name = 2;
inline bool adjuster::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool adjuster::has_name() const {
  return _internal_has_name();
}
inline void adjuster::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& adjuster::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.adjuster.name)
  return _internal_name();
}
inline void adjuster::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.adjuster.name)
}
inline std::string* adjuster::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.adjuster.name)
  return _internal_mutable_name();
}
inline const std::string& adjuster::_internal_name() const {
  return name_.Get();
}
inline void adjuster::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void adjuster::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.adjuster.name)
}
inline void adjuster::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.adjuster.name)
}
inline void adjuster::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.adjuster.name)
}
inline std::string* adjuster::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* adjuster::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.adjuster.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void adjuster::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.adjuster.name)
}
inline std::string* adjuster::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.adjuster.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void adjuster::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.adjuster.name)
}

// required uint32 default = 3;
inline bool adjuster::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool adjuster::has_default_() const {
  return _internal_has_default_();
}
inline void adjuster::clear_default_() {
  default__ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 adjuster::_internal_default_() const {
  return default__;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 adjuster::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.adjuster.default)
  return _internal_default_();
}
inline void adjuster::_internal_set_default_(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  default__ = value;
}
inline void adjuster::set_default_(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.adjuster.default)
}

// -------------------------------------------------------------------

// driver

// required .infoprotobuf.driver.driver_status status = 1;
inline bool driver::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool driver::has_status() const {
  return _internal_has_status();
}
inline void driver::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::infoprotobuf::driver_driver_status driver::_internal_status() const {
  return static_cast< ::infoprotobuf::driver_driver_status >(status_);
}
inline ::infoprotobuf::driver_driver_status driver::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.status)
  return _internal_status();
}
inline void driver::_internal_set_status(::infoprotobuf::driver_driver_status value) {
  assert(::infoprotobuf::driver_driver_status_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void driver::set_status(::infoprotobuf::driver_driver_status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.status)
}

// required .infoprotobuf.driver.driver_status emulation = 2;
inline bool driver::_internal_has_emulation() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool driver::has_emulation() const {
  return _internal_has_emulation();
}
inline void driver::clear_emulation() {
  emulation_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::infoprotobuf::driver_driver_status driver::_internal_emulation() const {
  return static_cast< ::infoprotobuf::driver_driver_status >(emulation_);
}
inline ::infoprotobuf::driver_driver_status driver::emulation() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.emulation)
  return _internal_emulation();
}
inline void driver::_internal_set_emulation(::infoprotobuf::driver_driver_status value) {
  assert(::infoprotobuf::driver_driver_status_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  emulation_ = value;
}
inline void driver::set_emulation(::infoprotobuf::driver_driver_status value) {
  _internal_set_emulation(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.emulation)
}

// optional .infoprotobuf.driver.driver_status cocktail = 3;
inline bool driver::_internal_has_cocktail() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool driver::has_cocktail() const {
  return _internal_has_cocktail();
}
inline void driver::clear_cocktail() {
  cocktail_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::infoprotobuf::driver_driver_status driver::_internal_cocktail() const {
  return static_cast< ::infoprotobuf::driver_driver_status >(cocktail_);
}
inline ::infoprotobuf::driver_driver_status driver::cocktail() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.cocktail)
  return _internal_cocktail();
}
inline void driver::_internal_set_cocktail(::infoprotobuf::driver_driver_status value) {
  assert(::infoprotobuf::driver_driver_status_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  cocktail_ = value;
}
inline void driver::set_cocktail(::infoprotobuf::driver_driver_status value) {
  _internal_set_cocktail(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.cocktail)
}

// required .infoprotobuf.driver.Supported savestate = 4;
inline bool driver::_internal_has_savestate() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool driver::has_savestate() const {
  return _internal_has_savestate();
}
inline void driver::clear_savestate() {
  savestate_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::infoprotobuf::driver_Supported driver::_internal_savestate() const {
  return static_cast< ::infoprotobuf::driver_Supported >(savestate_);
}
inline ::infoprotobuf::driver_Supported driver::savestate() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.savestate)
  return _internal_savestate();
}
inline void driver::_internal_set_savestate(::infoprotobuf::driver_Supported value) {
  assert(::infoprotobuf::driver_Supported_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  savestate_ = value;
}
inline void driver::set_savestate(::infoprotobuf::driver_Supported value) {
  _internal_set_savestate(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.savestate)
}

// optional bool requireartwork = 5 [default = false];
inline bool driver::_internal_has_requireartwork() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool driver::has_requireartwork() const {
  return _internal_has_requireartwork();
}
inline void driver::clear_requireartwork() {
  requireartwork_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool driver::_internal_requireartwork() const {
  return requireartwork_;
}
inline bool driver::requireartwork() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.requireartwork)
  return _internal_requireartwork();
}
inline void driver::_internal_set_requireartwork(bool value) {
  _has_bits_[0] |= 0x00000001u;
  requireartwork_ = value;
}
inline void driver::set_requireartwork(bool value) {
  _internal_set_requireartwork(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.requireartwork)
}

// optional bool unofficial = 6 [default = false];
inline bool driver::_internal_has_unofficial() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool driver::has_unofficial() const {
  return _internal_has_unofficial();
}
inline void driver::clear_unofficial() {
  unofficial_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool driver::_internal_unofficial() const {
  return unofficial_;
}
inline bool driver::unofficial() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.unofficial)
  return _internal_unofficial();
}
inline void driver::_internal_set_unofficial(bool value) {
  _has_bits_[0] |= 0x00000002u;
  unofficial_ = value;
}
inline void driver::set_unofficial(bool value) {
  _internal_set_unofficial(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.unofficial)
}

// optional bool nosoundhardware = 7 [default = false];
inline bool driver::_internal_has_nosoundhardware() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool driver::has_nosoundhardware() const {
  return _internal_has_nosoundhardware();
}
inline void driver::clear_nosoundhardware() {
  nosoundhardware_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool driver::_internal_nosoundhardware() const {
  return nosoundhardware_;
}
inline bool driver::nosoundhardware() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.nosoundhardware)
  return _internal_nosoundhardware();
}
inline void driver::_internal_set_nosoundhardware(bool value) {
  _has_bits_[0] |= 0x00000004u;
  nosoundhardware_ = value;
}
inline void driver::set_nosoundhardware(bool value) {
  _internal_set_nosoundhardware(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.nosoundhardware)
}

// optional bool incomplete = 8 [default = false];
inline bool driver::_internal_has_incomplete() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool driver::has_incomplete() const {
  return _internal_has_incomplete();
}
inline void driver::clear_incomplete() {
  incomplete_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool driver::_internal_incomplete() const {
  return incomplete_;
}
inline bool driver::incomplete() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.driver.incomplete)
  return _internal_incomplete();
}
inline void driver::_internal_set_incomplete(bool value) {
  _has_bits_[0] |= 0x00000008u;
  incomplete_ = value;
}
inline void driver::set_incomplete(bool value) {
  _internal_set_incomplete(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.driver.incomplete)
}

// -------------------------------------------------------------------

// feature

// required string type = 1;
inline bool feature::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool feature::has_type() const {
  return _internal_has_type();
}
inline void feature::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& feature::type() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.feature.type)
  return _internal_type();
}
inline void feature::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.feature.type)
}
inline std::string* feature::mutable_type() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.feature.type)
  return _internal_mutable_type();
}
inline const std::string& feature::_internal_type() const {
  return type_.Get();
}
inline void feature::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void feature::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.feature.type)
}
inline void feature::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.feature.type)
}
inline void feature::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.feature.type)
}
inline std::string* feature::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* feature::release_type() {
  // @@protoc_insertion_point(field_release:infoprotobuf.feature.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void feature::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.feature.type)
}
inline std::string* feature::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.feature.type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void feature::unsafe_arena_set_allocated_type(
    std::string* type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.feature.type)
}

// optional .infoprotobuf.feature.feature_status status = 2;
inline bool feature::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool feature::has_status() const {
  return _internal_has_status();
}
inline void feature::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::infoprotobuf::feature_feature_status feature::_internal_status() const {
  return static_cast< ::infoprotobuf::feature_feature_status >(status_);
}
inline ::infoprotobuf::feature_feature_status feature::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.feature.status)
  return _internal_status();
}
inline void feature::_internal_set_status(::infoprotobuf::feature_feature_status value) {
  assert(::infoprotobuf::feature_feature_status_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void feature::set_status(::infoprotobuf::feature_feature_status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.feature.status)
}

// optional .infoprotobuf.feature.feature_status overall = 3;
inline bool feature::_internal_has_overall() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool feature::has_overall() const {
  return _internal_has_overall();
}
inline void feature::clear_overall() {
  overall_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::infoprotobuf::feature_feature_status feature::_internal_overall() const {
  return static_cast< ::infoprotobuf::feature_feature_status >(overall_);
}
inline ::infoprotobuf::feature_feature_status feature::overall() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.feature.overall)
  return _internal_overall();
}
inline void feature::_internal_set_overall(::infoprotobuf::feature_feature_status value) {
  assert(::infoprotobuf::feature_feature_status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  overall_ = value;
}
inline void feature::set_overall(::infoprotobuf::feature_feature_status value) {
  _internal_set_overall(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.feature.overall)
}

// -------------------------------------------------------------------

// device_DeviceInstance

// required string name = 1;
inline bool device_DeviceInstance::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool device_DeviceInstance::has_name() const {
  return _internal_has_name();
}
inline void device_DeviceInstance::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& device_DeviceInstance::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.DeviceInstance.name)
  return _internal_name();
}
inline void device_DeviceInstance::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.DeviceInstance.name)
}
inline std::string* device_DeviceInstance::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.DeviceInstance.name)
  return _internal_mutable_name();
}
inline const std::string& device_DeviceInstance::_internal_name() const {
  return name_.Get();
}
inline void device_DeviceInstance::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device_DeviceInstance::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.DeviceInstance.name)
}
inline void device_DeviceInstance::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.DeviceInstance.name)
}
inline void device_DeviceInstance::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.DeviceInstance.name)
}
inline std::string* device_DeviceInstance::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device_DeviceInstance::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.DeviceInstance.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device_DeviceInstance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.DeviceInstance.name)
}
inline std::string* device_DeviceInstance::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.DeviceInstance.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device_DeviceInstance::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.DeviceInstance.name)
}

// required string briefname = 2;
inline bool device_DeviceInstance::_internal_has_briefname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool device_DeviceInstance::has_briefname() const {
  return _internal_has_briefname();
}
inline void device_DeviceInstance::clear_briefname() {
  briefname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& device_DeviceInstance::briefname() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.DeviceInstance.briefname)
  return _internal_briefname();
}
inline void device_DeviceInstance::set_briefname(const std::string& value) {
  _internal_set_briefname(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.DeviceInstance.briefname)
}
inline std::string* device_DeviceInstance::mutable_briefname() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.DeviceInstance.briefname)
  return _internal_mutable_briefname();
}
inline const std::string& device_DeviceInstance::_internal_briefname() const {
  return briefname_.Get();
}
inline void device_DeviceInstance::_internal_set_briefname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  briefname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device_DeviceInstance::set_briefname(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  briefname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.DeviceInstance.briefname)
}
inline void device_DeviceInstance::set_briefname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  briefname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.DeviceInstance.briefname)
}
inline void device_DeviceInstance::set_briefname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  briefname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.DeviceInstance.briefname)
}
inline std::string* device_DeviceInstance::_internal_mutable_briefname() {
  _has_bits_[0] |= 0x00000002u;
  return briefname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device_DeviceInstance::release_briefname() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.DeviceInstance.briefname)
  if (!_internal_has_briefname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return briefname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device_DeviceInstance::set_allocated_briefname(std::string* briefname) {
  if (briefname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  briefname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), briefname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.DeviceInstance.briefname)
}
inline std::string* device_DeviceInstance::unsafe_arena_release_briefname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.DeviceInstance.briefname)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return briefname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device_DeviceInstance::unsafe_arena_set_allocated_briefname(
    std::string* briefname) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (briefname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  briefname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      briefname, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.DeviceInstance.briefname)
}

// -------------------------------------------------------------------

// device_Extension

// required string name = 1;
inline bool device_Extension::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool device_Extension::has_name() const {
  return _internal_has_name();
}
inline void device_Extension::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& device_Extension::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.Extension.name)
  return _internal_name();
}
inline void device_Extension::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.Extension.name)
}
inline std::string* device_Extension::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.Extension.name)
  return _internal_mutable_name();
}
inline const std::string& device_Extension::_internal_name() const {
  return name_.Get();
}
inline void device_Extension::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device_Extension::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.Extension.name)
}
inline void device_Extension::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.Extension.name)
}
inline void device_Extension::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.Extension.name)
}
inline std::string* device_Extension::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device_Extension::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.Extension.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device_Extension::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.Extension.name)
}
inline std::string* device_Extension::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.Extension.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device_Extension::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.Extension.name)
}

// -------------------------------------------------------------------

// device

// required string type = 1;
inline bool device::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool device::has_type() const {
  return _internal_has_type();
}
inline void device::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& device::type() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.type)
  return _internal_type();
}
inline void device::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.type)
}
inline std::string* device::mutable_type() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.type)
  return _internal_mutable_type();
}
inline const std::string& device::_internal_type() const {
  return type_.Get();
}
inline void device::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.type)
}
inline void device::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.type)
}
inline void device::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.type)
}
inline std::string* device::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device::release_type() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.type)
}
inline std::string* device::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device::unsafe_arena_set_allocated_type(
    std::string* type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.type)
}

// optional string tag = 2;
inline bool device::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool device::has_tag() const {
  return _internal_has_tag();
}
inline void device::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& device::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.tag)
  return _internal_tag();
}
inline void device::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.tag)
}
inline std::string* device::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.tag)
  return _internal_mutable_tag();
}
inline const std::string& device::_internal_tag() const {
  return tag_.Get();
}
inline void device::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.tag)
}
inline void device::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.tag)
}
inline void device::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.tag)
}
inline std::string* device::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.tag)
}
inline std::string* device::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.tag)
}

// optional string fixed_image = 3;
inline bool device::_internal_has_fixed_image() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool device::has_fixed_image() const {
  return _internal_has_fixed_image();
}
inline void device::clear_fixed_image() {
  fixed_image_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& device::fixed_image() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.fixed_image)
  return _internal_fixed_image();
}
inline void device::set_fixed_image(const std::string& value) {
  _internal_set_fixed_image(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.fixed_image)
}
inline std::string* device::mutable_fixed_image() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.fixed_image)
  return _internal_mutable_fixed_image();
}
inline const std::string& device::_internal_fixed_image() const {
  return fixed_image_.Get();
}
inline void device::_internal_set_fixed_image(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  fixed_image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device::set_fixed_image(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  fixed_image_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.fixed_image)
}
inline void device::set_fixed_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  fixed_image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.fixed_image)
}
inline void device::set_fixed_image(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  fixed_image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.fixed_image)
}
inline std::string* device::_internal_mutable_fixed_image() {
  _has_bits_[0] |= 0x00000004u;
  return fixed_image_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device::release_fixed_image() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.fixed_image)
  if (!_internal_has_fixed_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return fixed_image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device::set_allocated_fixed_image(std::string* fixed_image) {
  if (fixed_image != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fixed_image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fixed_image,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.fixed_image)
}
inline std::string* device::unsafe_arena_release_fixed_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.fixed_image)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return fixed_image_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device::unsafe_arena_set_allocated_fixed_image(
    std::string* fixed_image) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (fixed_image != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fixed_image_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      fixed_image, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.fixed_image)
}

// optional string mandatory = 4;
inline bool device::_internal_has_mandatory() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool device::has_mandatory() const {
  return _internal_has_mandatory();
}
inline void device::clear_mandatory() {
  mandatory_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& device::mandatory() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.mandatory)
  return _internal_mandatory();
}
inline void device::set_mandatory(const std::string& value) {
  _internal_set_mandatory(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.mandatory)
}
inline std::string* device::mutable_mandatory() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.mandatory)
  return _internal_mutable_mandatory();
}
inline const std::string& device::_internal_mandatory() const {
  return mandatory_.Get();
}
inline void device::_internal_set_mandatory(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  mandatory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device::set_mandatory(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  mandatory_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.mandatory)
}
inline void device::set_mandatory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  mandatory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.mandatory)
}
inline void device::set_mandatory(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  mandatory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.mandatory)
}
inline std::string* device::_internal_mutable_mandatory() {
  _has_bits_[0] |= 0x00000008u;
  return mandatory_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device::release_mandatory() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.mandatory)
  if (!_internal_has_mandatory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return mandatory_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device::set_allocated_mandatory(std::string* mandatory) {
  if (mandatory != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mandatory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mandatory,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.mandatory)
}
inline std::string* device::unsafe_arena_release_mandatory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.mandatory)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return mandatory_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device::unsafe_arena_set_allocated_mandatory(
    std::string* mandatory) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mandatory != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mandatory_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mandatory, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.mandatory)
}

// optional string interface = 5;
inline bool device::_internal_has_interface() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool device::has_interface() const {
  return _internal_has_interface();
}
inline void device::clear_interface() {
  interface_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& device::interface() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.interface)
  return _internal_interface();
}
inline void device::set_interface(const std::string& value) {
  _internal_set_interface(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.device.interface)
}
inline std::string* device::mutable_interface() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.interface)
  return _internal_mutable_interface();
}
inline const std::string& device::_internal_interface() const {
  return interface_.Get();
}
inline void device::_internal_set_interface(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void device::set_interface(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  interface_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.device.interface)
}
inline void device::set_interface(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.device.interface)
}
inline void device::set_interface(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  interface_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.device.interface)
}
inline std::string* device::_internal_mutable_interface() {
  _has_bits_[0] |= 0x00000010u;
  return interface_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* device::release_interface() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.interface)
  if (!_internal_has_interface()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return interface_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void device::set_allocated_interface(std::string* interface) {
  if (interface != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  interface_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interface,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.interface)
}
inline std::string* device::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.device.interface)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return interface_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void device::unsafe_arena_set_allocated_interface(
    std::string* interface) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (interface != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  interface_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      interface, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.interface)
}

// optional .infoprotobuf.device.DeviceInstance device_instance = 6;
inline bool device::_internal_has_device_instance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || device_instance_ != nullptr);
  return value;
}
inline bool device::has_device_instance() const {
  return _internal_has_device_instance();
}
inline void device::clear_device_instance() {
  if (device_instance_ != nullptr) device_instance_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::infoprotobuf::device_DeviceInstance& device::_internal_device_instance() const {
  const ::infoprotobuf::device_DeviceInstance* p = device_instance_;
  return p != nullptr ? *p : *reinterpret_cast<const ::infoprotobuf::device_DeviceInstance*>(
      &::infoprotobuf::_device_DeviceInstance_default_instance_);
}
inline const ::infoprotobuf::device_DeviceInstance& device::device_instance() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.device_instance)
  return _internal_device_instance();
}
inline void device::unsafe_arena_set_allocated_device_instance(
    ::infoprotobuf::device_DeviceInstance* device_instance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_instance_);
  }
  device_instance_ = device_instance;
  if (device_instance) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.device.device_instance)
}
inline ::infoprotobuf::device_DeviceInstance* device::release_device_instance() {
  auto temp = unsafe_arena_release_device_instance();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::infoprotobuf::device_DeviceInstance* device::unsafe_arena_release_device_instance() {
  // @@protoc_insertion_point(field_release:infoprotobuf.device.device_instance)
  _has_bits_[0] &= ~0x00000020u;
  ::infoprotobuf::device_DeviceInstance* temp = device_instance_;
  device_instance_ = nullptr;
  return temp;
}
inline ::infoprotobuf::device_DeviceInstance* device::_internal_mutable_device_instance() {
  _has_bits_[0] |= 0x00000020u;
  if (device_instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::infoprotobuf::device_DeviceInstance>(GetArena());
    device_instance_ = p;
  }
  return device_instance_;
}
inline ::infoprotobuf::device_DeviceInstance* device::mutable_device_instance() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.device_instance)
  return _internal_mutable_device_instance();
}
inline void device::set_allocated_device_instance(::infoprotobuf::device_DeviceInstance* device_instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete device_instance_;
  }
  if (device_instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(device_instance);
    if (message_arena != submessage_arena) {
      device_instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_instance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  device_instance_ = device_instance;
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.device.device_instance)
}

// repeated .infoprotobuf.device.Extension extension = 7;
inline int device::_internal_extension_size() const {
  return extension_.size();
}
inline int device::extension_size() const {
  return _internal_extension_size();
}
inline void device::clear_extension() {
  extension_.Clear();
}
inline ::infoprotobuf::device_Extension* device::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.device.extension)
  return extension_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_Extension >*
device::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.device.extension)
  return &extension_;
}
inline const ::infoprotobuf::device_Extension& device::_internal_extension(int index) const {
  return extension_.Get(index);
}
inline const ::infoprotobuf::device_Extension& device::extension(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.device.extension)
  return _internal_extension(index);
}
inline ::infoprotobuf::device_Extension* device::_internal_add_extension() {
  return extension_.Add();
}
inline ::infoprotobuf::device_Extension* device::add_extension() {
  // @@protoc_insertion_point(field_add:infoprotobuf.device.extension)
  return _internal_add_extension();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::device_Extension >&
device::extension() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.device.extension)
  return extension_;
}

// -------------------------------------------------------------------

// slot_SlotOption

// required string name = 1;
inline bool slot_SlotOption::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool slot_SlotOption::has_name() const {
  return _internal_has_name();
}
inline void slot_SlotOption::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& slot_SlotOption::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.slot.SlotOption.name)
  return _internal_name();
}
inline void slot_SlotOption::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.slot.SlotOption.name)
}
inline std::string* slot_SlotOption::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.slot.SlotOption.name)
  return _internal_mutable_name();
}
inline const std::string& slot_SlotOption::_internal_name() const {
  return name_.Get();
}
inline void slot_SlotOption::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void slot_SlotOption::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.slot.SlotOption.name)
}
inline void slot_SlotOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.slot.SlotOption.name)
}
inline void slot_SlotOption::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.slot.SlotOption.name)
}
inline std::string* slot_SlotOption::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* slot_SlotOption::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.slot.SlotOption.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void slot_SlotOption::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.slot.SlotOption.name)
}
inline std::string* slot_SlotOption::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.slot.SlotOption.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void slot_SlotOption::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.slot.SlotOption.name)
}

// required string devname = 2;
inline bool slot_SlotOption::_internal_has_devname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool slot_SlotOption::has_devname() const {
  return _internal_has_devname();
}
inline void slot_SlotOption::clear_devname() {
  devname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& slot_SlotOption::devname() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.slot.SlotOption.devname)
  return _internal_devname();
}
inline void slot_SlotOption::set_devname(const std::string& value) {
  _internal_set_devname(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.slot.SlotOption.devname)
}
inline std::string* slot_SlotOption::mutable_devname() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.slot.SlotOption.devname)
  return _internal_mutable_devname();
}
inline const std::string& slot_SlotOption::_internal_devname() const {
  return devname_.Get();
}
inline void slot_SlotOption::_internal_set_devname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  devname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void slot_SlotOption::set_devname(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  devname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.slot.SlotOption.devname)
}
inline void slot_SlotOption::set_devname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  devname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.slot.SlotOption.devname)
}
inline void slot_SlotOption::set_devname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  devname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.slot.SlotOption.devname)
}
inline std::string* slot_SlotOption::_internal_mutable_devname() {
  _has_bits_[0] |= 0x00000002u;
  return devname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* slot_SlotOption::release_devname() {
  // @@protoc_insertion_point(field_release:infoprotobuf.slot.SlotOption.devname)
  if (!_internal_has_devname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return devname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void slot_SlotOption::set_allocated_devname(std::string* devname) {
  if (devname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  devname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.slot.SlotOption.devname)
}
inline std::string* slot_SlotOption::unsafe_arena_release_devname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.slot.SlotOption.devname)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return devname_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void slot_SlotOption::unsafe_arena_set_allocated_devname(
    std::string* devname) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (devname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  devname_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      devname, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.slot.SlotOption.devname)
}

// optional bool default = 3 [default = false];
inline bool slot_SlotOption::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool slot_SlotOption::has_default_() const {
  return _internal_has_default_();
}
inline void slot_SlotOption::clear_default_() {
  default__ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool slot_SlotOption::_internal_default_() const {
  return default__;
}
inline bool slot_SlotOption::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.slot.SlotOption.default)
  return _internal_default_();
}
inline void slot_SlotOption::_internal_set_default_(bool value) {
  _has_bits_[0] |= 0x00000004u;
  default__ = value;
}
inline void slot_SlotOption::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.slot.SlotOption.default)
}

// -------------------------------------------------------------------

// slot

// required string name = 1;
inline bool slot::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool slot::has_name() const {
  return _internal_has_name();
}
inline void slot::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& slot::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.slot.name)
  return _internal_name();
}
inline void slot::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.slot.name)
}
inline std::string* slot::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.slot.name)
  return _internal_mutable_name();
}
inline const std::string& slot::_internal_name() const {
  return name_.Get();
}
inline void slot::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void slot::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.slot.name)
}
inline void slot::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.slot.name)
}
inline void slot::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.slot.name)
}
inline std::string* slot::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* slot::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.slot.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void slot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.slot.name)
}
inline std::string* slot::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.slot.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void slot::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.slot.name)
}

// repeated .infoprotobuf.slot.SlotOption slotoption = 2;
inline int slot::_internal_slotoption_size() const {
  return slotoption_.size();
}
inline int slot::slotoption_size() const {
  return _internal_slotoption_size();
}
inline void slot::clear_slotoption() {
  slotoption_.Clear();
}
inline ::infoprotobuf::slot_SlotOption* slot::mutable_slotoption(int index) {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.slot.slotoption)
  return slotoption_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot_SlotOption >*
slot::mutable_slotoption() {
  // @@protoc_insertion_point(field_mutable_list:infoprotobuf.slot.slotoption)
  return &slotoption_;
}
inline const ::infoprotobuf::slot_SlotOption& slot::_internal_slotoption(int index) const {
  return slotoption_.Get(index);
}
inline const ::infoprotobuf::slot_SlotOption& slot::slotoption(int index) const {
  // @@protoc_insertion_point(field_get:infoprotobuf.slot.slotoption)
  return _internal_slotoption(index);
}
inline ::infoprotobuf::slot_SlotOption* slot::_internal_add_slotoption() {
  return slotoption_.Add();
}
inline ::infoprotobuf::slot_SlotOption* slot::add_slotoption() {
  // @@protoc_insertion_point(field_add:infoprotobuf.slot.slotoption)
  return _internal_add_slotoption();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infoprotobuf::slot_SlotOption >&
slot::slotoption() const {
  // @@protoc_insertion_point(field_list:infoprotobuf.slot.slotoption)
  return slotoption_;
}

// -------------------------------------------------------------------

// softwarelist

// required string tag = 1;
inline bool softwarelist::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool softwarelist::has_tag() const {
  return _internal_has_tag();
}
inline void softwarelist::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& softwarelist::tag() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.softwarelist.tag)
  return _internal_tag();
}
inline void softwarelist::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.softwarelist.tag)
}
inline std::string* softwarelist::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.softwarelist.tag)
  return _internal_mutable_tag();
}
inline const std::string& softwarelist::_internal_tag() const {
  return tag_.Get();
}
inline void softwarelist::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void softwarelist::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.softwarelist.tag)
}
inline void softwarelist::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.softwarelist.tag)
}
inline void softwarelist::set_tag(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.softwarelist.tag)
}
inline std::string* softwarelist::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* softwarelist::release_tag() {
  // @@protoc_insertion_point(field_release:infoprotobuf.softwarelist.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void softwarelist::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.softwarelist.tag)
}
inline std::string* softwarelist::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.softwarelist.tag)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return tag_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void softwarelist::unsafe_arena_set_allocated_tag(
    std::string* tag) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      tag, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.softwarelist.tag)
}

// required string name = 2;
inline bool softwarelist::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool softwarelist::has_name() const {
  return _internal_has_name();
}
inline void softwarelist::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& softwarelist::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.softwarelist.name)
  return _internal_name();
}
inline void softwarelist::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.softwarelist.name)
}
inline std::string* softwarelist::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.softwarelist.name)
  return _internal_mutable_name();
}
inline const std::string& softwarelist::_internal_name() const {
  return name_.Get();
}
inline void softwarelist::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void softwarelist::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.softwarelist.name)
}
inline void softwarelist::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.softwarelist.name)
}
inline void softwarelist::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.softwarelist.name)
}
inline std::string* softwarelist::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* softwarelist::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.softwarelist.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void softwarelist::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.softwarelist.name)
}
inline std::string* softwarelist::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.softwarelist.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void softwarelist::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.softwarelist.name)
}

// required .infoprotobuf.softwarelist.Status status = 3;
inline bool softwarelist::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool softwarelist::has_status() const {
  return _internal_has_status();
}
inline void softwarelist::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::infoprotobuf::softwarelist_Status softwarelist::_internal_status() const {
  return static_cast< ::infoprotobuf::softwarelist_Status >(status_);
}
inline ::infoprotobuf::softwarelist_Status softwarelist::status() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.softwarelist.status)
  return _internal_status();
}
inline void softwarelist::_internal_set_status(::infoprotobuf::softwarelist_Status value) {
  assert(::infoprotobuf::softwarelist_Status_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void softwarelist::set_status(::infoprotobuf::softwarelist_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.softwarelist.status)
}

// optional string filter = 4;
inline bool softwarelist::_internal_has_filter() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool softwarelist::has_filter() const {
  return _internal_has_filter();
}
inline void softwarelist::clear_filter() {
  filter_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& softwarelist::filter() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.softwarelist.filter)
  return _internal_filter();
}
inline void softwarelist::set_filter(const std::string& value) {
  _internal_set_filter(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.softwarelist.filter)
}
inline std::string* softwarelist::mutable_filter() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.softwarelist.filter)
  return _internal_mutable_filter();
}
inline const std::string& softwarelist::_internal_filter() const {
  return filter_.Get();
}
inline void softwarelist::_internal_set_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void softwarelist::set_filter(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  filter_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.softwarelist.filter)
}
inline void softwarelist::set_filter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.softwarelist.filter)
}
inline void softwarelist::set_filter(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.softwarelist.filter)
}
inline std::string* softwarelist::_internal_mutable_filter() {
  _has_bits_[0] |= 0x00000004u;
  return filter_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* softwarelist::release_filter() {
  // @@protoc_insertion_point(field_release:infoprotobuf.softwarelist.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return filter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void softwarelist::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.softwarelist.filter)
}
inline std::string* softwarelist::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.softwarelist.filter)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return filter_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void softwarelist::unsafe_arena_set_allocated_filter(
    std::string* filter) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (filter != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filter_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      filter, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.softwarelist.filter)
}

// -------------------------------------------------------------------

// ramoption

// required string name = 1;
inline bool ramoption::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ramoption::has_name() const {
  return _internal_has_name();
}
inline void ramoption::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ramoption::name() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.ramoption.name)
  return _internal_name();
}
inline void ramoption::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.ramoption.name)
}
inline std::string* ramoption::mutable_name() {
  // @@protoc_insertion_point(field_mutable:infoprotobuf.ramoption.name)
  return _internal_mutable_name();
}
inline const std::string& ramoption::_internal_name() const {
  return name_.Get();
}
inline void ramoption::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ramoption::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:infoprotobuf.ramoption.name)
}
inline void ramoption::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:infoprotobuf.ramoption.name)
}
inline void ramoption::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:infoprotobuf.ramoption.name)
}
inline std::string* ramoption::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ramoption::release_name() {
  // @@protoc_insertion_point(field_release:infoprotobuf.ramoption.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ramoption::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:infoprotobuf.ramoption.name)
}
inline std::string* ramoption::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infoprotobuf.ramoption.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ramoption::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infoprotobuf.ramoption.name)
}

// optional bool default = 2;
inline bool ramoption::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ramoption::has_default_() const {
  return _internal_has_default_();
}
inline void ramoption::clear_default_() {
  default__ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ramoption::_internal_default_() const {
  return default__;
}
inline bool ramoption::default_() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.ramoption.default)
  return _internal_default_();
}
inline void ramoption::_internal_set_default_(bool value) {
  _has_bits_[0] |= 0x00000002u;
  default__ = value;
}
inline void ramoption::set_default_(bool value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.ramoption.default)
}

// optional uint32 value = 3;
inline bool ramoption::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ramoption::has_value() const {
  return _internal_has_value();
}
inline void ramoption::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ramoption::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ramoption::value() const {
  // @@protoc_insertion_point(field_get:infoprotobuf.ramoption.value)
  return _internal_value();
}
inline void ramoption::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void ramoption::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:infoprotobuf.ramoption.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace infoprotobuf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::infoprotobuf::condition_condition_relation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::condition_condition_relation>() {
  return ::infoprotobuf::condition_condition_relation_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::driver_driver_status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::driver_driver_status>() {
  return ::infoprotobuf::driver_driver_status_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::driver_Supported> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::driver_Supported>() {
  return ::infoprotobuf::driver_Supported_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::feature_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::feature_Type>() {
  return ::infoprotobuf::feature_Type_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::feature_feature_status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::feature_feature_status>() {
  return ::infoprotobuf::feature_feature_status_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::softwarelist_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::softwarelist_Status>() {
  return ::infoprotobuf::softwarelist_Status_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::display_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::display_type>() {
  return ::infoprotobuf::display_type_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::display_rotation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::display_rotation>() {
  return ::infoprotobuf::display_rotation_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::status>() {
  return ::infoprotobuf::status_descriptor();
}
template <> struct is_proto_enum< ::infoprotobuf::chip_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infoprotobuf::chip_type>() {
  return ::infoprotobuf::chip_type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_info_2eproto
