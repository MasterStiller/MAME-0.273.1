// license:BSD-3-Clause
// copyright-holders:Nicola Salmoria
/***************************************************************************

  video.c

  Functions to emulate the video hardware of the machine.

***************************************************************************/

#include "emu.h"
#include "includes/galaga.h"

#define LOG_DEBUG           (1 << 0U)
#define LOG_ALL             (LOG_DEBUG)

#define VERBOSE             (LOG_ALL)

#include "logmacro.h"

#define MAX_STARS 252
#define STARS_COLOR_BASE (64*4+64*4)

/*
Galaga star line and pixel locations pulled directly from
a clocked stepping of the 05 starfield. The chip was clocked
on a test rig with hblank and vblank simulated, each X & Y
location of a star being recorded along with it's color value.

Because the starfield begins generating stars at the point
in time it's enabled the exact horiz location of the stars
on Galaga depends on the length of time of the POST for the
original board.

Two control bits determine which of two sets are displayed
set 0 or 1 and simultaneously 2 or 3.

There are 63 stars in each set, 126 displayed at any one time

*/

galaga_state::star const galaga_state::s_star_seed_tab[252]=
{
	// also shared by Bosconian

	// star set 0
	{0x0085, 0x0006, 0x35, 0x00},
	{0x008f, 0x0008, 0x30, 0x00},
	{0x00e5, 0x001b, 0x07, 0x00},
	{0x0022, 0x001c, 0x31, 0x00},
	{0x00e5, 0x0025, 0x1d, 0x00},
	{0x0015, 0x0026, 0x29, 0x00},
	{0x0080, 0x002d, 0x3b, 0x00},
	{0x0097, 0x002e, 0x1c, 0x00},
	{0x00ba, 0x003b, 0x05, 0x00},
	{0x0036, 0x003d, 0x36, 0x00},
	{0x0057, 0x0044, 0x09, 0x00},
	{0x00cf, 0x0044, 0x3d, 0x00},
	{0x0061, 0x004e, 0x27, 0x00},
	{0x0087, 0x0064, 0x1a, 0x00},
	{0x00d6, 0x0064, 0x17, 0x00},
	{0x000b, 0x006c, 0x3c, 0x00},
	{0x0006, 0x006d, 0x24, 0x00},
	{0x0018, 0x006e, 0x3a, 0x00},
	{0x00a9, 0x0079, 0x23, 0x00},
	{0x008a, 0x007b, 0x11, 0x00},
	{0x00d6, 0x0080, 0x0c, 0x00},
	{0x0067, 0x0082, 0x3f, 0x00},
	{0x0039, 0x0083, 0x38, 0x00},
	{0x0072, 0x0083, 0x14, 0x00},
	{0x00ec, 0x0084, 0x16, 0x00},
	{0x008e, 0x0085, 0x10, 0x00},
	{0x0020, 0x0088, 0x25, 0x00},
	{0x0095, 0x008a, 0x0f, 0x00},
	{0x000e, 0x008d, 0x00, 0x00},
	{0x0006, 0x0091, 0x2e, 0x00},
	{0x0007, 0x0094, 0x0d, 0x00},
	{0x00ae, 0x0097, 0x0b, 0x00},
	{0x0000, 0x0098, 0x2d, 0x00},
	{0x0086, 0x009b, 0x01, 0x00},
	{0x0058, 0x00a1, 0x34, 0x00},
	{0x00fe, 0x00a1, 0x3e, 0x00},
	{0x00a2, 0x00a8, 0x1f, 0x00},
	{0x0041, 0x00aa, 0x0a, 0x00},
	{0x003f, 0x00ac, 0x32, 0x00},
	{0x00de, 0x00ac, 0x03, 0x00},
	{0x00d4, 0x00b9, 0x26, 0x00},
	{0x006d, 0x00bb, 0x1b, 0x00},
	{0x0062, 0x00bd, 0x39, 0x00},
	{0x00c9, 0x00be, 0x18, 0x00},
	{0x006c, 0x00c1, 0x04, 0x00},
	{0x0059, 0x00c3, 0x21, 0x00},
	{0x0060, 0x00cc, 0x0e, 0x00},
	{0x0091, 0x00cc, 0x12, 0x00},
	{0x003f, 0x00cf, 0x06, 0x00},
	{0x00f7, 0x00cf, 0x22, 0x00},
	{0x0044, 0x00d0, 0x33, 0x00},
	{0x0034, 0x00d2, 0x08, 0x00},
	{0x00d3, 0x00d9, 0x20, 0x00},
	{0x0071, 0x00dd, 0x37, 0x00},
	{0x0073, 0x00e1, 0x2c, 0x00},
	{0x00b9, 0x00e3, 0x2f, 0x00},
	{0x00a9, 0x00e4, 0x13, 0x00},
	{0x00d3, 0x00e7, 0x19, 0x00},
	{0x0037, 0x00ed, 0x02, 0x00},
	{0x00bd, 0x00f4, 0x15, 0x00},
	{0x000f, 0x00f6, 0x28, 0x00},
	{0x004f, 0x00f7, 0x2b, 0x00},
	{0x00fb, 0x00ff, 0x2a, 0x00},

	// star set 1
	{0x00fe, 0x0004, 0x3d, 0x01},
	{0x00c4, 0x0006, 0x10, 0x01},
	{0x001e, 0x0007, 0x2d, 0x01},
	{0x0083, 0x000b, 0x1f, 0x01},
	{0x002e, 0x000d, 0x3c, 0x01},
	{0x001f, 0x000e, 0x00, 0x01},
	{0x00d8, 0x000e, 0x2c, 0x01},
	{0x0003, 0x000f, 0x17, 0x01},
	{0x0095, 0x0011, 0x3f, 0x01},
	{0x006a, 0x0017, 0x35, 0x01},
	{0x00cc, 0x0017, 0x02, 0x01},
	{0x0000, 0x0018, 0x32, 0x01},
	{0x0092, 0x001d, 0x36, 0x01},
	{0x00e3, 0x0021, 0x04, 0x01},
	{0x002f, 0x002d, 0x37, 0x01},
	{0x00f0, 0x002f, 0x0c, 0x01},
	{0x009b, 0x003e, 0x06, 0x01},
	{0x00a4, 0x004c, 0x07, 0x01},
	{0x00ea, 0x004d, 0x13, 0x01},
	{0x0084, 0x004e, 0x21, 0x01},
	{0x0033, 0x0052, 0x0f, 0x01},
	{0x0070, 0x0053, 0x0e, 0x01},
	{0x0006, 0x0059, 0x08, 0x01},
	{0x0081, 0x0060, 0x28, 0x01},
	{0x0037, 0x0061, 0x29, 0x01},
	{0x008f, 0x0067, 0x2f, 0x01},
	{0x001b, 0x006a, 0x1d, 0x01},
	{0x00bf, 0x007c, 0x12, 0x01},
	{0x0051, 0x007f, 0x31, 0x01},
	{0x0061, 0x0086, 0x25, 0x01},
	{0x006a, 0x008f, 0x0d, 0x01},
	{0x006a, 0x0091, 0x19, 0x01},
	{0x0090, 0x0092, 0x05, 0x01},
	{0x003b, 0x0096, 0x24, 0x01},
	{0x008c, 0x0097, 0x0a, 0x01},
	{0x0006, 0x0099, 0x03, 0x01},
	{0x0038, 0x0099, 0x38, 0x01},
	{0x00a8, 0x0099, 0x18, 0x01},
	{0x0076, 0x00a6, 0x20, 0x01},
	{0x00ad, 0x00a6, 0x1c, 0x01},
	{0x00ec, 0x00a6, 0x1e, 0x01},
	{0x0086, 0x00ac, 0x15, 0x01},
	{0x0078, 0x00af, 0x3e, 0x01},
	{0x007b, 0x00b3, 0x09, 0x01},
	{0x0027, 0x00b8, 0x39, 0x01},
	{0x0088, 0x00c2, 0x23, 0x01},
	{0x0044, 0x00c3, 0x3a, 0x01},
	{0x00cf, 0x00c5, 0x34, 0x01},
	{0x0035, 0x00c9, 0x30, 0x01},
	{0x006e, 0x00d1, 0x3b, 0x01},
	{0x00d6, 0x00d7, 0x16, 0x01},
	{0x003a, 0x00d9, 0x2b, 0x01},
	{0x00ab, 0x00e0, 0x11, 0x01},
	{0x00e0, 0x00e2, 0x1b, 0x01},
	{0x006f, 0x00e6, 0x0b, 0x01},
	{0x00b8, 0x00e8, 0x14, 0x01},
	{0x00d9, 0x00e8, 0x1a, 0x01},
	{0x00f9, 0x00e8, 0x22, 0x01},
	{0x0004, 0x00f1, 0x2e, 0x01},
	{0x0049, 0x00f8, 0x26, 0x01},
	{0x0010, 0x00f9, 0x01, 0x01},
	{0x0039, 0x00fb, 0x33, 0x01},
	{0x0028, 0x00fc, 0x27, 0x01},

	// star set 2
	{0x00fa, 0x0006, 0x19, 0x02},
	{0x00e4, 0x0007, 0x2d, 0x02},
	{0x0072, 0x000a, 0x03, 0x02},
	{0x0084, 0x001b, 0x00, 0x02},
	{0x00ba, 0x001d, 0x29, 0x02},
	{0x00e3, 0x0022, 0x04, 0x02},
	{0x00d1, 0x0026, 0x2a, 0x02},
	{0x0089, 0x0032, 0x30, 0x02},
	{0x005b, 0x0036, 0x27, 0x02},
	{0x0084, 0x003a, 0x36, 0x02},
	{0x0053, 0x003f, 0x0d, 0x02},
	{0x0008, 0x0040, 0x1d, 0x02},
	{0x0055, 0x0040, 0x1a, 0x02},
	{0x00aa, 0x0041, 0x31, 0x02},
	{0x00fb, 0x0041, 0x2b, 0x02},
	{0x00bc, 0x0046, 0x16, 0x02},
	{0x0093, 0x0052, 0x39, 0x02},
	{0x00b9, 0x0057, 0x10, 0x02},
	{0x0054, 0x0059, 0x28, 0x02},
	{0x00e6, 0x005a, 0x01, 0x02},
	{0x00a7, 0x005d, 0x1b, 0x02},
	{0x002d, 0x005e, 0x35, 0x02},
	{0x0014, 0x0062, 0x21, 0x02},
	{0x0069, 0x006d, 0x1f, 0x02},
	{0x00ce, 0x006f, 0x0b, 0x02},
	{0x00df, 0x0075, 0x2f, 0x02},
	{0x00cb, 0x0077, 0x12, 0x02},
	{0x004e, 0x007c, 0x23, 0x02},
	{0x004a, 0x0084, 0x0f, 0x02},
	{0x0012, 0x0086, 0x25, 0x02},
	{0x0068, 0x008c, 0x32, 0x02},
	{0x0003, 0x0095, 0x20, 0x02},
	{0x000a, 0x009c, 0x17, 0x02},
	{0x005b, 0x00a3, 0x08, 0x02},
	{0x005f, 0x00a4, 0x3e, 0x02},
	{0x0072, 0x00a4, 0x2e, 0x02},
	{0x00cc, 0x00a6, 0x06, 0x02},
	{0x008a, 0x00ab, 0x0c, 0x02},
	{0x00e0, 0x00ad, 0x26, 0x02},
	{0x00f3, 0x00af, 0x0a, 0x02},
	{0x0075, 0x00b4, 0x13, 0x02},
	{0x0068, 0x00b7, 0x11, 0x02},
	{0x006d, 0x00c2, 0x2c, 0x02},
	{0x0076, 0x00c3, 0x14, 0x02},
	{0x00cf, 0x00c4, 0x1e, 0x02},
	{0x0004, 0x00c5, 0x1c, 0x02},
	{0x0013, 0x00c6, 0x3f, 0x02},
	{0x00b9, 0x00c7, 0x3c, 0x02},
	{0x0005, 0x00d7, 0x34, 0x02},
	{0x0095, 0x00d7, 0x3a, 0x02},
	{0x00fc, 0x00d8, 0x02, 0x02},
	{0x00e7, 0x00dc, 0x09, 0x02},
	{0x001d, 0x00e1, 0x05, 0x02},
	{0x0005, 0x00e6, 0x33, 0x02},
	{0x001c, 0x00e9, 0x3b, 0x02},
	{0x00a2, 0x00ed, 0x37, 0x02},
	{0x0028, 0x00ee, 0x07, 0x02},
	{0x00dd, 0x00ef, 0x18, 0x02},
	{0x006d, 0x00f0, 0x38, 0x02},
	{0x00a1, 0x00f2, 0x0e, 0x02},
	{0x0074, 0x00f7, 0x3d, 0x02},
	{0x0069, 0x00f9, 0x22, 0x02},
	{0x003f, 0x00ff, 0x24, 0x02},

	// star set 3
	{0x0071, 0x0010, 0x34, 0x03},
	{0x00af, 0x0011, 0x23, 0x03},
	{0x00a0, 0x0014, 0x26, 0x03},
	{0x0002, 0x0017, 0x02, 0x03},
	{0x004b, 0x0019, 0x31, 0x03},
	{0x0093, 0x001c, 0x0e, 0x03},
	{0x001b, 0x001e, 0x25, 0x03},
	{0x0032, 0x0020, 0x2e, 0x03},
	{0x00ee, 0x0020, 0x3a, 0x03},
	{0x0079, 0x0022, 0x2f, 0x03},
	{0x006c, 0x0023, 0x17, 0x03},
	{0x00bc, 0x0025, 0x11, 0x03},
	{0x0041, 0x0029, 0x30, 0x03},
	{0x001c, 0x002e, 0x32, 0x03},
	{0x00b9, 0x0031, 0x01, 0x03},
	{0x0083, 0x0032, 0x05, 0x03},
	{0x0095, 0x003a, 0x12, 0x03},
	{0x000d, 0x003f, 0x07, 0x03},
	{0x0020, 0x0041, 0x33, 0x03},
	{0x0092, 0x0045, 0x2c, 0x03},
	{0x00d4, 0x0047, 0x08, 0x03},
	{0x00a1, 0x004b, 0x2d, 0x03},
	{0x00d2, 0x004b, 0x3b, 0x03},
	{0x00d6, 0x0052, 0x24, 0x03},
	{0x009a, 0x005f, 0x1c, 0x03},
	{0x0016, 0x0060, 0x3d, 0x03},
	{0x001a, 0x0063, 0x1f, 0x03},
	{0x00cd, 0x0066, 0x28, 0x03},
	{0x00ff, 0x0067, 0x10, 0x03},
	{0x0035, 0x0069, 0x20, 0x03},
	{0x008f, 0x006c, 0x04, 0x03},
	{0x00ca, 0x006c, 0x2a, 0x03},
	{0x005a, 0x0074, 0x09, 0x03},
	{0x0060, 0x0078, 0x38, 0x03},
	{0x0072, 0x0079, 0x1e, 0x03},
	{0x0037, 0x007f, 0x29, 0x03},
	{0x0012, 0x0080, 0x14, 0x03},
	{0x0029, 0x0082, 0x2b, 0x03},
	{0x0084, 0x0098, 0x36, 0x03},
	{0x0032, 0x0099, 0x37, 0x03},
	{0x00bb, 0x00a0, 0x19, 0x03},
	{0x003e, 0x00a3, 0x3e, 0x03},
	{0x004a, 0x00a6, 0x1a, 0x03},
	{0x0029, 0x00a7, 0x21, 0x03},
	{0x009d, 0x00b7, 0x22, 0x03},
	{0x006c, 0x00b9, 0x15, 0x03},
	{0x000c, 0x00c0, 0x0a, 0x03},
	{0x00c2, 0x00c3, 0x0f, 0x03},
	{0x002f, 0x00c9, 0x0d, 0x03},
	{0x00d2, 0x00ce, 0x16, 0x03},
	{0x00f3, 0x00ce, 0x0b, 0x03},
	{0x0075, 0x00cf, 0x27, 0x03},
	{0x001a, 0x00d5, 0x35, 0x03},
	{0x0026, 0x00d6, 0x39, 0x03},
	{0x0080, 0x00da, 0x3c, 0x03},
	{0x00a9, 0x00dd, 0x00, 0x03},
	{0x00bc, 0x00eb, 0x03, 0x03},
	{0x0032, 0x00ef, 0x1b, 0x03},
	{0x0067, 0x00f0, 0x3f, 0x03},
	{0x00ef, 0x00f1, 0x18, 0x03},
	{0x00a8, 0x00f3, 0x0c, 0x03},
	{0x00de, 0x00f9, 0x1d, 0x03},
	{0x002c, 0x00fa, 0x13, 0x03}
};




/***************************************************************************

  Convert the color PROMs.

  Galaga has one 32x8 palette PROM and two 256x4 color lookup table PROMs
  (one for characters, one for sprites). Only the first 128 bytes of the
  lookup tables seem to be used.
  The palette PROM is connected to the RGB output this way:

  bit 7 -- 220 ohm resistor  -- BLUE
        -- 470 ohm resistor  -- BLUE
        -- 220 ohm resistor  -- GREEN
        -- 470 ohm resistor  -- GREEN
        -- 1  kohm resistor  -- GREEN
        -- 220 ohm resistor  -- RED
        -- 470 ohm resistor  -- RED
  bit 0 -- 1  kohm resistor  -- RED

***************************************************************************/

void galaga_state::galaga_palette(palette_device &palette) const
{
	const uint8_t *color_prom = memregion("proms")->base();

	// core palette
	for (int i = 0; i < 32; i++)
	{
		int bit0, bit1, bit2;

		bit0 = BIT(*color_prom, 0);
		bit1 = BIT(*color_prom, 1);
		bit2 = BIT(*color_prom, 2);
		int const r = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
		bit0 = BIT(*color_prom, 3);
		bit1 = BIT(*color_prom, 4);
		bit2 = BIT(*color_prom, 5);
		int const g = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
		bit0 = 0;
		bit1 = BIT(*color_prom, 6);
		bit2 = BIT(*color_prom, 7);
		int const b = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;

		palette.set_indirect_color(i, rgb_t(r, g, b));
		color_prom++;
	}

	// palette for the stars
	for (int i = 0; i < 64; i++)
	{
		static constexpr int map[4] = { 0x00, 0x47, 0x97 ,0xde };

		int const r = map[(i >> 0) & 0x03];
		int const g = map[(i >> 2) & 0x03];
		int const b = map[(i >> 4) & 0x03];

		palette.set_indirect_color(32 + i, rgb_t(r, g, b));
	}

	// characters
	for (int i = 0; i < 64*4; i++)
		palette.set_pen_indirect(i, (*color_prom++ & 0x0f) | 0x10);

	// sprites
	for (int i = 0; i < 64*4; i++)
		palette.set_pen_indirect(64*4 + i, *color_prom++ & 0x0f);

	// now the stars
	for (int i = 0; i < 64; i++)
		palette.set_pen_indirect(64*4 + 64*4 + i, 32 + i);
}

/***************************************************************************

    Star field documentation

    Couriersud, May 2019:

    The code below was manually applied based on a pull request from
    Jindřich Makovička. He based his work on information published by
    Wolfgang Scherr about the 05XX on pin4.at.

    Wolfgang shared is VHDL implementation with the MAME team. I have
    created a spreadsheet implementation for his decode logic.

    Both implementations use the same Galois type LFSR( tap 15,12,10,5).
    Using the same seed value, the following holds true:

    Decode_W(lfsr[t-4]) = Decode_J(lfsr[t])

    The two decoding algorithm (Wolfgang, Jindřich) thus deliver the same
    results but with a 4 clock difference.

    Jindřich's code filters out stars with y<4. This matches the starfield
    measurements documented above. Wolfgang states that his code matches his
    measurements and there are stars with y<4.
    We need to have a closer look at this.

    Both implementations are complex compared to other star field gnerators
    used in the industry. We thus now have two decoding solutions matching
    the output. I wonder if there is a simpler one.

***************************************************************************/

void galaga_state::starfield_init()
{
	const uint16_t feed = 0x9420;

	int idx = 0;
	for (uint16_t sf = 0; sf < 4; ++sf)
	{
		// starfield select flags
		uint16_t sf1 = (sf >> 1) & 1;
		uint16_t sf2 = sf & 1;

		uint16_t i = 0x70cc;
		for (int cnt = 0; cnt < 65535; ++cnt)
		{
			// output enable lookup
			uint16_t xor1 = i ^ (i >> 3);
			uint16_t xor2 = xor1 ^ (i >> 2);
			uint16_t oe = (sf1 ? 0 : 0x4000) | ((sf1 ^ sf2) ? 0 : 0x1000);
			if ((i & 0x8007) == 0x8007
				&& (~i & 0x2008) == 0x2008
				&& (xor1 & 0x0100) == (sf1 ? 0 : 0x0100)
				&& (xor2 & 0x0040) == (sf2 ? 0 : 0x0040)
				&& (i & 0x5000) == oe
				&& cnt >= 256 * 4)
			{
				// color lookup
				uint16_t xor3 = (i >> 1) ^ (i >> 6);
				uint16_t clr =
					(((i >> 9) & 0x07)
					 | ((xor3 ^ (i >> 4) ^ (i >> 7)) & 0x08)
					 | (~xor3 & 0x10)
					 | (((i >> 2) ^ (i >> 5)) & 0x20))
					^ ((i & 0x4000) ? 0 : 0x24)
					^ ((((i >> 2) ^ i) & 0x1000) ? 0x21 : 0);
#if 0
				m_star_seed_tab[idx].x = cnt % 256;
				m_star_seed_tab[idx].y = cnt / 256;
				m_star_seed_tab[idx].col = clr;
				m_star_seed_tab[idx].set = sf;
#else
				int x = cnt % 256;
				int y = cnt / 256;
				int col = clr;
				int set = sf;

				if ((x != s_star_seed_tab[idx].x) || (y != s_star_seed_tab[idx].y)
					|| (col != s_star_seed_tab[idx].col) || (s_star_seed_tab[idx].set != set))
					LOGMASKED(LOG_DEBUG, "Mismatch: %d %d %d %d %d %d %d %d\n", x, y, col, set, s_star_seed_tab[idx].x,
						s_star_seed_tab[idx].y, s_star_seed_tab[idx].col, s_star_seed_tab[idx].set);
#endif
				++idx;
			}

			// update the LFSR
			if (i & 1)
				i = (i >> 1) ^ feed;
			else
				i = (i >> 1);
		}
	}
}

/***************************************************************************

  Callbacks for the TileMap code

***************************************************************************/

/* convert from 32x32 to 36x28 */
TILEMAP_MAPPER_MEMBER(galaga_state::tilemap_scan)
{
	int offs;

	row += 2;
	col -= 2;
	if (col & 0x20)
		offs = row + ((col & 0x1f) << 5);
	else
		offs = col + (row << 5);

	return offs;
}


TILE_GET_INFO_MEMBER(galaga_state::get_tile_info)
{
	/* the hardware has two character sets, one normal and one x-flipped. When
	   screen is flipped, character y flip is done by the hardware inverting the
	   timing signals, while x flip is done by selecting the 2nd character set.
	   We reproduce this here, but since the tilemap system automatically flips
	   characters when screen is flipped, we have to flip them back. */
	int color = m_videoram[tile_index + 0x400] & 0x3f;
	SET_TILE_INFO_MEMBER(0,
			(m_videoram[tile_index] & 0x7f) | (flip_screen() ? 0x80 : 0) | (m_galaga_gfxbank << 8),
			color,
			flip_screen() ? TILE_FLIPX : 0);
	tileinfo.group = color;
}



/***************************************************************************

  Start the video hardware emulation.

***************************************************************************/

VIDEO_START_MEMBER(galaga_state,galaga)
{
	m_fg_tilemap = &machine().tilemap().create(*m_gfxdecode, tilemap_get_info_delegate(*this, FUNC(galaga_state::get_tile_info)), tilemap_mapper_delegate(*this, FUNC(galaga_state::tilemap_scan)), 8,8,36,28);
	m_fg_tilemap->configure_groups(*m_gfxdecode->gfx(0), 0x1f);

	m_galaga_gfxbank = 0;

	save_item(NAME(m_stars_scrollx));
	save_item(NAME(m_stars_scrolly));
	save_item(NAME(m_galaga_gfxbank));

	starfield_init();
}



/***************************************************************************

  Memory handlers

***************************************************************************/


WRITE8_MEMBER(galaga_state::galaga_videoram_w)
{
	m_videoram[offset] = data;
	m_fg_tilemap->mark_tile_dirty(offset & 0x3ff);
}

WRITE_LINE_MEMBER(galaga_state::gatsbee_bank_w)
{
	m_galaga_gfxbank = state;
	m_fg_tilemap->mark_all_dirty();
}



/***************************************************************************

  Display refresh

***************************************************************************/

void galaga_state::draw_sprites(bitmap_ind16 &bitmap, const rectangle &cliprect )
{
	uint8_t *spriteram = m_galaga_ram1 + 0x380;
	uint8_t *spriteram_2 = m_galaga_ram2 + 0x380;
	uint8_t *spriteram_3 = m_galaga_ram3 + 0x380;
	int offs;


	for (offs = 0;offs < 0x80;offs += 2)
	{
		static const int gfx_offs[2][2] =
		{
			{ 0, 1 },
			{ 2, 3 }
		};
		int sprite = spriteram[offs] & 0x7f;
		int color = spriteram[offs+1] & 0x3f;
		int sx = spriteram_2[offs+1] - 40 + 0x100*(spriteram_3[offs+1] & 3);
		int sy = 256 - spriteram_2[offs] + 1;   // sprites are buffered and delayed by one scanline
		int flipx = (spriteram_3[offs] & 0x01);
		int flipy = (spriteram_3[offs] & 0x02) >> 1;
		int sizex = (spriteram_3[offs] & 0x04) >> 2;
		int sizey = (spriteram_3[offs] & 0x08) >> 3;
		int x,y;

		sy -= 16 * sizey;
		sy = (sy & 0xff) - 32;  // fix wraparound

		if (flip_screen())
		{
			flipx ^= 1;
			flipy ^= 1;
		}

		for (y = 0;y <= sizey;y++)
		{
			for (x = 0;x <= sizex;x++)
			{
				m_gfxdecode->gfx(1)->transmask(bitmap,cliprect,
					sprite + gfx_offs[y ^ (sizey * flipy)][x ^ (sizex * flipx)],
					color,
					flipx,flipy,
					sx + 16*x, sy + 16*y,
					m_palette->transpen_mask(*m_gfxdecode->gfx(1), color, 0x0f));
			}
		}
	}
}


void galaga_state::draw_stars(bitmap_ind16 &bitmap, const rectangle &cliprect )
{
	/* draw the stars */

	/* $a005 controls the stars ON/OFF */
	if ( m_videolatch->q5_r() == 1 )
	{
		int star_cntr;
		int set_a, set_b;

		/* two sets of stars controlled by these bits */
		set_a = m_videolatch->q3_r();
		set_b = m_videolatch->q4_r() | 2;

		for (star_cntr = 0;star_cntr < MAX_STARS ;star_cntr++)
		{
			int x,y;

			if ((set_a == s_star_seed_tab[star_cntr].set) || (set_b == s_star_seed_tab[star_cntr].set))
			{
				x = (s_star_seed_tab[star_cntr].x + m_stars_scrollx) % 256 + 16;
				y = (112 + s_star_seed_tab[star_cntr].y + m_stars_scrolly) % 256;
				/* 112 is a tweak to get alignment about perfect */

				if (cliprect.contains(x, y))
					bitmap.pix16(y, x) = STARS_COLOR_BASE + s_star_seed_tab[ star_cntr ].col;
			}

		}
	}
}

uint32_t galaga_state::screen_update_galaga(screen_device &screen, bitmap_ind16 &bitmap, const rectangle &cliprect)
{
	bitmap.fill(m_palette->black_pen(), cliprect);
	draw_stars(bitmap,cliprect);
	draw_sprites(bitmap,cliprect);
	m_fg_tilemap->draw(screen, bitmap, cliprect, 0,0);
	return 0;
}



WRITE_LINE_MEMBER(galaga_state::screen_vblank_galaga)
{
	// falling edge
	if (!state)
	{
		/* this function is called by galaga_interrupt_1() */
		int s0,s1,s2;
		static const int speeds[8] = { -1, -2, -3, 0, 3, 2, 1, 0 };

		s0 = m_videolatch->q0_r();
		s1 = m_videolatch->q1_r();
		s2 = m_videolatch->q2_r();

		m_stars_scrollx += speeds[s0 + s1*2 + s2*4];
	}
}
