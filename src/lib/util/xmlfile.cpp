// license:BSD-3-Clause
// copyright-holders:Aaron Giles
/***************************************************************************

    xmlfile.c

    XML file parsing code.

***************************************************************************/

#include "xmlfile.h"
#include <vector>

namespace util { namespace xml {

// write an XML tree to a file
void document_node::file_write(util::core_file &file)
{
	xml_corefile_writer writer(file);
	prepend_child(pugi::node_comment).set_value("This file is autogenerated; comments and unknown tags will be stripped");
	save(writer);
}

void document_node::load_string(const pugi::char_t* contents, unsigned int options)
{
	unsigned int pugi_opts = pugi::parse_default;
	switch(options)
	{
		case PARSE_FLAG_WHITESPACE_SIGNIFICANT:
			pugi_opts = pugi::parse_ws_pcdata;
	}
	res = xml_document::load_string(contents, pugi_opts);
}

void document_node::load_file(util::core_file &file, unsigned int options)
{
	int len = file.size();
	std::vector<pugi::char_t> buf(len);
	file.read(&buf[0], len);
	load_string(&buf[0], options);
}

/*-------------------------------------------------
    get_attribute_int_format - return the
    format of the given integer attribute
-------------------------------------------------*/

int_format get_attribute_int_format(const char *string)
{
	if (!string)
		return int_format::DECIMAL;
	else if (string[0] == '$')
		return int_format::HEX_DOLLAR;
	else if (string[0] == '0' && string[1] == 'x')
		return int_format::HEX_C;
	if (string[0] == '#')
		return int_format::DECIMAL_HASH;
	else
		return int_format::DECIMAL;
}



/***************************************************************************
    MISCELLANEOUS INTERFACES
***************************************************************************/

/*-------------------------------------------------
    normalize_string - normalize a string
    to ensure it doesn't contain embedded tags
-------------------------------------------------*/

const char *normalize_string(const char *string)
{
	static char buffer[1024];
	char *d = &buffer[0];

	if (string != nullptr)
	{
		while (*string)
		{
			switch (*string)
			{
				case '\"' : d += sprintf(d, "&quot;"); break;
				case '&'  : d += sprintf(d, "&amp;"); break;
				case '<'  : d += sprintf(d, "&lt;"); break;
				case '>'  : d += sprintf(d, "&gt;"); break;
				default:
					*d++ = *string;
			}
			++string;
		}
	}
	*d++ = 0;
	return buffer;
}


} } // namespace util::xml
