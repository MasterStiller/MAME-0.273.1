// license:BSD-3-Clause
// copyright-holders: R. Belmont
/**********************************************************************

    MM5740 Keyboard Encoder emulation

**********************************************************************
			    _____   _____
		    B3   1 |*    \_/     | 40  B4
		   Vll   2 |             | 39  B9
		 Clock   3 |             | 38  B2
		    X9   4 |             | 37  B1
		    X8   5 |             | 36  B8
		    X7   6 |             | 35  B7
		    X6   7 |             | 34  B6
		    X5   8 |             | 33  B5
		    X4   9 |             | 32  Vss
		    X3  10 |    MM5740   | 31  Y9
		    X2  11 |             | 30  Y8
		    X1  12 |             | 29  Y7
    Data Strobe Output  13 |             | 28  Y6
   Data Strobe Control  14 |             | 27  Y5
	 Output Enable  15 |             | 26  Y4
		Repeat  16 |             | 25  Y3
       Key Bounce Mask  17 |             | 24  Y2
		   Vgg  18 |             | 23  Y1
	       Control  19 |             | 22  Y0
	Shift Lock I/O  20 |_____________| 21  Shift

Name                 Pin No.     Function
----------------------------------------------------------------------

X1-X9                4-12        These pins are chip outputs which are 
				 used to drive the key switch matrix.
				 When activated (at the appropriate
				 scan time) they are driven high.

Y1-Y10               22-31       The Y sense inputs which are connected
				 to the X drive lines via the key switch
				 matrix. They are inernally precharged
				 to a low state and are pulled high upon
				 switch closure.

B1-B9                1,33-40     These are the data outputs which represent
				 the code for each keyswitch. They are
				 TRI-STATE outputs with direct TTL 
				 compatibility. When the output enable
				 input (Pin 15) is high, these outputs
				 are in the third state.

Data Strobe Output   13          The function of this pin is to indicate
				 that valid data has been entered by the
				 keyboard and is ready for acceptance. 
				 An active data strobe may be operated
				 in the pulse or level mode as indicated
				 by the timing diagram.

Data Strobe Control  14          The basic purpose of this input is to
				 provde data strobe output pulse width
				 control. When connected to the data
				 strobe output (Pin 13), the data
				 strobe will exhibit a one bit wide
				 pulse width. The pulse width may be
				 varied by interposing an RC network
				 between the data strobe output and
				 the strobe control input. For level
				 mode of operation the data strobe
				 control input may be tied to Vss
				 or to the data strobe output.

Output Enable        15          This input serves to TRI-STATE the
				 data output(B1-B9) lines. In addition,
				 it control the return of the data
				 strobe to the idle condition (low
				 state)which is needed in the level
				 strobe mode of operation.

Repeat               16          The repeat input is designed to
				 accept a repeat signal via the repeat
				 key. One data strobe will be issued
				 for each positive interval of the
				 repeat signal. Thus, if a 10 Hz
				 signal is applied to the repeat
				 switch, a 10 character per second
				 data strobe will be issued when
				 a data key and the repeat key are
				 held depressed.

Key-Bounce Mask      17          This pin is intended as a timing
				 node to mas switch key-bounce. The
				 mask time interval is generated by
				 connecting a capacitor to this pin.

Shift                21          When this input is brought to a
				 logic "0" (Vss) level, the encoder
				 will assume the shifted character mode.

Control              19          A logic "0" places the encoder in
				 the control character mode.

Shift Lock I/O       20          This pin is intended to serve as an
				 input when the shift lock key is
				 depressed. It places the encoder
				 in the shift mode. Upon release of
				 the key, the shift mode will be
				 maintained and this pin will serve
				 as an output to drive an indicator.
				 This function is reset by depressing
				 the shift key.

Clock                3           A TTL compatible clock signal is
				 applied to this pin. A bit time is
				 defined as the time from one
				 negative going transition to the
				 succeeding negative going transition
				 of the clock.

Vss                  32          +5.0V supply

Vll                  2           Ground

Vgg                  18          -12V supply


**********************************************************************/

#pragma once

#ifndef __MM5740__
#define __MM5740__

#include "emu.h"



//**************************************************************************
//  INTERFACE CONFIGURATION MACROS
//**************************************************************************

#define MCFG_MM5740_MATRIX_X1(_cb)       devcb = &mm5740_device::set_x1_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X2(_cb)       devcb = &mm5740_device::set_x2_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X3(_cb)       devcb = &mm5740_device::set_x3_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X4(_cb)       devcb = &mm5740_device::set_x4_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X5(_cb)       devcb = &mm5740_device::set_x5_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X6(_cb)       devcb = &mm5740_device::set_x6_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X7(_cb)       devcb = &mm5740_device::set_x7_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X8(_cb)       devcb = &mm5740_device::set_x8_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_MATRIX_X9(_cb)       devcb = &mm5740_device::set_x9_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_SHIFT_CB(_cb)        devcb = &mm5740_device::set_shift_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_CONTROL_CB(_cb)      devcb = &mm5740_device::set_control_cb(*device, DEVCB_##_cb);
#define MCFG_MM5740_DATA_READY_CB(_cb)   devcb = &mm5740_device::set_data_ready_cb(*device, DEVCB_##_cb);

//**************************************************************************
//  TYPE DEFINITIONS
//**************************************************************************

// ======================> mm5740_device

class mm5740_device :   public device_t
{
public:
	// construction/destruction
	mm5740_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock);

	// public interface
	uint16_t b_r();

	template<class _Object> static devcb_base &set_x1_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x1.set_callback(rd); }
	template<class _Object> static devcb_base &set_x2_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x2.set_callback(rd); }
	template<class _Object> static devcb_base &set_x3_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x3.set_callback(rd); }
	template<class _Object> static devcb_base &set_x4_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x4.set_callback(rd); }
	template<class _Object> static devcb_base &set_x5_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x5.set_callback(rd); }
	template<class _Object> static devcb_base &set_x6_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x6.set_callback(rd); }
	template<class _Object> static devcb_base &set_x7_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x7.set_callback(rd); }
	template<class _Object> static devcb_base &set_x8_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x8.set_callback(rd); }
	template<class _Object> static devcb_base &set_x9_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_x9.set_callback(rd); }
	template<class _Object> static devcb_base &set_shift_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_shift.set_callback(rd); }
	template<class _Object> static devcb_base &set_control_cb(device_t &device, _Object rd) { return downcast<mm5740_device &>(device).m_read_control.set_callback(rd); }
	template<class _Object> static devcb_base &set_data_ready_cb(device_t &device, _Object wr) { return downcast<mm5740_device &>(device).m_write_data_ready.set_callback(wr); }

	devcb_read16 m_read_x1, m_read_x2, m_read_x3, m_read_x4, m_read_x5, m_read_x6, m_read_x7, m_read_x8, m_read_x9;
	devcb_read_line m_read_shift, m_read_control;
	devcb_write_line m_write_data_ready;

protected:
	// device-level overrides
	virtual void device_start() override;
	virtual void device_reset() override;
	virtual void device_timer(emu_timer &timer, device_timer_id id, int param, void *ptr) override;

private:
	static const int MAX_KEYS_DOWN = 4;

	int m_b;                    // output buffer
	int m_ako;                  // any key down

	int m_x_mask[9];            // mask of what keys are down

	// timers
	emu_timer *m_scan_timer;    // keyboard scan timer
};


// device type definition
extern const device_type MM5740;



#endif

