// Instruction handlers for the m68000 (indirect, partial, mcu)
//
// Generated by m68000gen.py sipm m68000.lst m68000-sipm.cpp

#include "m68000.h"

void m68000_device::state_reset_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 002 rstp3
	m_icount -= 2;
	// 296 rstp4
	m_ird = m_ir;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 27e rstp5
	m_ftu = 0x0000;
	m_icount -= 2;
	// 27f rstp6
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_sr |= 0x0700;
	update_interrupt();
	m_au = ext32(m_ftu);
	m_icount -= 2;
	// 2fb rstp7
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_da[16], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2ff rstp8
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_da[16], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 300 rstp9
	m_aob = m_au;
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[16], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 11e rstpa
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_bus_error_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 003 bser1
	m_ssw = m_base_ssw | (m_sr & SR_S ? SSW_S : 0);
	m_at = m_aob;
	m_ftu = m_sr;
	m_au = m_pc;
	m_icount -= 2;
	// 3a7 bser2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3ca bser3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 0a2 bser4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_ftu = m_ird;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 3c6 bser5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 088 bser6
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_ftu = (m_ftu & ~0x1f) | m_ssw;
	m_au = m_au - 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0008;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_address_error_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 003 bser1
	m_ssw = m_base_ssw | (m_sr & SR_S ? SSW_S : 0);
	m_at = m_aob;
	m_ftu = m_sr;
	m_au = m_pc;
	m_icount -= 2;
	// 3a7 bser2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3ca bser3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 0a2 bser4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_ftu = m_ird;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 3c6 bser5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 088 bser6
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_ftu = (m_ftu & ~0x1f) | m_ssw;
	m_au = m_au - 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x000c;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N | SSW_CRITICAL;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N | SSW_CRITICAL;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_double_fault_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 001 halt1
	m_icount = m_bcount;
	}
}

void m68000_device::state_interrupt_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c4 itlx1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 234 itlx2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_alub = m_ftu;
	m_pc = m_au;
	m_sr = (m_sr & ~SR_I) | ((m_next_state >> 16) & SR_I);
	update_interrupt();
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_icount -= 2;
	// 235 itlx3
	m_ftu = 0xfff0 | ((m_next_state >> 23) & 0xe);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 0eb itlx4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 236 itlx5
	m_aob = m_at;
	m_base_ssw = SSW_CPU | SSW_R | SSW_N;
	start_interrupt_vector_lookup();
	m_edb = m_mmu->read_cpu(m_aob, 0xffff);
	end_interrupt_vector_lookup();
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	// 118 itlx6
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_icount -= 2;
	// 292 itlx7
	m_ird = m_ir;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[16] = m_au;
	m_ftu = m_int_vector;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_trace_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c0 trac1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 3a3 trac2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x0024;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_illegal_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c0 trac1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 3a3 trac2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x0010;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_priviledge_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c0 trac1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 3a3 trac2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x0020;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_linea_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c0 trac1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 3a3 trac2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x0028;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::state_linef_ipm()
{
	switch(m_inst_substate) {
	case 0:
	// 1c0 trac1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 3a3 trac2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	if(m_next_state == S_TRACE)
		m_next_state = 0;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x002c;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA | SSW_N;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R | SSW_N;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R | SSW_N;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_ds_ipm() // 0000 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_or8(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_ais_ipm() // 0010 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_aips_ipm() // 0018 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_pais_ipm() // 0020 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_das_ipm() // 0028 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_dais_ipm() // 0030 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_adr16_ipm() // 0038 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_b_imm8_adr32_ipm() // 0039 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_imm8_ccr_ipm() // 003c ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_or8(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_ds_ipm() // 0040 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_or(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_ais_ipm() // 0050 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_aips_ipm() // 0058 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_pais_ipm() // 0060 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_das_ipm() // 0068 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_dais_ipm() // 0070 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_adr16_ipm() // 0078 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_w_imm16_adr32_ipm() // 0079 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_i16u_sr_ipm() // 007c ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=14 c=2 m=.....  i=....... ALU.or_ a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_or(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_ds_ipm() // 0080 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_or(m_dt, m_da[ry]);
	sr_nzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	// 25a roal3
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=18:m_da[ry]
	alu_or(high16(m_dt), high16(m_da[ry]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_ais_ipm() // 0090 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_aips_ipm() // 0098 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_pais_ipm() // 00a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_das_ipm() // 00a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_dais_ipm() // 00b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e7 aixw0
	// alu r=14 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_adr16_ipm() // 00b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ori_l_imm32_adr32_ipm() // 00b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=R.alue:m_alue
	alu_or(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_ds_ipm() // 0100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e7 btsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_eor(m_da[rx], m_da[ry]);
	// 0e7 btsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	if(m_t)
		goto btsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
btsr3:
	// 044 btsr3
	m_ird = m_ir;
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_and(high16(m_da[ry]), 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movep_w_das_dd_ipm() // 0108 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d2 mpiw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 29a mpiw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	set_8(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 368 mpiw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 4;
	set_8h(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 36a mpiw4
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_ais_ipm() // 0110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_aips_ipm() // 0118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_pais_ipm() // 0120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_das_ipm() // 0128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_dais_ipm() // 0130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_adr16_ipm() // 0138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_adr32_ipm() // 0139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_dpc_ipm() // 013a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_dpci_ipm() // 013b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_dd_imm_ipm() // 013c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 0ab btsi1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16h(m_dt, high16(m_at));
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 0e7 btsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dt;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	if(m_t)
		goto btsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_dt, m_aluo);
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
btsr3:
	// 044 btsr3
	m_ird = m_ir;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=23:m_dt d=R.dcro:m_dcro
	alu_and8(high16(m_dt), 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_ds_ipm() // 0140 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3ef bcsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_eor(m_da[rx], m_da[ry]);
	// 06a bcsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=2 m=.....  i=....... ALU.eor a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_eor(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bcsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bcsr3:
	// 084 bcsr3
	m_alub = high16(m_da[ry]);
	// alu r=13 c=2 m=.....  i=....... ALU.eor a=18:m_da[ry] d=R.dcro:m_dcro
	alu_eor(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movep_l_das_dd_ipm() // 0148 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d6 mpil1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 29e mpil2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	set_8(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 34e mpil3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	set_8h(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 34f mpil4
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_dbin);
	m_au = m_au + 2;
	set_8(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 368 mpiw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 4;
	set_8h(m_dbin, m_edb);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 36a mpiw4
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_ais_ipm() // 0150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_aips_ipm() // 0158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_pais_ipm() // 0160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_das_ipm() // 0168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_dais_ipm() // 0170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_adr16_ipm() // 0178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_dd_adr32_ipm() // 0179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_ds_ipm() // 0180 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3eb bclr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_or(m_da[rx], m_da[ry]);
	// 06e bclr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=2 m=.....  i=.l..... ALU.or_ a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_or(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bclr3;
	else
		goto bclr4;
bclr4:
	// 0cc bclr4
	// alu r=14 c=4 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor(m_aluo, 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.l...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bclr3:
	// 08c bclr3
	m_alub = high16(m_da[ry]);
	// alu r=14 c=2 m=.....  i=.l..... ALU.or_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_or(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0c8 bclr5
	// alu r=14 c=4 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor(m_aluo, 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.l...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movep_w_dd_das_ipm() // 0188 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ca mpow1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 36d mpow2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xh(m_dbout, m_da[rx]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dxl:m_da[rx]
	// 36e mpow3
	m_aob = m_au;
	set_8xl(m_dbout, m_da[rx]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 4;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_ais_ipm() // 0190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_aips_ipm() // 0198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_pais_ipm() // 01a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_das_ipm() // 01a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_dais_ipm() // 01b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_adr16_ipm() // 01b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_dd_adr32_ipm() // 01b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_ds_ipm() // 01c0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3ef bcsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_or(m_da[rx], m_da[ry]);
	// 06a bcsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=2 m=.....  i=....... ALU.or_ a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_or(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bcsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bcsr3:
	// 084 bcsr3
	m_alub = high16(m_da[ry]);
	// alu r=14 c=2 m=.....  i=....... ALU.or_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_or(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movep_l_dd_das_ipm() // 01c8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ce mpol1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 36b mpol2
	m_aob = m_au;
	set_8xh(m_dbout, high16(m_da[rx]));
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=16:m_da[rx] d=none
	// 36c mpol3
	m_aob = m_au;
	set_8xl(m_dbout, high16(m_da[rx]));
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=16:m_da[rx] d=none
	// 36d mpow2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xh(m_dbout, m_da[rx]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dxl:m_da[rx]
	// 36e mpow3
	m_aob = m_au;
	set_8xl(m_dbout, m_da[rx]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 4;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_ais_ipm() // 01d0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_aips_ipm() // 01d8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_pais_ipm() // 01e0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_das_ipm() // 01e8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_dais_ipm() // 01f0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_adr16_ipm() // 01f8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_dd_adr32_ipm() // 01f9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_ds_ipm() // 0200 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_and8(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_ais_ipm() // 0210 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_aips_ipm() // 0218 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_pais_ipm() // 0220 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_das_ipm() // 0228 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_dais_ipm() // 0230 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_adr16_ipm() // 0238 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_b_imm8_adr32_ipm() // 0239 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_imm8_ccr_ipm() // 023c ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=4 c=2 m=.....  i=b...... ALU.and_ a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_and8(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_ds_ipm() // 0240 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_and(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_ais_ipm() // 0250 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_aips_ipm() // 0258 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_pais_ipm() // 0260 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_das_ipm() // 0268 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_dais_ipm() // 0270 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_adr16_ipm() // 0278 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_w_imm16_adr32_ipm() // 0279 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_i16u_sr_ipm() // 027c ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=4 c=2 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_and(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_ds_ipm() // 0280 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_and(m_dt, m_da[ry]);
	sr_nzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	// 25a roal3
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=18:m_da[ry]
	alu_and(high16(m_dt), high16(m_da[ry]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_ais_ipm() // 0290 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_aips_ipm() // 0298 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_pais_ipm() // 02a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_das_ipm() // 02a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_dais_ipm() // 02b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e7 aixw0
	// alu r=4 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_adr16_ipm() // 02b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::andi_l_imm32_adr32_ipm() // 02b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_and(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=R.alue:m_alue
	alu_and(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_ds_ipm() // 0400 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub8(m_dt, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_ais_ipm() // 0410 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_aips_ipm() // 0418 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_pais_ipm() // 0420 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_das_ipm() // 0428 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_dais_ipm() // 0430 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_adr16_ipm() // 0438 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_b_imm8_adr32_ipm() // 0439 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_ds_ipm() // 0440 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub(m_dt, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_ais_ipm() // 0450 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_aips_ipm() // 0458 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_pais_ipm() // 0460 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_das_ipm() // 0468 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_dais_ipm() // 0470 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_adr16_ipm() // 0478 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_w_imm16_adr32_ipm() // 0479 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_ds_ipm() // 0480 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub(m_dt, m_da[ry]);
	sr_xnzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=18:m_da[ry]
	alu_subc(high16(m_dt), high16(m_da[ry]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_ais_ipm() // 0490 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_aips_ipm() // 0498 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_pais_ipm() // 04a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_das_ipm() // 04a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_dais_ipm() // 04b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_adr16_ipm() // 04b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subi_l_imm32_adr32_ipm() // 04b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_ds_ipm() // 0600 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_add8(m_dt, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_ais_ipm() // 0610 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_aips_ipm() // 0618 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_pais_ipm() // 0620 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_das_ipm() // 0628 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_dais_ipm() // 0630 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_adr16_ipm() // 0638 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_b_imm8_adr32_ipm() // 0639 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add8(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_ds_ipm() // 0640 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_add(m_dt, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_ais_ipm() // 0650 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_aips_ipm() // 0658 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_pais_ipm() // 0660 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_das_ipm() // 0668 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_dais_ipm() // 0670 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_adr16_ipm() // 0678 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_w_imm16_adr32_ipm() // 0679 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_ds_ipm() // 0680 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_add(m_dt, m_da[ry]);
	sr_xnzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=18:m_da[ry]
	alu_addc(high16(m_dt), high16(m_da[ry]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_ais_ipm() // 0690 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_aips_ipm() // 0698 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_pais_ipm() // 06a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_das_ipm() // 06a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_dais_ipm() // 06b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_adr16_ipm() // 06b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addi_l_imm32_adr32_ipm() // 06b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_add(m_dt, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_ds_ipm() // 0800 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 3e7 btsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = m_dt;
	m_au = m_da[ry];
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_eor(m_dt, m_da[ry]);
	// 0e7 btsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	if(m_t)
		goto btsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
btsr3:
	// 044 btsr3
	m_ird = m_ir;
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_and(high16(m_da[ry]), 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_ais_ipm() // 0810 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_aips_ipm() // 0818 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_pais_ipm() // 0820 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_das_ipm() // 0828 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_dais_ipm() // 0830 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_adr16_ipm() // 0838 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_adr32_ipm() // 0839 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_dpc_ipm() // 083a ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::btst_imm8_dpci_ipm() // 083b ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 215 btsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_and8(m_dbin, 1 << (m_dcr & 15));
	sr_z();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_ds_ipm() // 0840 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 3ef bcsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = m_dt;
	m_au = m_da[ry];
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_eor(m_dt, m_da[ry]);
	// 06a bcsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=2 m=.....  i=....... ALU.eor a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_eor(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bcsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bcsr3:
	// 084 bcsr3
	m_alub = high16(m_da[ry]);
	// alu r=13 c=2 m=.....  i=....... ALU.eor a=18:m_da[ry] d=R.dcro:m_dcro
	alu_eor(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=13 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_ais_ipm() // 0850 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_aips_ipm() // 0858 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_pais_ipm() // 0860 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_das_ipm() // 0868 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_dais_ipm() // 0870 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_adr16_ipm() // 0878 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bchg_imm8_adr32_ipm() // 0879 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_eor8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	// alu r=13 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_ds_ipm() // 0880 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 3eb bclr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = m_dt;
	m_au = m_da[ry];
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_or(m_dt, m_da[ry]);
	// 06e bclr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=2 m=.....  i=.l..... ALU.or_ a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_or(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bclr3;
	else
		goto bclr4;
bclr4:
	// 0cc bclr4
	// alu r=14 c=4 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor(m_aluo, 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.l...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bclr3:
	// 08c bclr3
	m_alub = high16(m_da[ry]);
	// alu r=14 c=2 m=.....  i=.l..... ALU.or_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_or(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0c8 bclr5
	// alu r=14 c=4 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor(m_aluo, 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.l...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_ais_ipm() // 0890 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_aips_ipm() // 0898 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_pais_ipm() // 08a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_das_ipm() // 08a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_dais_ipm() // 08b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=none
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_adr16_ipm() // 08b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bclr_imm8_adr32_ipm() // 08b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=bl..... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 069 bclm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_dbin;
	m_ftu = m_sr;
	// alu r=14 c=2 m=.....  i=bl..... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	// 067 bclm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=4 m=.....  i=bl..... ALU.eor a=R.aluo:m_aluo d=R.dcro:m_dcro
	alu_eor8(m_aluo, 1 << (m_dcr & 15));
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	// alu r=14 c=1 m=..z..  i=bl...i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_ds_ipm() // 08c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 3ef bcsr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = m_dt;
	m_au = m_da[ry];
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_or(m_dt, m_da[ry]);
	// 06a bcsr2
	m_t = m_dcr & 0x10;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_da[ry];
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=2 m=.....  i=....... ALU.or_ a=R.dyl:m_da[ry] d=R.dcro:m_dcro
	alu_or(m_da[ry], 1 << (m_dcr & 15));
	if(m_t)
		goto bcsr3;
	else
		goto bcsr4;
bcsr4:
	// 0c4 bcsr4
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
bcsr3:
	// 084 bcsr3
	m_alub = high16(m_da[ry]);
	// alu r=14 c=2 m=.....  i=....... ALU.or_ a=18:m_da[ry] d=R.dcro:m_dcro
	alu_or(high16(m_da[ry]), 1 << (m_dcr & 15));
	m_icount -= 2;
	// 0a1 bcsr5
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	// alu r=14 c=1 m=..z..  i=.....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_ais_ipm() // 08d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_aips_ipm() // 08d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_pais_ipm() // 08e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_das_ipm() // 08e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_dais_ipm() // 08f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_adr16_ipm() // 08f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bset_imm8_adr32_ipm() // 08f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 081 bcsm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=14 c=2 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=R.dcro:m_dcro
	alu_or8(m_dbin, 1 << (m_dcr & 15));
	m_dbin = m_edb;
	// 082 bcsm2
	m_aob = m_at;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	// alu r=14 c=1 m=..z..  i=b....i. ALU.and_ a=alub d=R.dcro:m_dcro
	alu_and8(m_alub, 1 << (m_dcr & 15));
	sr_z();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_ds_ipm() // 0a00 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_eor8(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_ais_ipm() // 0a10 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_aips_ipm() // 0a18 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_pais_ipm() // 0a20 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_das_ipm() // 0a28 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_dais_ipm() // 0a30 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_adr16_ipm() // 0a38 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_b_imm8_adr32_ipm() // 0a39 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor8(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_imm8_ccr_ipm() // 0a3c ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=13 c=2 m=.....  i=b...... ALU.eor a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_eor8(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_ds_ipm() // 0a40 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_eor(m_dt, m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_ais_ipm() // 0a50 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_aips_ipm() // 0a58 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_pais_ipm() // 0a60 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_das_ipm() // 0a68 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_dais_ipm() // 0a70 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_adr16_ipm() // 0a78 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_w_imm16_adr32_ipm() // 0a79 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_i16u_sr_ipm() // 0a7c ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 1cc stiw1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	m_icount -= 2;
	// 307 stiw2
	// alu r=13 c=2 m=.....  i=....... ALU.eor a=R.ftu:m_ftu d=R.dtl:m_dt
	alu_eor(m_ftu, m_dt);
	m_icount -= 2;
	// 320 stiw3
	m_movemr = m_dbin;
	m_ftu = m_aluo;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.aluo:m_aluo d=none
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_ds_ipm() // 0a80 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_eor(m_dt, m_da[ry]);
	sr_nzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	// 25a roal3
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=18:m_da[ry]
	alu_eor(high16(m_dt), high16(m_da[ry]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_ais_ipm() // 0a90 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_aips_ipm() // 0a98 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_pais_ipm() // 0aa0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_das_ipm() // 0aa8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_dais_ipm() // 0ab0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 1e7 aixw0
	// alu r=13 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_adr16_ipm() // 0ab8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eori_l_imm32_adr32_ipm() // 0ab9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_eor(m_dt, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=23:m_dt d=R.alue:m_alue
	alu_eor(high16(m_dt), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_ds_ipm() // 0c00 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 108 rcaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub8(m_dt, m_da[ry]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_ais_ipm() // 0c10 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_aips_ipm() // 0c18 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_pais_ipm() // 0c20 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_das_ipm() // 0c28 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_dais_ipm() // 0c30 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_adr16_ipm() // 0c38 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_b_imm8_adr32_ipm() // 0c39 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub8(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_ds_ipm() // 0c40 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 108 rcaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub(m_dt, m_da[ry]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_ais_ipm() // 0c50 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_aips_ipm() // 0c58 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_pais_ipm() // 0c60 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_das_ipm() // 0c68 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_dais_ipm() // 0c70 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_adr16_ipm() // 0c78 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_w_imm16_adr32_ipm() // 0c79 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 087 cpdw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_ds_ipm() // 0c80 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	if(!m_cmpild_instr_callback.isnull()) (m_cmpild_instr_callback)(ry, (m_dt & 0xffff0000) | m_dbin);
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 104 rcal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dyl:m_da[ry]
	alu_sub(m_dt, m_da[ry]);
	sr_nzvc();
	// 239 rcal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=18:m_da[ry]
	alu_subc(high16(m_dt), high16(m_da[ry]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_ais_ipm() // 0c90 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_aips_ipm() // 0c98 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_pais_ipm() // 0ca0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_das_ipm() // 0ca8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_dais_ipm() // 0cb0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e7 aixw0
	// alu r=6 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_adr16_ipm() // 0cb8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpi_l_imm32_adr32_ipm() // 0cb9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 3e0 o#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b9 o#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 08f cpdl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_sub(m_dt, m_dbin);
	sr_nzvc();
	// 171 cpdl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_dd_ipm() // 1000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 121 rrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_dd_ipm() // 1010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_dd_ipm() // 1018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_dd_ipm() // 1020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_dd_ipm() // 1028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_dd_ipm() // 1030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_dd_ipm() // 1038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_dd_ipm() // 1039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_dd_ipm() // 103a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_dd_ipm() // 103b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_8(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_dd_ipm() // 103c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 121 rrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_aid_ipm() // 1080 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fa rmrw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_aid_ipm() // 1090 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_aid_ipm() // 1098 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_aid_ipm() // 10a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_aid_ipm() // 10a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_aid_ipm() // 10b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_aid_ipm() // 10b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_aid_ipm() // 10b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_aid_ipm() // 10ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_aid_ipm() // 10bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_aid_ipm() // 10bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fa rmrw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_aipd_ipm() // 10c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fe rmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_aipd_ipm() // 10d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_aipd_ipm() // 10d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_aipd_ipm() // 10e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_aipd_ipm() // 10e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_aipd_ipm() // 10f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_aipd_ipm() // 10f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_aipd_ipm() // 10f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_aipd_ipm() // 10fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_aipd_ipm() // 10fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dbin);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_aipd_ipm() // 10fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fe rmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_paid_ipm() // 1100 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2f8 rmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_paid_ipm() // 1110 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_paid_ipm() // 1118 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_paid_ipm() // 1120 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_paid_ipm() // 1128 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_paid_ipm() // 1130 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_paid_ipm() // 1138 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_paid_ipm() // 1139 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_paid_ipm() // 113a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_paid_ipm() // 113b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_paid_ipm() // 113c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f8 rmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_dad_ipm() // 1140 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2da rmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_dad_ipm() // 1150 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_dad_ipm() // 1158 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_dad_ipm() // 1160 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_dad_ipm() // 1168 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_dad_ipm() // 1170 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_dad_ipm() // 1178 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_dad_ipm() // 1179 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_dad_ipm() // 117a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_dad_ipm() // 117b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_dad_ipm() // 117c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2da rmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_daid_ipm() // 1180 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1eb rmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 109 rmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxw3;
	else
		goto rmxw2;
rmxw2:
	// 128 rmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmxw3:
	// 1e8 rmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmdw2:
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_daid_ipm() // 1190 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_daid_ipm() // 1198 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_daid_ipm() // 11a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_daid_ipm() // 11a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_daid_ipm() // 11b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_daid_ipm() // 11b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_daid_ipm() // 11b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_daid_ipm() // 11ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_daid_ipm() // 11bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=bl..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_daid_ipm() // 11bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1eb rmxw0
	// alu r=2 c=5 m=.....  i=bl..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 109 rmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxw3;
	else
		goto rmxw2;
rmxw2:
	// 128 rmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmxw3:
	// 1e8 rmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmdw2:
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=bl...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_adr16_ipm() // 11c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d9 raww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_adr16_ipm() // 11d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_adr16_ipm() // 11d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_adr16_ipm() // 11e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_adr16_ipm() // 11e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_adr16_ipm() // 11f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_adr16_ipm() // 11f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_adr16_ipm() // 11f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_adr16_ipm() // 11fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_adr16_ipm() // 11fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_adr16_ipm() // 11fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2d9 raww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ds_adr32_ipm() // 13c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1ea ralw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bb ralw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_ais_adr32_ipm() // 13d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_aips_adr32_ipm() // 13d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_pais_adr32_ipm() // 13e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_das_adr32_ipm() // 13e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dais_adr32_ipm() // 13f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr16_adr32_ipm() // 13f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_adr32_adr32_ipm() // 13f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpc_adr32_ipm() // 13fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_dpci_adr32_ipm() // 13fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_b_imm8_adr32_ipm() // 13fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1ea ralw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bb ralw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and8(m_dt, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_dd_ipm() // 2000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	m_da[rx] = m_at;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_dd_ipm() // 2008 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_dd_ipm() // 2010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_dd_ipm() // 2018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_dd_ipm() // 2020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_dd_ipm() // 2028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_dd_ipm() // 2030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_dd_ipm() // 2038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_dd_ipm() // 2039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_dd_ipm() // 203a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_dd_ipm() // 203b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_dd_ipm() // 203c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_ds_ad_ipm() // 2040 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_as_ad_ipm() // 2048 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	m_da[rx] = m_at;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_ais_ad_ipm() // 2050 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_aips_ad_ipm() // 2058 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_pais_ad_ipm() // 2060 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_das_ad_ipm() // 2068 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_dais_ad_ipm() // 2070 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_adr16_ad_ipm() // 2078 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_adr32_ad_ipm() // 2079 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_dpc_ad_ipm() // 207a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_dpci_ad_ipm() // 207b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29f mrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 36f mrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_l_imm32_ad_ipm() // 207c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 129 rrgl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_aid_ipm() // 2080 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2f9 rmrl1
	m_aob = m_da[rx];
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = high16(m_da[ry]);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23f rmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_aid_ipm() // 2088 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2f9 rmrl1
	m_aob = m_da[rx];
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = high16(m_da[ry]);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23f rmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_aid_ipm() // 2090 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_aid_ipm() // 2098 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_aid_ipm() // 20a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_aid_ipm() // 20a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_aid_ipm() // 20b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_aid_ipm() // 20b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_aid_ipm() // 20b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_aid_ipm() // 20ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_aid_ipm() // 20bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3a9 mmrl1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3aa mmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_aid_ipm() // 20bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f9 rmrl1
	m_aob = m_da[rx];
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = high16(m_dt);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23f rmrl2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_aipd_ipm() // 20c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fd rmil1
	m_aob = m_da[rx];
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = high16(m_da[ry]);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23c rmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 23d rmil3
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_aipd_ipm() // 20c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2fd rmil1
	m_aob = m_da[rx];
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = high16(m_da[ry]);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23c rmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 23d rmil3
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_aipd_ipm() // 20d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_aipd_ipm() // 20d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_aipd_ipm() // 20e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_aipd_ipm() // 20e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_aipd_ipm() // 20f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_aipd_ipm() // 20f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_aipd_ipm() // 20f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_aipd_ipm() // 20fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_aipd_ipm() // 20fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 3ad mmil1
	m_aob = m_da[rx];
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 3ae mmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_aipd_ipm() // 20fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fd rmil1
	m_aob = m_da[rx];
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = high16(m_dt);
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// 23c rmil2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 23d rmil3
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_paid_ipm() // 2100 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fc rmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 23e rmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_paid_ipm() // 2108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2fc rmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 23e rmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_paid_ipm() // 2110 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_paid_ipm() // 2118 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_paid_ipm() // 2120 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_paid_ipm() // 2128 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_paid_ipm() // 2130 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_paid_ipm() // 2138 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_paid_ipm() // 2139 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_paid_ipm() // 213a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_paid_ipm() // 213b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38f mmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34a mmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_paid_ipm() // 213c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fc rmml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 23e rmml2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_dad_ipm() // 2140 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2de rmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_dad_ipm() // 2148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2de rmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_dad_ipm() // 2150 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_dad_ipm() // 2158 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_dad_ipm() // 2160 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_dad_ipm() // 2168 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_dad_ipm() // 2170 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_dad_ipm() // 2178 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_dad_ipm() // 2179 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_dad_ipm() // 217a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_dad_ipm() // 217b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38e mmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_dad_ipm() // 217c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2de rmdl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = high16(m_dt);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_daid_ipm() // 2180 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1ef rmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 105 rmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxl3;
	else
		goto rmxl2;
rmxl2:
	// 12c rmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmxl3:
	// 1ec rmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmdl2:
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_daid_ipm() // 2188 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ef rmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 105 rmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxl3;
	else
		goto rmxl2;
rmxl2:
	// 12c rmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmxl3:
	// 1ec rmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmdl2:
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_daid_ipm() // 2190 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_daid_ipm() // 2198 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_daid_ipm() // 21a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_daid_ipm() // 21a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_daid_ipm() // 21b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_daid_ipm() // 21b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_daid_ipm() // 21b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_daid_ipm() // 21ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_daid_ipm() // 21bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29c mmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 10d mmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxl3;
	else
		goto mmxl2;
mmxl2:
	// 02c mmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mmxl3:
	// 0ec mmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto mawl2;
mawl2:
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_daid_ipm() // 21bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1ef rmxl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 105 rmxl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxl3;
	else
		goto rmxl2;
rmxl2:
	// 12c rmxl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmxl3:
	// 1ec rmxl3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdl2;
rmdl2:
	// 2be rmdl2
	m_aob = m_au;
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = high16(m_dt);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	// 2df rmdl3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 258 rmrl3
	m_aob = m_au;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_adr16_ipm() // 21c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2dd rawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_adr16_ipm() // 21c8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2dd rawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_adr16_ipm() // 21d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_adr16_ipm() // 21d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_adr16_ipm() // 21e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_adr16_ipm() // 21e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_adr16_ipm() // 21f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_adr16_ipm() // 21f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_adr16_ipm() // 21f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_adr16_ipm() // 21fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_adr16_ipm() // 21fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 38c mawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 32f mawl2
	m_aob = m_au;
	m_dbout = m_alue;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_at, m_aluo);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_adr16_ipm() // 21fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2dd rawl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = high16(m_dt);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ds_adr32_ipm() // 23c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1ee rall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bf rall2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_as_adr32_ipm() // 23c8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ee rall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bf rall2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_da[ry]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = high16(m_da[ry]);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_ais_adr32_ipm() // 23d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_aips_adr32_ipm() // 23d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_pais_adr32_ipm() // 23e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_das_adr32_ipm() // 23e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dais_adr32_ipm() // 23f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr16_adr32_ipm() // 23f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_adr32_adr32_ipm() // 23f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpc_adr32_ipm() // 23fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_dpci_adr32_ipm() // 23fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 30f mall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	set_16h(m_at, m_aluo);
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 329 mall2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	// 32a mall3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_l_imm32_adr32_ipm() // 23fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1ee rall1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bf rall2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 2ba rall3
	m_aob = m_au;
	m_dbout = high16(m_dt);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_alub = high16(m_dt);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nz..  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	sr_nz_u();
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_dd_ipm() // 3000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 121 rrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_dd_ipm() // 3008 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 121 rrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_dd_ipm() // 3010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_dd_ipm() // 3018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_dd_ipm() // 3020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_dd_ipm() // 3028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_dd_ipm() // 3030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_dd_ipm() // 3038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_dd_ipm() // 3039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_dd_ipm() // 303a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_dd_ipm() // 303b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 29b mrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_dd_ipm() // 303c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 121 rrgw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_ds_ad_ipm() // 3040 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 279 rrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	m_au = m_au + 2;
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_as_ad_ipm() // 3048 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 279 rrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	m_au = m_au + 2;
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=17:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	m_da[rx] = m_at;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_ais_ad_ipm() // 3050 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_aips_ad_ipm() // 3058 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_pais_ad_ipm() // 3060 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_das_ad_ipm() // 3068 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_dais_ad_ipm() // 3070 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_adr16_ad_ipm() // 3078 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_adr32_ad_ipm() // 3079 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_dpc_ad_ipm() // 307a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_dpci_ad_ipm() // 307b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 158 mrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_dbin);
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movea_w_imm16_ad_ipm() // 307c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 279 rrgm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	m_au = m_au + 2;
	// 278 rrgl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=......f ALU.and_ a=23:m_dt d=-1
	alu_and(high16(m_dt), 0xffff);
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_aid_ipm() // 3080 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fa rmrw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_aid_ipm() // 3088 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2fa rmrw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_aid_ipm() // 3090 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_aid_ipm() // 3098 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_aid_ipm() // 30a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_aid_ipm() // 30a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_aid_ipm() // 30b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_aid_ipm() // 30b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_aid_ipm() // 30b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_aid_ipm() // 30ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_aid_ipm() // 30bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3ab mmrw1
	m_aob = m_da[rx];
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_aid_ipm() // 30bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fa rmrw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_aipd_ipm() // 30c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2fe rmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_aipd_ipm() // 30c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2fe rmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_aipd_ipm() // 30d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_aipd_ipm() // 30d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_aipd_ipm() // 30e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_aipd_ipm() // 30e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_aipd_ipm() // 30f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_aipd_ipm() // 30f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_aipd_ipm() // 30f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_aipd_ipm() // 30fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_aipd_ipm() // 30fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 3af mmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dbin;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_aipd_ipm() // 30fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2fe rmiw1
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_au = m_da[rx] + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_paid_ipm() // 3100 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2f8 rmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_paid_ipm() // 3108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2f8 rmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_paid_ipm() // 3110 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_paid_ipm() // 3118 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_paid_ipm() // 3120 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_paid_ipm() // 3128 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_paid_ipm() // 3130 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_paid_ipm() // 3138 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_paid_ipm() // 3139 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_paid_ipm() // 313a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_paid_ipm() // 313b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38b mmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_paid_ipm() // 313c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f8 rmmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 34b mmmw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_dad_ipm() // 3140 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2da rmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_dad_ipm() // 3148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2da rmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_dad_ipm() // 3150 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_dad_ipm() // 3158 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_dad_ipm() // 3160 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_dad_ipm() // 3168 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_dad_ipm() // 3170 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_dad_ipm() // 3178 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_dad_ipm() // 3179 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_dad_ipm() // 317a f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_dad_ipm() // 317b f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 38a mmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo) + m_da[rx];
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_dad_ipm() // 317c f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2da rmdw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[rx];
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_daid_ipm() // 3180 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1eb rmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 109 rmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxw3;
	else
		goto rmxw2;
rmxw2:
	// 128 rmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmxw3:
	// 1e8 rmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmdw2:
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_daid_ipm() // 3188 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1eb rmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 109 rmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxw3;
	else
		goto rmxw2;
rmxw2:
	// 128 rmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmxw3:
	// 1e8 rmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmdw2:
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_da[ry];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_daid_ipm() // 3190 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_daid_ipm() // 3198 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_daid_ipm() // 31a0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_daid_ipm() // 31a8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_daid_ipm() // 31b0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_daid_ipm() // 31b8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_daid_ipm() // 31b9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_daid_ipm() // 31ba f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_daid_ipm() // 31bb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 298 mmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.aluo:m_aluo d=0
	alu_ext(m_aluo);
	m_icount -= 2;
	// 101 mmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto mmxw3;
	else
		goto mmxw2;
mmxw2:
	// 028 mmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
mmxw3:
	// 0e8 mmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	goto maww2;
maww2:
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_daid_ipm() // 31bc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1eb rmxw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 109 rmxw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_pc = m_au;
	m_au = m_da[rx] + ext32(m_aluo);
	if(m_t)
		goto rmxw3;
	else
		goto rmxw2;
rmxw2:
	// 128 rmxw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmxw3:
	// 1e8 rmxw3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto rmdw2;
rmdw2:
	// 2db rmdw2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_dt;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_adr16_ipm() // 31c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d9 raww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_adr16_ipm() // 31c8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2d9 raww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_adr16_ipm() // 31d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_adr16_ipm() // 31d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_adr16_ipm() // 31e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_adr16_ipm() // 31e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_adr16_ipm() // 31f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_adr16_ipm() // 31f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_adr16_ipm() // 31f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_adr16_ipm() // 31fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_adr16_ipm() // 31fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 388 maww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = ext32(m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_adr16_ipm() // 31fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2d9 raww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ds_adr32_ipm() // 33c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1ea ralw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bb ralw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_as_adr32_ipm() // 33c8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ea ralw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bb ralw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_da[ry]);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_ais_adr32_ipm() // 33d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_aips_adr32_ipm() // 33d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_pais_adr32_ipm() // 33e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_das_adr32_ipm() // 33e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dais_adr32_ipm() // 33f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr16_adr32_ipm() // 33f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_adr32_adr32_ipm() // 33f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpc_adr32_ipm() // 33fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_dpci_adr32_ipm() // 33fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 32b malw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_aluo);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_dbin = m_edb;
	// 32e malw2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_w_imm16_adr32_ipm() // 33fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1ea ralw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bb ralw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16l(m_at, m_dt);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	// 389 maww2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_ds_ipm() // 4000 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dyl:m_da[ry] d=0
	alu_subx8(m_da[ry], 0x0000);
	sr_xnzvc_u();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_ais_ipm() // 4010 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_aips_ipm() // 4018 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_pais_ipm() // 4020 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_das_ipm() // 4028 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_dais_ipm() // 4030 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=10 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_adr16_ipm() // 4038 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_b_adr32_ipm() // 4039 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx8(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_ds_ipm() // 4040 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dyl:m_da[ry] d=0
	alu_subx(m_da[ry], 0x0000);
	sr_xnzvc_u();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_ais_ipm() // 4050 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_aips_ipm() // 4058 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_pais_ipm() // 4060 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_das_ipm() // 4068 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_dais_ipm() // 4070 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=10 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_adr16_ipm() // 4078 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_w_adr32_ipm() // 4079 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_ds_ipm() // 4080 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 137 nnrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dyl:m_da[ry] d=0
	alu_subx(m_da[ry], 0x0000);
	sr_xnzvc_u();
	// 15e nnrl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=18:m_da[ry] d=0
	alu_subc(high16(m_da[ry]), 0x0000);
	sr_xnzvc_u();
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_ais_ipm() // 4090 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_aips_ipm() // 4098 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_pais_ipm() // 40a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_das_ipm() // 40a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_dais_ipm() // 40b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=10 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_adr16_ipm() // 40b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::negx_l_adr32_ipm() // 40b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dbin:m_dbin d=0
	alu_subx(m_dbin, 0x0000);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_at - 2;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_ds_ipm() // 40c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3a5 strw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 340 strw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_ftu);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_ais_ipm() // 40d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_aips_ipm() // 40d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_pais_ipm() // 40e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_das_ipm() // 40e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_dais_ipm() // 40f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=10 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_adr16_ipm() // 40f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_sr_adr32_ipm() // 40f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3a1 stmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_ftu = m_sr;
	// 324 sftm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::chk_w_ds_dd_ipm() // 4180 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 152 chkr1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_sub(m_da[rx], m_da[ry]);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_ais_dd_ipm() // 4190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_aips_dd_ipm() // 4198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_pais_dd_ipm() // 41a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_das_dd_ipm() // 41a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_dais_dd_ipm() // 41b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_adr16_dd_ipm() // 41b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_adr32_dd_ipm() // 41b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_dpc_dd_ipm() // 41ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_dpci_dd_ipm() // 41bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 151 chkm1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::chk_w_imm16_dd_ipm() // 41bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 152 chkr1
	m_alub = m_da[rx];
	m_au = m_au - 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dtl:m_dt
	alu_sub(m_da[rx], m_dt);
	sr_nzvc();
	m_icount -= 2;
	// 153 chkr2
	m_t = !(m_isr & (SR_V|SR_N));
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.nzvc  i=.l...i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto chkr3;
	else
		goto trap1;
trap1:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[16] = m_au;
	m_ftu = 0x0018;
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
chkr3:
	// 110 chkr3
	m_t = m_isr & SR_N;
	m_icount -= 2;
	if(m_t)
		goto trap1;
	else
		goto chkr4;
mmrw3:
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
chkr4:
	// 150 chkr4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	goto mmrw3;
	}
}

void m68000_device::lea_ais_ad_ipm() // 41d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2f1 leaa1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_movemr = m_dbin;
	m_pc = m_au;
	m_at = m_da[ry];
	m_ftu = m_dbin;
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_das_ad_ipm() // 41e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2f2 lead1
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_da[ry];
	// 309 lead2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_dais_ad_ipm() // 41f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1fb leax0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3ea leax1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto leax3;
	else
		goto leax2;
leax2:
	// 130 leax2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto leax4;
leax3:
	// 1f0 leax3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto leax4;
leax4:
	// 30a leax4
	m_da[rx] = m_au;
	m_au = m_pc + 4;
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_adr16_ad_ipm() // 41f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 275 laaw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = ext32(m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_adr32_ad_ipm() // 41f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e4 laal1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_da[rx], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2bd laal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_da[rx], m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_dpc_ad_ipm() // 41fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2f2 lead1
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_pc;
	// 309 lead2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lea_dpci_ad_ipm() // 41fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1fb leax0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3ea leax1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto leax3;
	else
		goto leax2;
leax2:
	// 130 leax2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto leax4;
leax3:
	// 1f0 leax3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto leax4;
leax4:
	// 30a leax4
	m_da[rx] = m_au;
	m_au = m_pc + 4;
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_ds_ipm() // 4200 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=0
	alu_and8(m_da[ry], 0x0000);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_ais_ipm() // 4210 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_aips_ipm() // 4218 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and8(m_da[m_movems], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_pais_ipm() // 4220 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and8(m_da[m_movems], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_das_ipm() // 4228 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_dais_ipm() // 4230 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_adr16_ipm() // 4238 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_b_adr32_ipm() // 4239 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and8(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_ds_ipm() // 4240 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=0
	alu_and(m_da[ry], 0x0000);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_ais_ipm() // 4250 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_aips_ipm() // 4258 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_pais_ipm() // 4260 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_das_ipm() // 4268 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_dais_ipm() // 4270 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=none
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_adr16_ipm() // 4278 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_w_adr32_ipm() // 4279 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_ds_ipm() // 4280 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 137 nnrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=0
	alu_and(m_da[ry], 0x0000);
	sr_nzvc();
	// 15e nnrl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=18:m_da[ry] d=0
	alu_and(high16(m_da[ry]), 0x0000);
	sr_nzvc_u();
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_ais_ipm() // 4290 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_aips_ipm() // 4298 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_pais_ipm() // 42a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_das_ipm() // 42a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_dais_ipm() // 42b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=4 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_adr16_ipm() // 42b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::clr_l_adr32_ipm() // 42b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_and(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_at - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=0
	alu_and(m_alub, 0x0000);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_ds_ipm() // 4400 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dyl:m_da[ry] d=0
	alu_sub8(m_da[ry], 0x0000);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_ais_ipm() // 4410 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_aips_ipm() // 4418 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_pais_ipm() // 4420 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_das_ipm() // 4428 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_dais_ipm() // 4430 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_adr16_ipm() // 4438 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_b_adr32_ipm() // 4439 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub8(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_ds_ipm() // 4440 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=0
	alu_sub(m_da[ry], 0x0000);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_ais_ipm() // 4450 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_aips_ipm() // 4458 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_pais_ipm() // 4460 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_das_ipm() // 4468 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_dais_ipm() // 4470 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_adr16_ipm() // 4478 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_w_adr32_ipm() // 4479 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_ds_ipm() // 4480 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 137 nnrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dyl:m_da[ry] d=0
	alu_sub(m_da[ry], 0x0000);
	sr_xnzvc();
	// 15e nnrl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=18:m_da[ry] d=0
	alu_subc(high16(m_da[ry]), 0x0000);
	sr_xnzvc_u();
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_ais_ipm() // 4490 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_aips_ipm() // 4498 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_pais_ipm() // 44a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_das_ipm() // 44a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_dais_ipm() // 44b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_adr16_ipm() // 44b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::neg_l_adr32_ipm() // 44b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=0
	alu_sub(m_dbin, 0x0000);
	sr_xnzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_at - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=0
	alu_subc(m_alub, 0x0000);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_ds_ccr_ipm() // 44c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 301 rstw1
	m_movemr = m_dbin;
	m_ftu = m_da[ry];
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_ais_ccr_ipm() // 44d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_aips_ccr_ipm() // 44d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_pais_ccr_ipm() // 44e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_das_ccr_ipm() // 44e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dais_ccr_ipm() // 44f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_adr16_ccr_ipm() // 44f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_adr32_ccr_ipm() // 44f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dpc_ccr_ipm() // 44fa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dpci_ccr_ipm() // 44fb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_imm8_ccr_ipm() // 44fc ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 301 rstw1
	m_movemr = m_dbin;
	m_ftu = m_dt;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_ds_ipm() // 4600 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dyl:m_da[ry] d=0
	alu_not8(m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_ais_ipm() // 4610 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8x(m_dbin, 0xff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_aips_ipm() // 4618 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=alub d=-1
	alu_and8x(m_alub, 0xff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_pais_ipm() // 4620 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=alub d=-1
	alu_and8x(m_alub, 0xff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_das_ipm() // 4628 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8x(m_dbin, 0xff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_dais_ipm() // 4630 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=11 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8x(m_dbin, 0xff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_adr16_ipm() // 4638 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8x(m_dbin, 0xff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_b_adr32_ipm() // 4639 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8x(m_dbin, 0xff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=b....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not8(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_ds_ipm() // 4640 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dyl:m_da[ry] d=0
	alu_not(m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_ais_ipm() // 4650 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_aips_ipm() // 4658 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_pais_ipm() // 4660 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_das_ipm() // 4668 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_dais_ipm() // 4670 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=11 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_adr16_ipm() // 4678 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_w_adr32_ipm() // 4679 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2b8 nnmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.....i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_ds_ipm() // 4680 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 137 nnrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dyl:m_da[ry] d=0
	alu_not(m_da[ry]);
	sr_nzvc();
	// 15e nnrl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=18:m_da[ry] d=0
	alu_not(high16(m_da[ry]));
	sr_nzvc_u();
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_ais_ipm() // 4690 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_aips_ipm() // 4698 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_pais_ipm() // 46a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_das_ipm() // 46a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_dais_ipm() // 46b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=11 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_adr16_ipm() // 46b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::not_l_adr32_ipm() // 46b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2bc nnml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=11 c=2 m=.nzvc  i=.l...i. ALU.not_ a=R.dbin:m_dbin d=0
	alu_not(m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 15d nnml2
	m_aob = m_at;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_at - 2;
	// alu r=11 c=3 m=.nzvc  i=.l....f ALU.not_ a=alub d=0
	alu_not(m_alub);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_ds_sr_ipm() // 46c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 301 rstw1
	m_movemr = m_dbin;
	m_ftu = m_da[ry];
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_ais_sr_ipm() // 46d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_aips_sr_ipm() // 46d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_pais_sr_ipm() // 46e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_das_sr_ipm() // 46e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dais_sr_ipm() // 46f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 1e3 aixl0
	// alu r=11 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_adr16_sr_ipm() // 46f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_adr32_sr_ipm() // 46f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dpc_sr_ipm() // 46fa ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_dpci_sr_ipm() // 46fb ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 1e3 aixl0
	// alu r=11 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 159 mstw1
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_i16u_sr_ipm() // 46fc ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 301 rstw1
	m_movemr = m_dbin;
	m_ftu = m_dt;
	m_au = m_au - 2;
	m_icount -= 2;
	// 321 stiw4
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_icount -= 2;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_ds_ipm() // 4800 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 13b nbcr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dyl:m_da[ry] d=0
	alu_sbcd8(m_da[ry], 0x0000);
	sr_xnzvc_u();
	// 117 nbcr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_ais_ipm() // 4810 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_aips_ipm() // 4818 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_pais_ipm() // 4820 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_das_ipm() // 4828 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_dais_ipm() // 4830 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=9 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_adr16_ipm() // 4838 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nbcd_b_adr32_ipm() // 4839 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15c nbcm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dbin:m_dbin d=0
	alu_sbcd8(m_dbin, 0x0000);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::swap_ds_ipm() // 4840 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 341 swap1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[ry];
	m_pc = m_au;
	set_16h(m_at, m_da[ry]);
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nzvc();
	// 342 swap2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = merge_16_32(high16(m_at), m_aluo);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nz..  i=......f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_ais_ipm() // 4850 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 17c peaa1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_at = m_da[ry];
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 106 peax6
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_das_ipm() // 4868 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 17d pead1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_da[ry];
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 17e pead2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_aluo) + m_at;
	// 17f pead3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[m_sp] - 4;
	// 106 peax6
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_dais_ipm() // 4870 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1ff peax0
	// alu r=9 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3ee peax1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto peax3;
	else
		goto peax2;
peax2:
	// 134 peax2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto peax4;
peax3:
	// 1f4 peax3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto peax4;
peax4:
	// 218 peax4
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_at = m_au;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_pc + 4;
	m_icount -= 2;
	// 219 peax5
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	m_dbin = m_edb;
	// 106 peax6
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_adr16_ipm() // 4878 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 178 paaw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 10a paaw2
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_adr32_ipm() // 4879 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1fa paal1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 15f paal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 10a paaw2
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 348 mawl3
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_at;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_dpc_ipm() // 487a ffff
{
	switch(m_inst_substate) {
	case 0:
	// 17d pead1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_pc;
	m_irc = m_edb;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 17e pead2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_aluo) + m_at;
	// 17f pead3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[m_sp] - 4;
	// 106 peax6
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::pea_dpci_ipm() // 487b ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1ff peax0
	// alu r=9 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3ee peax1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto peax3;
	else
		goto peax2;
peax2:
	// 134 peax2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto peax4;
peax3:
	// 1f4 peax3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto peax4;
peax4:
	// 218 peax4
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_at = m_au;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_pc + 4;
	m_icount -= 2;
	// 219 peax5
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	m_dbin = m_edb;
	// 106 peax6
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ext_w_ds_ipm() // 4880 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 133 nnrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=2 m=.nzvc  i=.l...i. ALU.ext a=R.dyl:m_da[ry] d=0
	alu_ext(m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_list_ais_ipm() // 4890 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3a0 stmr1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// 323 stmr2
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[ry];
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmr5:
	// 0a5 stmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_listp_pais_ipm() // 48a0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3a4 push1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// 21e push2
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_at = m_da[ry];
	m_irc = m_edb;
	m_au = m_da[ry] - 2;
	step_movem_predec();
	if(m_t)
		goto push3;
	else
		goto push5;
push5:
	// 083 push5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_au = m_au - 2;
	step_movem_predec();
	if(m_t)
		goto push3;
	else
		goto push5;
push3:
	// 043 push3
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_da[ry] = m_at;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_list_das_ipm() // 48a8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f1 stmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c9 stmd2
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 322 stmd3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[ry] + ext32(m_dbin);
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmr5:
	// 0a5 stmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_list_dais_ipm() // 48b0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 325 stmx1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 4;
	m_dbin = m_edb;
	// 326 stmx2
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	m_au = m_au - 2;
	// alu r=8 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02f stmx3
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto stmx5;
	else
		goto stmx4;
stmx4:
	// 138 stmx4
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmx5:
	// 1f8 stmx5
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmr5:
	// 0a5 stmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_list_adr16_ipm() // 48b8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1ed smaw1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c1 smaw2
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 04b smaw3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmr5:
	// 0a5 stmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_list_adr32_ipm() // 48b9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e5 smal1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 112 smal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 305 smal3
	m_aob = m_au;
	set_16l(m_at, m_dbin);
	m_au = m_au + 2;
	// 04b smaw3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
stmr5:
	// 0a5 stmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr5;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ext_l_ds_ipm() // 48c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 232 extr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=8 c=3 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 233 extr2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_list_ais_ipm() // 48d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3a0 stmr1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// 323 stmr2
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[ry];
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmr4:
	// 0e5 stmr4
	m_aob = m_au;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// 0ad stmr6
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_listp_pais_ipm() // 48e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3a4 push1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// 21e push2
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_at = m_da[ry];
	m_irc = m_edb;
	m_au = m_da[ry] - 2;
	step_movem_predec();
	if(m_t)
		goto push3;
	else
		goto push4;
push4:
	// 0c3 push4
	m_aob = m_au;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_au = m_au - 2;
	// 21f push5
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = m_au;
	m_au = m_au - 2;
	step_movem_predec();
	if(m_t)
		goto push3;
	else
		goto push4;
push3:
	// 043 push3
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_da[ry] = m_at;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_list_das_ipm() // 48e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f1 stmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c9 stmd2
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 322 stmd3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[ry] + ext32(m_dbin);
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmr4:
	// 0e5 stmr4
	m_aob = m_au;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// 0ad stmr6
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_list_dais_ipm() // 48f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 325 stmx1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 4;
	m_dbin = m_edb;
	// 326 stmx2
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	m_au = m_au - 2;
	// alu r=8 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02f stmx3
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto stmx5;
	else
		goto stmx4;
stmx4:
	// 138 stmx4
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmx5:
	// 1f8 stmx5
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmr4:
	// 0e5 stmr4
	m_aob = m_au;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// 0ad stmr6
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_list_adr16_ipm() // 48f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1ed smaw1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c1 smaw2
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 04b smaw3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmr4:
	// 0e5 stmr4
	m_aob = m_au;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// 0ad stmr6
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_list_adr32_ipm() // 48f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e5 smal1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 112 smal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 305 smal3
	m_aob = m_au;
	set_16l(m_at, m_dbin);
	m_au = m_au + 2;
	// 04b smaw3
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
stmr4:
	// 0e5 stmr4
	m_aob = m_au;
	m_dbout = high16(m_da[m_movems]);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au + 2;
	// 0ad stmr6
	m_aob = m_au;
	m_t = !m_movemr;
	m_dbout = m_da[m_movems];
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au + 2;
	step_movem();
	if(m_t)
		goto mmrw2;
	else
		goto stmr4;
mmrw2:
	// 025 mmrw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_ds_ipm() // 4a00 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 12d tsrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_ais_ipm() // 4a10 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_aips_ipm() // 4a18 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_pais_ipm() // 4a20 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_das_ipm() // 4a28 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_dais_ipm() // 4a30 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_adr16_ipm() // 4a38 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_b_adr32_ipm() // 4a39 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_ds_ipm() // 4a40 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 12d tsrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_ais_ipm() // 4a50 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_aips_ipm() // 4a58 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_pais_ipm() // 4a60 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_das_ipm() // 4a68 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_dais_ipm() // 4a70 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_adr16_ipm() // 4a78 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_w_adr32_ipm() // 4a79 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c3 tsmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_ds_ipm() // 4a80 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 125 tsrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	// 362 tsrl2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_ais_ipm() // 4a90 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_aips_ipm() // 4a98 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_pais_ipm() // 4aa0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_das_ipm() // 4aa8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_dais_ipm() // 4ab0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=15 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_adr16_ipm() // 4ab8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tst_l_adr32_ipm() // 4ab9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=15 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 3cb tsml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 361 tsml2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_ds_ipm() // 4ac0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 345 tasr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[ry];
	m_pc = m_au;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_or8(m_ftu, m_da[ry]);
	// 346 tasr2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_ais_ipm() // 4ad0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_aips_ipm() // 4ad8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[m_movems];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_pais_ipm() // 4ae0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_das_ipm() // 4ae8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_dais_ipm() // 4af0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[m_movems];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=none
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_adr16_ipm() // 4af8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::tas_adr32_ipm() // 4af9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[m_movems];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.moveml:m_da[m_movems] d=R.dbin:m_dbin
	alu_or8(m_da[m_movems], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 343 tasm1
	m_pc = m_au;
	m_au = m_at;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_or8(m_ftu, m_dbin);
	m_icount -= 2;
	// 344 tasm2
	m_aob = m_au;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	if(!m_tas_write_callback.isnull())
		m_tas_write_callback(m_aob, m_dbout);
	else
		m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc;
	// alu r=15 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	sr_nzvc();
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_ais_list_ipm() // 4c90 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 127 ldmr1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 111 ldmr2
	m_aob = m_da[ry];
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_aips_list_ipm() // 4c98 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 123 popm1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 115 popm2
	m_aob = m_da[ry];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto popm6;
	else
		goto popm4;
popm4:
	// 3ac popm4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto popm6;
	else
		goto popm4;
popm6:
	// 32c popm6
	m_aob = m_pc;
	m_da[ry] = m_at;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_das_list_ipm() // 4ca8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1fd ldmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f6 ldmd2
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_da[ry];
	// 276 ldmd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 237 ldmd4
	m_aob = m_at;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_dais_list_ipm() // 4cb0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f5 ldmx0
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 027 ldmx1
	// alu r=0 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02b ldmx2
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto ldmx4;
	else
		goto ldmx3;
ldmx3:
	// 021 ldmx3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx4:
	// 0e1 ldmx4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx5:
	// 02e ldmx5
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=0 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 277 ldmx6
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_adr16_list_ipm() // 4cb8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f9 lmaw1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 30e lmaw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dt = ext32(m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	// 111 ldmr2
	m_aob = m_dt;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_dt + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_adr32_list_ipm() // 4cb9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e9 lmal1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0af lmal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ee lmal3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 111 ldmr2
	m_aob = m_dt;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_dt + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_dpc_list_ipm() // 4cba ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1fd ldmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f6 ldmd2
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_pc;
	// 276 ldmd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 237 ldmd4
	m_aob = m_at;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_w_dpci_list_ipm() // 4cbb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f5 ldmx0
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 027 ldmx1
	// alu r=0 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02b ldmx2
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto ldmx4;
	else
		goto ldmx3;
ldmx3:
	// 021 ldmx3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx4:
	// 0e1 ldmx4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx5:
	// 02e ldmx5
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=0 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 277 ldmx6
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
ldmr4:
	// 3a8 ldmr4
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[m_movems] = ext32(m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr4;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_ais_list_ipm() // 4cd0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 127 ldmr1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 111 ldmr2
	m_aob = m_da[ry];
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_aips_list_ipm() // 4cd8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 123 popm1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 115 popm2
	m_aob = m_da[ry];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto popm6;
	else
		goto popm3;
popm3:
	// 3ec popm3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f4 popm5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto popm6;
	else
		goto popm3;
popm6:
	// 32c popm6
	m_aob = m_pc;
	m_da[ry] = m_at;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_das_list_ipm() // 4ce8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1fd ldmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f6 ldmd2
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_da[ry];
	// 276 ldmd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 237 ldmd4
	m_aob = m_at;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_dais_list_ipm() // 4cf0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f5 ldmx0
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 027 ldmx1
	// alu r=0 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02b ldmx2
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto ldmx4;
	else
		goto ldmx3;
ldmx3:
	// 021 ldmx3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx4:
	// 0e1 ldmx4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx5:
	// 02e ldmx5
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 277 ldmx6
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_adr16_list_ipm() // 4cf8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f9 lmaw1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 30e lmaw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dt = ext32(m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	// 111 ldmr2
	m_aob = m_dt;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_dt + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_adr32_list_ipm() // 4cf9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e9 lmal1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0af lmal2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ee lmal3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 111 ldmr2
	m_aob = m_dt;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_at = m_dt;
	m_au = m_dt + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_dpc_list_ipm() // 4cfa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1fd ldmd1
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f6 ldmd2
	m_aob = m_au;
	m_au = ext32(m_dbin) + m_pc;
	// 276 ldmd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_at = m_au;
	m_irc = m_edb;
	m_au = m_pc + 4;
	// 237 ldmd4
	m_aob = m_at;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::movem_l_dpci_list_ipm() // 4cfb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f5 ldmx0
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 027 ldmx1
	// alu r=0 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 02b ldmx2
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto ldmx4;
	else
		goto ldmx3;
ldmx3:
	// 021 ldmx3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx4:
	// 0e1 ldmx4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	goto ldmx5;
ldmx5:
	// 02e ldmx5
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 277 ldmx6
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_au = m_at + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
ldmr3:
	// 3e8 ldmr3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16h(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2f0 ldmr5
	m_aob = m_au;
	m_t = !m_movemr;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = m_au;
	set_16l(m_da[m_movems], m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	step_movem();
	if(m_t)
		goto mmaw2;
	else
		goto ldmr3;
mmaw2:
	// 328 mmaw2
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::trap_imm4_ipm() // 4e40 fff0
{
	switch(m_inst_substate) {
	case 0:
	// 1d0 trap1
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 347 trap2
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_au = m_da[16] - 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[16] = m_au;
	m_ftu = 0x80 | ((m_ird & 0xf) << 2);
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::link_as_imm16_ipm() // 4e50 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 30b link1
	m_aob = m_au;
	m_at = m_da[ry];
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ayl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 2b5 link2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 30c link3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	// 30d link4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = ext32(m_dbin) + m_da[ry];
	// 349 mmiw2
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[m_sp] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::unlk_as_ipm() // 4e58 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 119 unlk1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	m_dbin = m_edb;
	step_movem();
	// 1fe unlk2
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 27c unlk3
	m_aob = m_pc;
	m_da[m_sp] = m_au;
	m_au = m_pc + 2;
	// 27d unlk4
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[ry] = merge_16_32(high16(m_at), m_dbin);
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_as_usp_ipm() // 4e60 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 2f5 lusp1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_movemr = m_dbin;
	m_pc = m_au;
	m_at = m_da[ry];
	m_ftu = m_dbin;
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[15] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::move_usp_as_ipm() // 4e68 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 230 susp1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[15];
	m_at = m_da[15];
	m_au = m_da[ry];
	// 233 extr2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::reset_ipm() // 4e70 ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 3a6 rset1
	m_ird = m_ir;
	m_movemr = m_dbin;
	m_pc = m_au;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	m_icount -= 2;
	// 27b rset2
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = ext32(m_aluo) - 2;
	m_icount -= 2;
	m_reset_cb(1);
	goto rset3;
rset3:
	// 0e4 rset3
	m_au = m_au - 2;
	m_icount -= 2;
	// 114 rset4
	m_t = !(m_au & 0x3f);
	m_icount -= 2;
	if(m_t)
		goto rset5;
	else
		goto rset3;
rset5:
	m_reset_cb(0);
	// 064 rset5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::nop_ipm() // 4e71 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::stop_i16u_ipm() // 4e72 ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 3a2 stop1
	m_ird = m_ir;
	m_movemr = m_dbin;
	m_pc = m_au;
	m_ftu = m_dbin;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=0
	alu_and(m_dbin, 0x0000);
	m_icount -= 2;
	// 327 aaa01
	m_ird = m_ir;
	m_pc = m_au;
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_au = m_au - 2;
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	return;
	}
}

void m68000_device::rte_ipm() // 4e73 ffff
{
	switch(m_inst_substate) {
	case 0:
	if(!(m_sr & SR_S)) {
		m_inst_state = S_PRIVILEDGE;
		return;
	}
	// 12a rtr1
	if(!m_rte_instr_callback.isnull()) (m_rte_instr_callback)(1);
	m_aob = m_da[m_sp];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[m_sp] + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 12b rtr2
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c5 rtr3
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 302 rtr4
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_da[m_sp] = m_au;
	m_sr = m_ftu & (SR_CCR|SR_SR);
	update_user_super();
	update_interrupt();
	m_dbin = m_edb;
	// 2b3 jmal2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rts_ipm() // 4e75 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 126 rts1
	m_aob = m_da[m_sp];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[m_sp] + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 116 rts2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 303 rts3
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::trapv_ipm() // 4e76 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 06d trpv1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_V;
	m_alub = m_dbin;
	m_ftu = m_sr;
	if(m_t)
		goto trpv3;
	else
		goto trpv2;
trpv2:
	// 0e2 trpv2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
trpv3:
	// 022 trpv3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_da[16] - 2;
	m_dbin = m_edb;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x001c;
	m_au = m_au + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rtr_ipm() // 4e77 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 12a rtr1
	m_aob = m_da[m_sp];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[m_sp] + 2;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 12b rtr2
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 3c5 rtr3
	m_aob = m_au;
	m_at = ext32(m_dbin);
	m_au = m_au + 2;
	// 302 rtr4
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16h(m_at, m_dbin);
	m_da[m_sp] = m_au;
	m_sr = (m_ftu & SR_CCR) | (m_sr & SR_SR);
	m_dbin = m_edb;
	// 2b3 jmal2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_ais_ipm() // 4e90 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 273 jsra1
	m_aob = m_da[ry];
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_da[ry];
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_das_ipm() // 4ea8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b0 jsrd1
	m_au = ext32(m_dbin) + m_da[ry];
	m_icount -= 2;
	// 274 jsrd2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 2;
	// 2b1 jsrd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_dais_ipm() // 4eb0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f3 jsrx0
	// alu r=0 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 2b2 jsrx1
	m_t = m_irc & 0x0800;
	m_au = ext32(m_aluo) + m_da[ry];
	m_icount -= 2;
	if(m_t)
		goto jsrx3;
	else
		goto jsrx2;
jsrx2:
	// 029 jsrx2
	m_au = m_au + ext32(m_da[map_sp(m_irc >> 12)]);
	m_icount -= 2;
	goto jsrd2;
jsrx3:
	// 0e9 jsrx3
	m_au = m_au + m_da[map_sp(m_irc >> 12)];
	m_icount -= 2;
	goto jsrd2;
jsrd2:
	// 274 jsrd2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 2;
	// 2b1 jsrd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_adr16_ipm() // 4eb8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 293 jsaw0
	m_at = ext32(m_dbin);
	m_icount -= 2;
	// 270 jsaw1
	m_aob = m_at;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_adr32_ipm() // 4eb9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f2 jsal1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 256 jsal2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_dpc_ipm() // 4eba ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b0 jsrd1
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	// 274 jsrd2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 2;
	// 2b1 jsrd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jsr_dpci_ipm() // 4ebb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f3 jsrx0
	// alu r=0 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 2b2 jsrx1
	m_t = m_irc & 0x0800;
	m_au = ext32(m_aluo) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto jsrx3;
	else
		goto jsrx2;
jsrx2:
	// 029 jsrx2
	m_au = m_au + ext32(m_da[map_sp(m_irc >> 12)]);
	m_icount -= 2;
	goto jsrd2;
jsrx3:
	// 0e9 jsrx3
	m_au = m_au + m_da[map_sp(m_irc >> 12)];
	m_icount -= 2;
	goto jsrd2;
jsrd2:
	// 274 jsrd2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 2;
	// 2b1 jsrd3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_da[m_sp] - 4;
	// 271 jsaw2
	m_aob = m_au;
	m_dbout = high16(m_pc);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 272 jsaw3
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_pc;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_at + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_ais_ipm() // 4ed0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 255 jmpa1
	m_aob = m_da[ry];
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_da[ry] + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_das_ipm() // 4ee8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2b4 jmpd1
	m_au = ext32(m_dbin) + m_da[ry];
	m_icount -= 2;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_dais_ipm() // 4ef0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1f7 jmpx0
	// alu r=0 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 2b6 jmpx1
	m_t = m_irc & 0x0800;
	m_au = ext32(m_aluo) + m_da[ry];
	m_icount -= 2;
	if(m_t)
		goto jmpx3;
	else
		goto jmpx2;
jmpx2:
	// 02d jmpx2
	m_au = m_au + ext32(m_da[map_sp(m_irc >> 12)]);
	m_icount -= 2;
	goto bbci3;
jmpx3:
	// 0ed jmpx3
	m_au = m_au + m_da[map_sp(m_irc >> 12)];
	m_icount -= 2;
	goto bbci3;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_adr16_ipm() // 4ef8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 297 jmaw1
	m_at = ext32(m_dbin);
	m_icount -= 2;
	// 2b3 jmal2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_adr32_ipm() // 4ef9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f6 jmal1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b3 jmal2
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_dpc_ipm() // 4efa ffff
{
	switch(m_inst_substate) {
	case 0:
	// 2b4 jmpd1
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::jmp_dpci_ipm() // 4efb ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1f7 jmpx0
	// alu r=0 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 2b6 jmpx1
	m_t = m_irc & 0x0800;
	m_au = ext32(m_aluo) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto jmpx3;
	else
		goto jmpx2;
jmpx2:
	// 02d jmpx2
	m_au = m_au + ext32(m_da[map_sp(m_irc >> 12)]);
	m_icount -= 2;
	goto bbci3;
jmpx3:
	// 0ed jmpx3
	m_au = m_au + m_da[map_sp(m_irc >> 12)];
	m_icount -= 2;
	goto bbci3;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_ds_ipm() // 5000 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d8 raqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_add8(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_ais_ipm() // 5010 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_aips_ipm() // 5018 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_pais_ipm() // 5020 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_das_ipm() // 5028 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_dais_ipm() // 5030 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_adr16_ipm() // 5038 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_b_imm3_adr32_ipm() // 5039 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_ds_ipm() // 5040 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d8 raqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_add(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_as_ipm() // 5048 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.ftu:m_ftu d=R.ayl:m_da[ry]
	alu_add(m_ftu, m_da[ry]);
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=23:m_dt d=17:m_da[ry]
	alu_addc(high16(m_dt), high16(m_da[ry]));
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_ais_ipm() // 5050 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_aips_ipm() // 5058 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_pais_ipm() // 5060 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_das_ipm() // 5068 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_dais_ipm() // 5070 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_adr16_ipm() // 5078 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_w_imm3_adr32_ipm() // 5079 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_ds_ipm() // 5080 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_add(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=18:m_da[ry]
	alu_addc(high16(m_dt), high16(m_da[ry]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_as_ipm() // 5088 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=2 c=2 m=.....  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.ayl:m_da[ry]
	alu_add(m_ftu, m_da[ry]);
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=2 c=3 m=.....  i=.l....f ALU.addc a=23:m_dt d=17:m_da[ry]
	alu_addc(high16(m_dt), high16(m_da[ry]));
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_ais_ipm() // 5090 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_aips_ipm() // 5098 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_pais_ipm() // 50a0 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_das_ipm() // 50a8 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_dais_ipm() // 50b0 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_adr16_ipm() // 50b8 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addq_l_imm3_adr32_ipm() // 50b9 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_add(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=R.alue:m_alue
	alu_addc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_ds_ipm() // 50c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbt_ds_rel16_ipm() // 50c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = 1;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::st_ais_ipm() // 50d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_aips_ipm() // 50d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_pais_ipm() // 50e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_das_ipm() // 50e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_dais_ipm() // 50f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_adr16_ipm() // 50f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::st_adr32_ipm() // 50f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 1;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_ds_ipm() // 5100 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d8 raqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_sub8(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_ais_ipm() // 5110 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_aips_ipm() // 5118 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_pais_ipm() // 5120 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_das_ipm() // 5128 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_dais_ipm() // 5130 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_adr16_ipm() // 5138 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_b_imm3_adr32_ipm() // 5139 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub8(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_ds_ipm() // 5140 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2d8 raqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_sub(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_as_ipm() // 5148 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.ayl:m_da[ry]
	alu_sub(m_ftu, m_da[ry]);
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=23:m_dt d=17:m_da[ry]
	alu_subc(high16(m_dt), high16(m_da[ry]));
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_ais_ipm() // 5150 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_aips_ipm() // 5158 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_pais_ipm() // 5160 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_das_ipm() // 5168 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_dais_ipm() // 5170 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_adr16_ipm() // 5178 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_w_imm3_adr32_ipm() // 5179 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 2f3 maqw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_ds_ipm() // 5180 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dyl:m_da[ry]
	alu_sub(m_ftu, m_da[ry]);
	sr_xnzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=18:m_da[ry]
	alu_subc(high16(m_dt), high16(m_da[ry]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_as_ipm() // 5188 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 2dc raql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	// alu r=5 c=2 m=.....  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.ayl:m_da[ry]
	alu_sub(m_ftu, m_da[ry]);
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25a roal3
	// alu r=5 c=3 m=.....  i=.l....f ALU.subc a=23:m_dt d=17:m_da[ry]
	alu_subc(high16(m_dt), high16(m_da[ry]));
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_ais_ipm() // 5190 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_aips_ipm() // 5198 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_pais_ipm() // 51a0 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_das_ipm() // 51a8 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_dais_ipm() // 51b0 f1f8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_adr16_ipm() // 51b8 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subq_l_imm3_adr32_ipm() // 51b9 f1ff
{
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 2f7 maql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_dt = ext32(m_ftu);
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ftu:m_ftu d=R.dbin:m_dbin
	alu_sub(m_ftu, m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=R.alue:m_alue
	alu_subc(high16(m_dt), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_ds_ipm() // 51c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbra_ds_rel16_ipm() // 51c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = 0;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sf_ais_ipm() // 51d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_aips_ipm() // 51d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_pais_ipm() // 51e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_das_ipm() // 51e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_dais_ipm() // 51f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_adr16_ipm() // 51f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sf_adr32_ipm() // 51f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_ds_ipm() // 52c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbhi_ds_rel16_ipm() // 52c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::shi_ais_ipm() // 52d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_aips_ipm() // 52d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_pais_ipm() // 52e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_das_ipm() // 52e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_dais_ipm() // 52f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_adr16_ipm() // 52f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::shi_adr32_ipm() // 52f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_ds_ipm() // 53c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbls_ds_rel16_ipm() // 53c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sls_ais_ipm() // 53d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_aips_ipm() // 53d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_pais_ipm() // 53e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_das_ipm() // 53e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_dais_ipm() // 53f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_adr16_ipm() // 53f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sls_adr32_ipm() // 53f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_ds_ipm() // 54c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbcc_ds_rel16_ipm() // 54c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = !(m_sr & SR_C);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::scc_ais_ipm() // 54d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_aips_ipm() // 54d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_pais_ipm() // 54e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_das_ipm() // 54e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_dais_ipm() // 54f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_adr16_ipm() // 54f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scc_adr32_ipm() // 54f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_C);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_ds_ipm() // 55c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbcs_ds_rel16_ipm() // 55c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = m_sr & SR_C;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::scs_ais_ipm() // 55d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_aips_ipm() // 55d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_pais_ipm() // 55e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_das_ipm() // 55e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_dais_ipm() // 55f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_adr16_ipm() // 55f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::scs_adr32_ipm() // 55f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_C;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_ds_ipm() // 56c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbne_ds_rel16_ipm() // 56c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = !(m_sr & SR_Z);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sne_ais_ipm() // 56d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_aips_ipm() // 56d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_pais_ipm() // 56e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_das_ipm() // 56e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_dais_ipm() // 56f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_adr16_ipm() // 56f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sne_adr32_ipm() // 56f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_Z);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_ds_ipm() // 57c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbeq_ds_rel16_ipm() // 57c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = m_sr & SR_Z;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::seq_ais_ipm() // 57d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_aips_ipm() // 57d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_pais_ipm() // 57e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_das_ipm() // 57e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_dais_ipm() // 57f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_adr16_ipm() // 57f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::seq_adr32_ipm() // 57f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_Z;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_ds_ipm() // 58c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbvc_ds_rel16_ipm() // 58c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = !(m_sr & SR_V);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::svc_ais_ipm() // 58d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_aips_ipm() // 58d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_pais_ipm() // 58e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_das_ipm() // 58e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_dais_ipm() // 58f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_adr16_ipm() // 58f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svc_adr32_ipm() // 58f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_ds_ipm() // 59c0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbvs_ds_rel16_ipm() // 59c8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = m_sr & SR_V;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::svs_ais_ipm() // 59d0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_aips_ipm() // 59d8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_pais_ipm() // 59e0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_das_ipm() // 59e8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_dais_ipm() // 59f0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_adr16_ipm() // 59f8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::svs_adr32_ipm() // 59f9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_V;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_ds_ipm() // 5ac0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbpl_ds_rel16_ipm() // 5ac8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = !(m_sr & SR_N);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::spl_ais_ipm() // 5ad0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_aips_ipm() // 5ad8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_pais_ipm() // 5ae0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_das_ipm() // 5ae8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_dais_ipm() // 5af0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_adr16_ipm() // 5af8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::spl_adr32_ipm() // 5af9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = !(m_sr & SR_N);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_ds_ipm() // 5bc0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbmi_ds_rel16_ipm() // 5bc8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = m_sr & SR_N;
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::smi_ais_ipm() // 5bd0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_aips_ipm() // 5bd8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_pais_ipm() // 5be0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_das_ipm() // 5be8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_dais_ipm() // 5bf0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_adr16_ipm() // 5bf8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::smi_adr32_ipm() // 5bf9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_sr & SR_N;
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_ds_ipm() // 5cc0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbge_ds_rel16_ipm() // 5cc8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sge_ais_ipm() // 5cd0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_aips_ipm() // 5cd8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_pais_ipm() // 5ce0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_das_ipm() // 5ce8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_dais_ipm() // 5cf0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_adr16_ipm() // 5cf8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sge_adr32_ipm() // 5cf9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_ds_ipm() // 5dc0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dblt_ds_rel16_ipm() // 5dc8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::slt_ais_ipm() // 5dd0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_aips_ipm() // 5dd8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_pais_ipm() // 5de0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_das_ipm() // 5de8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_dais_ipm() // 5df0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_adr16_ipm() // 5df8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::slt_adr32_ipm() // 5df9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_ds_ipm() // 5ec0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dbgt_ds_rel16_ipm() // 5ec8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sgt_ais_ipm() // 5ed0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_aips_ipm() // 5ed8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_pais_ipm() // 5ee0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_das_ipm() // 5ee8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_dais_ipm() // 5ef0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_adr16_ipm() // 5ef8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sgt_adr32_ipm() // 5ef9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_ds_ipm() // 5fc0 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 384 sccr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccr2;
	else
		goto roaw2;
roaw2:
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
sccr2:
	// 0cb sccr2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::dble_ds_rel16_ipm() // 5fc8 fff8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 06c dbcc1
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = ext32(m_dbin) + m_pc;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	m_icount -= 2;
	if(m_t)
		goto dbcc6;
	else
		goto dbcc2;
dbcc2:
	// 046 dbcc2
	m_aob = m_au;
	m_alub = m_da[ry];
	m_at = m_au;
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=....... ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	// 175 dbcc3
	m_t = m_isr & SR_Z;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at + 2;
	// alu r=15 c=3 m=.....  i=....... ALU.add a=alub d=-1
	alu_add(m_alub, 0xffff);
	if(m_t)
		goto dbcc5;
	else
		goto dbcc4;
dbcc6:
	// 0c6 dbcc6
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc4:
	// 0c7 dbcc4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dbcc5:
	// 007 dbcc5
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto dbcc4;
	}
}

void m68000_device::sle_ais_ipm() // 5fd0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_aips_ipm() // 5fd8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_dt;
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_pais_ipm() // 5fe0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_dt;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_das_ipm() // 5fe8 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_dais_ipm() // 5ff0 fff8
{
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=15 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_dt;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=none
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_adr16_ipm() // 5ff8 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_dt;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sle_adr32_ipm() // 5ff9 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_dt;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=R.dtl:m_dt d=R.dbin:m_dbin
	alu_or8(m_dt, m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 380 sccb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_pc = m_au;
	// alu r=15 c=1 m=.....  i=b...... ALU.and_ a=none d=0
	alu_and8(0x0000, 0x0000);
	if(m_t)
		goto sccb2;
	else
		goto sccb3;
sccb3:
	// 04f sccb3
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	step_movem();
	goto morw2;
sccb2:
	// 0cf sccb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=15 c=2 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=-1
	alu_or8(m_aluo, 0xff);
	goto morw2;
morw2:
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=15 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bra_rel16_ipm() // 6000 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = 1;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bra_rel8_ipm() // 6000 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = 1;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bsr_rel16_ipm() // 6100 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 0a9 bsrw1
	m_at = m_au;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[m_sp] - 4;
	m_icount -= 2;
	// 10e bsrw2
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 0aa bsrw3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_dbin) + m_pc;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bsr_rel8_ipm() // 6100 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 089 bsri1
	m_at = m_pc;
	m_au = m_da[m_sp] - 4;
	// alu r=0 c=1 m=.....  i=....... ALU.and_ a=R.pcl:m_pc d=-1
	alu_and(m_pc, 0xffff);
	m_icount -= 2;
	// 102 bsri2
	m_aob = m_au;
	m_dbout = high16(m_at);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[m_sp] = m_au;
	m_au = m_au + 2;
	// 0a8 bsri3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = ext32(m_ftu) + m_pc;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bhi_rel16_ipm() // 6200 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bhi_rel8_ipm() // 6200 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = (m_sr & (SR_C|SR_Z)) == 0;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bls_rel16_ipm() // 6300 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bls_rel8_ipm() // 6300 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = (m_sr & (SR_C|SR_Z)) != 0;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bcc_rel16_ipm() // 6400 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = !(m_sr & SR_C);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bcc_rel8_ipm() // 6400 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = !(m_sr & SR_C);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bcs_rel16_ipm() // 6500 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = m_sr & SR_C;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bcs_rel8_ipm() // 6500 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = m_sr & SR_C;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bne_rel16_ipm() // 6600 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = !(m_sr & SR_Z);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bne_rel8_ipm() // 6600 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = !(m_sr & SR_Z);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::beq_rel16_ipm() // 6700 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = m_sr & SR_Z;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::beq_rel8_ipm() // 6700 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = m_sr & SR_Z;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bvc_rel16_ipm() // 6800 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = !(m_sr & SR_V);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bvc_rel8_ipm() // 6800 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = !(m_sr & SR_V);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bvs_rel16_ipm() // 6900 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = m_sr & SR_V;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bvs_rel8_ipm() // 6900 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = m_sr & SR_V;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bpl_rel16_ipm() // 6a00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = !(m_sr & SR_N);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bpl_rel8_ipm() // 6a00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = !(m_sr & SR_N);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bmi_rel16_ipm() // 6b00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = m_sr & SR_N;
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bmi_rel8_ipm() // 6b00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = m_sr & SR_N;
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bge_rel16_ipm() // 6c00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bge_rel8_ipm() // 6c00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = ((m_sr & (SR_N|SR_V)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V)) == 0);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::blt_rel16_ipm() // 6d00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::blt_rel8_ipm() // 6d00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bgt_rel16_ipm() // 6e00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::bgt_rel8_ipm() // 6e00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = ((m_sr & (SR_N|SR_V|SR_Z)) == (SR_N|SR_V)) || ((m_sr & (SR_N|SR_V|SR_Z)) == 0);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ble_rel16_ipm() // 6f00 ffff
{
	switch(m_inst_substate) {
	case 0:
	// 068 bbcw1
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = ext32(m_dbin) + m_pc;
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbcw3;
bbcw3:
	// 085 bbcw3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	// 1e1 malw3
	m_aob = m_au;
	m_movemr = m_dbin;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_ftu = m_dbin;
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ble_rel8_ipm() // 6f00 ff00
{
	switch(m_inst_substate) {
	case 0:
	// 308 bbci1
	m_t = (m_sr & SR_Z) || ((m_sr & (SR_N|SR_V)) == SR_N) || ((m_sr & (SR_N|SR_V)) == SR_V);
	m_au = m_pc + ext32(m_ftu);
	m_icount -= 2;
	if(m_t)
		goto bbci3;
	else
		goto bbci2;
bbci2:
	// 045 bbci2
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	goto b;
bbci3:
	// 0c5 bbci3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	goto b;
b:
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::moveq_imm8o_dd_ipm() // 7000 f100
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 23b rlql1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_da[rx] = ext32(m_ftu);
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	sr_nzvc();
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_ds_dd_ipm() // 8000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_or8(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_ais_dd_ipm() // 8010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_aips_dd_ipm() // 8018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_pais_dd_ipm() // 8020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_das_dd_ipm() // 8028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dais_dd_ipm() // 8030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_adr16_dd_ipm() // 8038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_adr32_dd_ipm() // 8039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dpc_dd_ipm() // 803a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dpci_dd_ipm() // 803b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_imm8_dd_ipm() // 803c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_or8(m_dt, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_ds_dd_ipm() // 8040 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_or(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_ais_dd_ipm() // 8050 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_aips_dd_ipm() // 8058 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_pais_dd_ipm() // 8060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_das_dd_ipm() // 8068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dais_dd_ipm() // 8070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_adr16_dd_ipm() // 8078 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_adr32_dd_ipm() // 8079 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dpc_dd_ipm() // 807a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dpci_dd_ipm() // 807b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_imm16_dd_ipm() // 807c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_or(m_dt, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_ds_dd_ipm() // 8080 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_or(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.aluo:m_aluo
	// 25e rorl3
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=18:m_da[ry] d=16:m_da[rx]
	alu_or(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_ais_dd_ipm() // 8090 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_aips_dd_ipm() // 8098 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_pais_dd_ipm() // 80a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_das_dd_ipm() // 80a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dais_dd_ipm() // 80b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=14 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_adr16_dd_ipm() // 80b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_adr32_dd_ipm() // 80b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dpc_dd_ipm() // 80ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dpci_dd_ipm() // 80bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=14 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_or(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=alub d=16:m_da[rx]
	alu_or(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_imm32_dd_ipm() // 80bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_or(m_dt, m_da[rx]);
	sr_nzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.aluo:m_aluo
	// 25e rorl3
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=23:m_dt d=16:m_da[rx]
	alu_or(high16(m_dt), high16(m_da[rx]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_ds_dd_ipm() // 80c0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a6 dvur1
	m_alub = m_da[ry];
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_da[ry]);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_ais_dd_ipm() // 80d0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_aips_dd_ipm() // 80d8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_pais_dd_ipm() // 80e0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_das_dd_ipm() // 80e8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_dais_dd_ipm() // 80f0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=1 c=5 m=.....  i=.l.d... ALU.over a=R.dbin:m_dbin d=0
	alu_over();
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_adr16_dd_ipm() // 80f8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_adr32_dd_ipm() // 80f9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_dpc_dd_ipm() // 80fa f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_dpci_dd_ipm() // 80fb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=1 c=5 m=.....  i=.l.d... ALU.over a=R.dbin:m_dbin d=0
	alu_over();
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0a4 dvum1
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divu_w_imm16_dd_ipm() // 80fc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0a6 dvur1
	m_alub = m_dt;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dt);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 213 dvum2
	m_t = m_isr & SR_Z;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=16:m_da[rx]
	alu_sub(m_alub, high16(m_da[rx]));
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvur2;
	else
		goto dvum3;
dvum3:
	// 023 dvum3
	m_t = m_isr & SR_C;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum5;
	else
		goto dvum4;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum5:
	// 291 dvum5
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum8:
	// 252 dvum8
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvumc;
	else
		goto dvumb;
dvum7:
	// 2d2 dvum7
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvum9;
	else
		goto dvum6;
dvumb:
	// 3e9 dvumb
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvume;
	else
		goto dvum6;
dvumc:
	// 369 dvumc
	m_t = m_isr & SR_C;
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvumf;
	else
		goto dvumd;
dvum6:
	// 2d0 dvum6
	m_t = m_isr & SR_N;
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	if(m_t)
		goto dvum7;
	else
		goto dvum8;
dvum9:
	// 250 dvum9
	set_16h(m_da[rx], m_aluo);
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aluo:m_aluo d=0
	alu_and(m_aluo, 0x0000);
	m_icount -= 2;
	goto dvumd;
dvume:
	// 290 dvume
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvum5;
dvumd:
	// 0c0 dvumd
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	m_au = m_pc + 2;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	goto dvum0;
dvumf:
	// 080 dvumf
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_aluo;
	set_16h(m_da[rx], m_at);
	m_au = m_pc + 2;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	goto dvum0;
dvum0:
	// 212 dvum0
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_alue);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.alue:m_alue
	alu_sub(m_alub, m_alue);
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sbcd_ds_dd_ipm() // 8100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1cd rbrb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sbcd8(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 11b rbrb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 238 rbrb3
	m_ird = m_ir;
	set_8(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sbcd_pais_paid_ipm() // 8108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 107 asbb1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 135 asbb2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 136 asbb3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// 04e asbb4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// 040 asbb5
	m_aob = m_pc;
	// alu r=9 c=2 m=xnzvc  i=b....i. ALU.sbcd a=alub d=R.dbin:m_dbin
	alu_sbcd8(m_alub, m_dbin);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=3 m=xnzvc  i=b.....f ALU.sbcd a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_ais_ipm() // 8110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_aips_ipm() // 8118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_pais_ipm() // 8120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_das_ipm() // 8128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_dais_ipm() // 8130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_adr16_ipm() // 8138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_b_dd_adr32_ipm() // 8139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=b....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=b...... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_ais_ipm() // 8150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_aips_ipm() // 8158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_pais_ipm() // 8160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_das_ipm() // 8168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_dais_ipm() // 8170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=14 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_adr16_ipm() // 8178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_w_dd_adr32_ipm() // 8179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=14 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.....i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=....... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_ais_ipm() // 8190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_aips_ipm() // 8198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_pais_ipm() // 81a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_das_ipm() // 81a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_dais_ipm() // 81b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=14 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_adr16_ipm() // 81b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::or_l_dd_adr32_ipm() // 81b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=14 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=14 c=2 m=.nzvc  i=.l...i. ALU.or_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_or(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=14 c=3 m=.nzvc  i=.l....f ALU.or_ a=16:m_da[rx] d=R.alue:m_alue
	alu_or(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=14 c=0 m=.....  i=.l..... ALU.or_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::divs_w_ds_dd_ipm() // 81c0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ae dvs02
	m_alub = m_da[ry];
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_da[ry]);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_ais_dd_ipm() // 81d0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_aips_dd_ipm() // 81d8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_pais_dd_ipm() // 81e0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_das_dd_ipm() // 81e8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_dais_dd_ipm() // 81f0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=1 c=5 m=.....  i=.l.d... ALU.over a=R.dbin:m_dbin d=0
	alu_over();
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_adr16_dd_ipm() // 81f8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_adr32_dd_ipm() // 81f9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_dpc_dd_ipm() // 81fa f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_dpci_dd_ipm() // 81fb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=1 c=5 m=.....  i=.l.d... ALU.over a=R.dbin:m_dbin d=0
	alu_over();
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 12;
		return;
	}
	[[fallthrough]]; case 12:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 0ac dvs01
	m_alub = m_dbin;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 11;
		return;
	}
	[[fallthrough]]; case 11:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::divs_w_imm16_dd_ipm() // 81fc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ae dvs02
	m_alub = m_dt;
	m_alue = m_da[rx];
	m_pc = m_au;
	set_16h(m_at, m_dt);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.dtl:m_dt d=-1
	alu_and(m_dt, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 0c9 dvs03
	m_t = (m_isr & SR_Z) ? 2 : (m_isr & SR_N) ? 1 : 0;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	if(m_t == 0)
		goto dvs04;
	else if(m_t == 1)
		goto dvs05;
	else
		goto dvur2;
dvs04:
	// 0a3 dvs04
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvs05:
	// 063 dvs05
	m_alub = m_aluo;
	set_16l(m_at, high16(m_da[rx]));
	m_au = merge_16_32(0, m_ftu) + 1;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs06;
dvur2:
	// 0e3 dvur2
	m_ftu = m_sr;
	m_au = m_pc - 2;
	m_icount -= 2;
	// 217 dvur3
	m_sr = (m_sr & ~SR_T) | SR_S;
	update_user_super();
	update_interrupt();
	m_pc = m_au;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.aul:m_au d=-1
	alu_and(m_au, 0xffff);
	m_au = m_da[16] - 2;
	m_icount -= 2;
	// 3c2 trap3
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.ftu:m_ftu d=-1
	alu_and(m_ftu, 0xffff);
	// 360 trap4
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_da[16] = m_au;
	m_ftu = 0x0014;
	m_au = m_au + 2;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=R.pch:m_pc d=-1
	alu_and(high16(m_pc), 0xffff);
	// 0ef trap5
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_at = ext32(m_ftu);
	m_au = m_au - 4;
	// alu r=1 c=1 m=.....  i=.l.d... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 367 trap6
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_pc = m_at;
	m_au = m_at + 2;
	m_dbin = m_edb;
	// 11a trap7
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 8;
		return;
	}
	[[fallthrough]]; case 8:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 2b7 trap8
	m_aob = merge_16_32(high16(m_at), m_dbin);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 9;
		return;
	}
	[[fallthrough]]; case 9:
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin) + 2;
	// 11c trap9
	m_icount -= 2;
	// 363 b
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// 34c mmrw3
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 10;
		return;
	}
	[[fallthrough]]; case 10:
	m_irc = m_edb;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs06:
	// 176 dvs06
	m_t = m_isr & SR_N;
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.dxl:m_da[rx] d=0
	alu_sub(m_da[rx], 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs10;
	else
		goto dvs07;
dvs07:
	// 042 dvs07
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.atl:m_at
	alu_sub(m_alub, m_at);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs10:
	// 0c2 dvs10
	m_alue = m_aluo;
	// alu r=1 c=3 m=.....  i=.l.d... ALU.subc a=16:m_da[rx] d=0
	alu_subc(high16(m_da[rx]), 0x0000);
	m_icount -= 2;
	// 177 dvs11
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	goto dvs08;
dvs08:
	// 216 dvs08
	m_t = m_isr & SR_C;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs09;
	else
		goto dvumz;
dvumz:
	// 2d5 dvumz
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs09:
	// 295 dvs09
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvuma:
	// 0e6 dvuma
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=1 c=5 m=.nzvc  i=.l.d.i. ALU.over a=none d=none
	alu_over();
	sr_nzvc();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvs0c:
	// 2d6 dvs0c
	m_t = !(m_au & 0x3f);
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs0e;
	else
		goto dvs0d;
dvs0d:
	// 3ed dvs0d
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs0f;
	else
		goto dvs0a;
dvs0e:
	// 32d dvs0e
	m_t = m_isr & SR_C;
	m_icount -= 2;
	if(m_t)
		goto dvs12;
	else
		goto dvs13;
dvs0a:
	// 2d4 dvs0a
	m_au = m_au - 1;
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs0c;
dvs0f:
	// 294 dvs0f
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.atl:m_at d=-1
	alu_and(m_at, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	goto dvs09;
dvs13:
	// 254 dvs13
	set_16l(m_at, m_aluo);
	// alu r=1 c=6 m=.....  i=.l.d... ALU.sla1 a=R.aluo:m_aluo d=-1
	alu_sla1(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs12:
	// 214 dvs12
	m_au = m_au - 1;
	// alu r=1 c=4 m=.....  i=.l.d... ALU.sla0 a=R.aluo:m_aluo d=-1
	alu_sla0(m_aluo);
	m_icount -= 2;
	goto dvs14;
dvs14:
	// 210 dvs14
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.ath:m_at d=-1
	alu_and(high16(m_at), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	// 211 dvs15
	m_t = m_isr & SR_N;
	m_alub = m_alue;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=16:m_da[rx] d=-1
	alu_and(high16(m_da[rx]), 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1d;
	else
		goto dvs16;
dvs16:
	// 041 dvs16
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1a;
	else
		goto dvs17;
dvs1d:
	// 0c1 dvs1d
	m_t = m_isr & SR_N;
	set_16h(m_at, m_at);
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto dvs1e;
	else
		goto dvs1f;
dvs17:
	// 04d dvs17
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_t = m_isr & SR_N;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto dvuma;
	else
		goto leaa2;
dvs1a:
	// 0cd dvs1a
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 0ce dvs1b
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvs1c;
	else
		goto dvum4;
dvs1f:
	// 08a dvs1f
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	// alu r=1 c=2 m=.nzvc  i=.l.d.i. ALU.sub a=alub d=0
	alu_sub(m_alub, 0x0000);
	sr_nzvc();
	m_icount -= 2;
	// 049 dvs20
	m_aob = m_pc;
	m_t = (m_isr & (SR_Z|SR_N)) != 0;
	set_16l(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc();
	if(m_t)
		goto leaa2;
	else
		goto dvuma;
dvs1e:
	// 0ca dvs1e
	m_t = m_isr & SR_N;
	m_alub = m_aluo;
	set_16l(m_at, m_aluo);
	// alu r=1 c=2 m=.....  i=.l.d... ALU.sub a=R.ath:m_at d=0
	alu_sub(high16(m_at), 0x0000);
	m_icount -= 2;
	if(m_t)
		goto dvum4;
	else
		goto dvs1c;
leaa2:
	// 066 leaa2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_at;
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
dvum4:
	// 2d1 dvum4
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_au = m_pc + 2;
	goto dvuma;
dvs1c:
	// 251 dvs1c
	m_aob = m_pc;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	set_16h(m_at, m_aluo);
	m_au = m_pc + 2;
	// alu r=1 c=1 m=.nzvc  i=.l.d.i. ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nzvc();
	goto leaa2;
	}
}

void m68000_device::sub_b_ds_dd_ipm() // 9000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub8(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_ais_dd_ipm() // 9010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_aips_dd_ipm() // 9018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_pais_dd_ipm() // 9020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_das_dd_ipm() // 9028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dais_dd_ipm() // 9030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_adr16_dd_ipm() // 9038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_adr32_dd_ipm() // 9039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dpc_dd_ipm() // 903a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dpci_dd_ipm() // 903b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_imm8_dd_ipm() // 903c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub8(m_dt, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_ds_dd_ipm() // 9040 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_as_dd_ipm() // 9048 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_ais_dd_ipm() // 9050 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_aips_dd_ipm() // 9058 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_pais_dd_ipm() // 9060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_das_dd_ipm() // 9068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dais_dd_ipm() // 9070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_adr16_dd_ipm() // 9078 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_adr32_dd_ipm() // 9079 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dpc_dd_ipm() // 907a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dpci_dd_ipm() // 907b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_imm16_dd_ipm() // 907c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_ds_dd_ipm() // 9080 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=18:m_da[ry] d=16:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_as_dd_ipm() // 9088 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=17:m_da[ry] d=16:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_ais_dd_ipm() // 9090 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_aips_dd_ipm() // 9098 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_pais_dd_ipm() // 90a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_das_dd_ipm() // 90a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dais_dd_ipm() // 90b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_adr16_dd_ipm() // 90b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_adr32_dd_ipm() // 90b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dpc_dd_ipm() // 90ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dpci_dd_ipm() // 90bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_imm32_dd_ipm() // 90bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=23:m_dt d=16:m_da[rx]
	alu_subc(high16(m_dt), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_ds_ad_ipm() // 90c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_as_ad_ipm() // 90c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_ais_ad_ipm() // 90d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_aips_ad_ipm() // 90d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_pais_ad_ipm() // 90e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_das_ad_ipm() // 90e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_dais_ad_ipm() // 90f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_adr16_ad_ipm() // 90f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_adr32_ad_ipm() // 90f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_dpc_ad_ipm() // 90fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_dpci_ad_ipm() // 90fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_w_imm16_ad_ipm() // 90fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_b_ds_dd_ipm() // 9100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_subx8(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_b_pais_paid_ipm() // 9108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10f asxw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 131 asxw2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 132 asxw3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// 04a asxw4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// 065 asxw5
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=b....i. ALU.subx a=alub d=R.dbin:m_dbin
	alu_subx8(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_ais_ipm() // 9110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_aips_ipm() // 9118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_pais_ipm() // 9120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_das_ipm() // 9128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_dais_ipm() // 9130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_adr16_ipm() // 9138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_b_dd_adr32_ipm() // 9139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=b....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_w_ds_dd_ipm() // 9140 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_subx(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_w_pais_paid_ipm() // 9148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10f asxw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 131 asxw2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 132 asxw3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// 04a asxw4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// 065 asxw5
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=2 m=xnzvc  i=.....i. ALU.subx a=alub d=R.dbin:m_dbin
	alu_subx(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_ais_ipm() // 9150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_aips_ipm() // 9158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_pais_ipm() // 9160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_das_ipm() // 9168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_dais_ipm() // 9170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_adr16_ipm() // 9178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_w_dd_adr32_ipm() // 9179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.....i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_l_ds_dd_ipm() // 9180 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_subx(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=18:m_da[ry] d=16:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::subx_l_pais_paid_ipm() // 9188 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10b asxl1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 048 asxl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_dbin;
	m_au = m_au - 2;
	m_dbin = m_edb;
	// 139 asxl3
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 13a asxl4
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// 04c asxl5
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_au = m_au - 2;
	m_dbin = m_edb;
	// 047 asxl6
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[rx] = m_au;
	m_au = m_au + 2;
	// alu r=10 c=2 m=xnzvc  i=.l...i. ALU.subx a=R.aluo:m_aluo d=R.dbin:m_dbin
	alu_subx(m_aluo, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 061 asxl7
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = ext32(m_dbin);
	// 062 asxl8
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=10 c=3 m=xnzvc  i=.l....f ALU.subc a=alub d=R.dbin:m_dbin
	alu_subc(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_ais_ipm() // 9190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_aips_ipm() // 9198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_pais_ipm() // 91a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_das_ipm() // 91a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_dais_ipm() // 91b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_adr16_ipm() // 91b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::sub_l_dd_adr32_ipm() // 91b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=5 c=2 m=xnzvc  i=.l...i. ALU.sub a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_sub(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=5 c=3 m=xnzvc  i=.l....f ALU.subc a=16:m_da[rx] d=R.alue:m_alue
	alu_subc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_ds_ad_ipm() // 91c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=18:m_da[ry] d=15:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_as_ad_ipm() // 91c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=17:m_da[ry] d=15:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_ais_ad_ipm() // 91d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_aips_ad_ipm() // 91d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_pais_ad_ipm() // 91e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_das_ad_ipm() // 91e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_dais_ad_ipm() // 91f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_adr16_ad_ipm() // 91f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_adr32_ad_ipm() // 91f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_dpc_ad_ipm() // 91fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_dpci_ad_ipm() // 91fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::suba_l_imm32_ad_ipm() // 91fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=5 c=2 m=.....  i=.....i. ALU.sub a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=5 c=3 m=.....  i=......f ALU.subc a=23:m_dt d=15:m_da[rx]
	alu_subc(high16(m_dt), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_ds_dd_ipm() // b000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1d1 cprw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub8(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_ais_dd_ipm() // b010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_aips_dd_ipm() // b018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_pais_dd_ipm() // b020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_das_dd_ipm() // b028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_dais_dd_ipm() // b030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_adr16_dd_ipm() // b038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_adr32_dd_ipm() // b039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_dpc_dd_ipm() // b03a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_dpci_dd_ipm() // b03b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_b_imm8_dd_ipm() // b03c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1d1 cprw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub8(m_dt, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_ds_dd_ipm() // b040 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1d1 cprw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_as_dd_ipm() // b048 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d1 cprw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_ais_dd_ipm() // b050 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_aips_dd_ipm() // b058 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_pais_dd_ipm() // b060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_das_dd_ipm() // b068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_dais_dd_ipm() // b070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_adr16_dd_ipm() // b078 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_adr32_dd_ipm() // b079 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_dpc_dd_ipm() // b07a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_dpci_dd_ipm() // b07b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1d3 cpmw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_w_imm16_dd_ipm() // b07c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1d1 cprw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_nzvc();
	// 23a rcaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_ds_dd_ipm() // b080 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=18:m_da[ry] d=16:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_as_dd_ipm() // b088 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=17:m_da[ry] d=16:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_ais_dd_ipm() // b090 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_aips_dd_ipm() // b098 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_pais_dd_ipm() // b0a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_das_dd_ipm() // b0a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_dais_dd_ipm() // b0b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=6 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_adr16_dd_ipm() // b0b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_adr32_dd_ipm() // b0b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_dpc_dd_ipm() // b0ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_dpci_dd_ipm() // b0bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=6 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=16:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmp_l_imm32_dd_ipm() // b0bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=23:m_dt d=16:m_da[rx]
	alu_subc(high16(m_dt), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_ds_ad_ipm() // b0c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1d9 cprm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_as_ad_ipm() // b0c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d9 cprm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_ais_ad_ipm() // b0d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_aips_ad_ipm() // b0d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_pais_ad_ipm() // b0e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_das_ad_ipm() // b0e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_dais_ad_ipm() // b0f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_adr16_ad_ipm() // b0f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_adr32_ad_ipm() // b0f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_dpc_ad_ipm() // b0fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_dpci_ad_ipm() // b0fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1cf cpmm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_w_imm16_ad_ipm() // b0fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1d9 cprm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_nzvc();
	// 174 cprm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=R.ath:m_at d=15:m_da[rx]
	alu_subc(high16(m_at), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_ds_ipm() // b100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_eor8(m_da[rx], m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpm_b_aips_aipd_ipm() // b108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 06b cmmw1
	m_aob = m_da[ry];
	m_pc = m_au;
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 086 cmmw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 122 cmmw3
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_da[rx] + (rx < 15 ? 1 : 2);
	// alu r=6 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 170 cmmw4
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	// alu r=6 c=2 m=.nzvc  i=b....i. ALU.sub a=R.aluo:m_aluo d=R.dbin:m_dbin
	alu_sub8(m_aluo, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_ais_ipm() // b110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_aips_ipm() // b118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_pais_ipm() // b120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_das_ipm() // b128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_dais_ipm() // b130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_adr16_ipm() // b138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_b_dd_adr32_ipm() // b139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=b....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=b...... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_ds_ipm() // b140 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 100 roaw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_eor(m_da[rx], m_da[ry]);
	sr_nzvc();
	// 08b roaw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpm_w_aips_aipd_ipm() // b148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 06b cmmw1
	m_aob = m_da[ry];
	m_pc = m_au;
	m_au = m_da[ry] + 2;
	// 086 cmmw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 122 cmmw3
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_da[rx] + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 170 cmmw4
	m_aob = m_pc;
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_da[rx] = m_au;
	m_irc = m_edb;
	m_au = m_pc + 2;
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.aluo:m_aluo d=R.dbin:m_dbin
	alu_sub(m_aluo, m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_ais_ipm() // b150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_aips_ipm() // b158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_pais_ipm() // b160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_das_ipm() // b168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_dais_ipm() // b170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=13 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_adr16_ipm() // b178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_w_dd_adr32_ipm() // b179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=13 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.....i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=....... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_ds_ipm() // b180 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 10c roal1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dyl:m_da[ry]
	alu_eor(m_da[rx], m_da[ry]);
	sr_nzvc();
	// 259 roal2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[ry], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	// 25a roal3
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=18:m_da[ry]
	alu_eor(high16(m_da[rx]), high16(m_da[ry]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25b roal4
	m_ird = m_ir;
	set_16h(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpm_l_aips_aipd_ipm() // b188 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 06f cmml1
	m_aob = m_da[ry];
	m_pc = m_au;
	m_au = m_da[ry] + 2;
	// 08e cmml2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 154 cmml3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_da[ry] = m_au;
	m_dbin = m_edb;
	// 12e cmml4
	m_aob = m_da[rx];
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_da[rx] + 2;
	// alu r=6 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 155 cmml5
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alue = m_dbin;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 156 cmml6
	m_aob = m_pc;
	m_da[rx] = m_au;
	m_au = m_pc + 2;
	// alu r=6 c=2 m=.nzvc  i=.l...i. ALU.sub a=R.aluo:m_aluo d=R.dbin:m_dbin
	alu_sub(m_aluo, m_dbin);
	sr_nzvc();
	// 157 cmml7
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=.l....f ALU.subc a=alub d=R.alue:m_alue
	alu_subc(m_alub, m_alue);
	sr_nzvc_u();
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_ais_ipm() // b190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_aips_ipm() // b198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_pais_ipm() // b1a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_das_ipm() // b1a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_dais_ipm() // b1b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=13 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_adr16_ipm() // b1b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::eor_l_dd_adr32_ipm() // b1b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=13 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=13 c=2 m=.nzvc  i=.l...i. ALU.eor a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_eor(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=13 c=3 m=.nzvc  i=.l....f ALU.eor a=16:m_da[rx] d=R.alue:m_alue
	alu_eor(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=13 c=0 m=.....  i=.l..... ALU.eor a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_ds_ad_ipm() // b1c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=18:m_da[ry] d=15:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_as_ad_ipm() // b1c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_sub(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=17:m_da[ry] d=15:m_da[rx]
	alu_subc(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_ais_ad_ipm() // b1d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_aips_ad_ipm() // b1d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_pais_ad_ipm() // b1e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_das_ad_ipm() // b1e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_dais_ad_ipm() // b1f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_adr16_ad_ipm() // b1f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_adr32_ad_ipm() // b1f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_dpc_ad_ipm() // b1fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_dpci_ad_ipm() // b1fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=6 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=6 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1d7 cpml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_sub(m_dbin, m_da[rx]);
	sr_nzvc();
	// 172 cpml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=alub d=15:m_da[rx]
	alu_subc(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::cmpa_l_imm32_ad_ipm() // b1fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1d5 cprl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=6 c=2 m=.nzvc  i=.....i. ALU.sub a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_sub(m_dt, m_da[rx]);
	sr_nzvc();
	// 173 cprl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=6 c=3 m=.nzvc  i=......f ALU.subc a=23:m_dt d=15:m_da[rx]
	alu_subc(high16(m_dt), high16(m_da[rx]));
	sr_nzvc_u();
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_ds_dd_ipm() // c000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_and8(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_ais_dd_ipm() // c010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_aips_dd_ipm() // c018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_pais_dd_ipm() // c020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_das_dd_ipm() // c028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dais_dd_ipm() // c030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_adr16_dd_ipm() // c038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_adr32_dd_ipm() // c039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dpc_dd_ipm() // c03a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dpci_dd_ipm() // c03b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and8(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_imm8_dd_ipm() // c03c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_and8(m_dt, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_ds_dd_ipm() // c040 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_and(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_ais_dd_ipm() // c050 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_aips_dd_ipm() // c058 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_pais_dd_ipm() // c060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_das_dd_ipm() // c068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dais_dd_ipm() // c070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_adr16_dd_ipm() // c078 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_adr32_dd_ipm() // c079 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dpc_dd_ipm() // c07a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dpci_dd_ipm() // c07b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_imm16_dd_ipm() // c07c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_and(m_dt, m_da[rx]);
	sr_nzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_ds_dd_ipm() // c080 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_and(m_da[ry], m_da[rx]);
	sr_nzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.aluo:m_aluo
	// 25e rorl3
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=18:m_da[ry] d=16:m_da[rx]
	alu_and(high16(m_da[ry]), high16(m_da[rx]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_ais_dd_ipm() // c090 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_aips_dd_ipm() // c098 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_pais_dd_ipm() // c0a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_das_dd_ipm() // c0a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dais_dd_ipm() // c0b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=4 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_adr16_dd_ipm() // c0b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_adr32_dd_ipm() // c0b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dpc_dd_ipm() // c0ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dpci_dd_ipm() // c0bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=4 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_and(m_dbin, m_da[rx]);
	sr_nzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=alub d=16:m_da[rx]
	alu_and(m_alub, high16(m_da[rx]));
	sr_nzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_imm32_dd_ipm() // c0bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_and(m_dt, m_da[rx]);
	sr_nzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.aluo:m_aluo
	// 25e rorl3
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=23:m_dt d=16:m_da[rx]
	alu_and(high16(m_dt), high16(m_da[rx]));
	sr_nzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_ds_dd_ipm() // c0c0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 15b mulr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_da[ry];
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_ais_dd_ipm() // c0d0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_aips_dd_ipm() // c0d8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_pais_dd_ipm() // c0e0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_das_dd_ipm() // c0e8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_dais_dd_ipm() // c0f0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=7 c=5 m=.....  i=.lm.... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_adr16_dd_ipm() // c0f8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_adr32_dd_ipm() // c0f9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_dpc_dd_ipm() // c0fa f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_dpci_dd_ipm() // c0fb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=7 c=5 m=.....  i=.lm.... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::mulu_w_imm16_dd_ipm() // c0fc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 15b mulr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dt;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm3;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : m_alue & 2 ? 1 : 2;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32mu(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else
		goto mulm4;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::abcd_ds_dd_ipm() // c100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1cd rbrb1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=3 c=2 m=xnzvc  i=b....i. ALU.abcd a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_abcd8(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 11b rbrb2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=3 m=xnzvc  i=b.....f ALU.add a=R.aluo:m_aluo d=?
	// 238 rbrb3
	m_ird = m_ir;
	set_8(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::abcd_pais_paid_ipm() // c108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 107 asbb1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 135 asbb2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=3 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 136 asbb3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// 04e asbb4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// 040 asbb5
	m_aob = m_pc;
	// alu r=3 c=2 m=xnzvc  i=b....i. ALU.abcd a=alub d=R.dbin:m_dbin
	alu_abcd8(m_alub, m_dbin);
	sr_xnzvc_u();
	// 113 asbb6
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=3 m=xnzvc  i=b.....f ALU.add a=R.aluo:m_aluo d=?
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_ais_ipm() // c110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_aips_ipm() // c118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_pais_ipm() // c120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_das_ipm() // c128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_dais_ipm() // c130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_adr16_ipm() // c138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_b_dd_adr32_ipm() // c139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=b....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and8(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::exg_dd_ds_ipm() // c140 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 3e3 exge1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// 231 exge2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_au;
	m_da[ry] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::exg_ad_as_ipm() // c148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e3 exge1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// 231 exge2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_au;
	m_da[ry] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_ais_ipm() // c150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_aips_ipm() // c158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_pais_ipm() // c160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_das_ipm() // c168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_dais_ipm() // c170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_adr16_ipm() // c178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_w_dd_adr32_ipm() // c179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.....i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::exg_dd_as_ipm() // c188 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 3e3 exge1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = m_da[rx];
	m_au = m_da[ry];
	// 231 exge2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[rx] = m_au;
	m_da[ry] = m_at;
	m_irc = m_edb;
	m_dbin = m_edb;
	// 08d rcal3
	m_ird = m_ir;
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_ais_ipm() // c190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_aips_ipm() // c198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_pais_ipm() // c1a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_das_ipm() // c1a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_dais_ipm() // c1b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=4 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_adr16_ipm() // c1b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::and_l_dd_adr32_ipm() // c1b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=none
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=R.dbin:m_dbin
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=4 c=2 m=.nzvc  i=.l...i. ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	sr_nzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=4 c=3 m=.nzvc  i=.l....f ALU.and_ a=16:m_da[rx] d=R.alue:m_alue
	alu_and(high16(m_da[rx]), m_alue);
	sr_nzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::muls_w_ds_dd_ipm() // c1c0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 15b mulr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_da[ry];
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_ais_dd_ipm() // c1d0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_aips_dd_ipm() // c1d8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_pais_dd_ipm() // c1e0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_das_dd_ipm() // c1e8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_dais_dd_ipm() // c1f0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=7 c=5 m=.....  i=.lm.... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_adr16_dd_ipm() // c1f8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_adr32_dd_ipm() // c1f9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_dpc_dd_ipm() // c1fa f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_dpci_dd_ipm() // c1fb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=7 c=5 m=.....  i=.lm.... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=7 c=1 m=.....  i=.lm.... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 15a mulm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dbin;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::muls_w_imm16_dd_ipm() // c1fc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 15b mulr1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_alub = m_da[rx];
	m_alue = m_dt;
	m_at = m_au;
	m_au = ext32(m_ftu);
	// alu r=7 c=1 m=.nzvc  i=.lm..i. ALU.and_ a=R.dxl:m_da[rx] d=0
	alu_and(m_da[rx], 0x0000);
	sr_nzvc();
	// 3c4 mulm2
	m_t = m_alue & 1;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	if(m_t)
		goto mulm5;
	else
		goto mulm4;
mulm4:
	// 0e0 mulm4
	m_t = !(m_au & 0x3f) ? 0 : (m_alue & 3) == 1 ? 1 : (m_alue & 3) == 2 ? 2 : 3;
	set_16l(m_pc, m_at);
	m_au = m_au - 1;
	// alu r=7 c=4 m=.nzvc  i=.lm...f ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32ms(m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	if(m_t == 0)
		goto mulm6;
	else if(m_t == 1)
		goto mulm3;
	else if(m_t == 2)
		goto mulm5;
	else
		goto mulm4;
mulm5:
	// 0a0 mulm5
	// alu r=7 c=2 m=.nzvc  i=.lm...f ALU.sub a=alub d=R.aluo:m_aluo
	alu_sub(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
mulm6:
	// 020 mulm6
	m_ird = m_ir;
	set_16h(m_pc, high16(m_at));
	m_da[rx] = merge_16_32(m_aluo, m_alue);
	m_au = m_at + 2;
	// alu r=7 c=1 m=.nzvc  i=.lm...f ALU.and_ a=R.aluo:m_aluo d=-1
	alu_and(m_aluo, 0xffff);
	sr_nzvc_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
mulm3:
	// 060 mulm3
	// alu r=7 c=3 m=.nzvc  i=.lm...f ALU.add a=alub d=R.aluo:m_aluo
	alu_add(m_alub, m_aluo);
	sr_nzvc_u();
	m_icount -= 2;
	goto mulm4;
	}
}

void m68000_device::add_b_ds_dd_ipm() // d000 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_add8(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_ais_dd_ipm() // d010 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_aips_dd_ipm() // d018 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_pais_dd_ipm() // d020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_das_dd_ipm() // d028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dais_dd_ipm() // d030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_adr16_dd_ipm() // d038 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_adr32_dd_ipm() // d039 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dpc_dd_ipm() // d03a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dpci_dd_ipm() // d03b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add8(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_imm8_dd_ipm() // d03c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_add8(m_dt, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_ds_dd_ipm() // d040 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_as_dd_ipm() // d048 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_ais_dd_ipm() // d050 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_aips_dd_ipm() // d058 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_pais_dd_ipm() // d060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_das_dd_ipm() // d068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dais_dd_ipm() // d070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_adr16_dd_ipm() // d078 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_adr32_dd_ipm() // d079 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dpc_dd_ipm() // d07a f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dpci_dd_ipm() // d07b f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 1c3 romw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_imm16_dd_ipm() // d07c f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_add(m_dt, m_da[rx]);
	sr_xnzvc();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_ds_dd_ipm() // d080 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=18:m_da[ry] d=16:m_da[rx]
	alu_addc(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_as_dd_ipm() // d088 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.ayl:m_da[ry] d=R.dxl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=17:m_da[ry] d=16:m_da[rx]
	alu_addc(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_ais_dd_ipm() // d090 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_aips_dd_ipm() // d098 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_pais_dd_ipm() // d0a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_das_dd_ipm() // d0a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dais_dd_ipm() // d0b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_adr16_dd_ipm() // d0b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_adr32_dd_ipm() // d0b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dpc_dd_ipm() // d0ba f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dpci_dd_ipm() // d0bb f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dbin:m_dbin d=R.dxl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	sr_xnzvc();
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=alub d=16:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	sr_xnzvc_u();
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_imm32_dd_ipm() // d0bc f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dtl:m_dt d=R.dxl:m_da[rx]
	alu_add(m_dt, m_da[rx]);
	sr_xnzvc();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=23:m_dt d=16:m_da[rx]
	alu_addc(high16(m_dt), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_ds_ad_ipm() // d0c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_as_ad_ipm() // d0c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_ais_ad_ipm() // d0d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_aips_ad_ipm() // d0d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = 0;
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_pais_ad_ipm() // d0e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_das_ad_ipm() // d0e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_dais_ad_ipm() // d0f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_adr16_ad_ipm() // d0f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_adr32_ad_ipm() // d0f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_dpc_ad_ipm() // d0fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_dpci_ad_ipm() // d0fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = 0;
	m_dbin = m_edb;
	// 1c7 romm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_w_imm16_ad_ipm() // d0fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c9 rorm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_add(m_dt, m_da[rx]);
	// 3c8 rorm2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25f rorm3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=R.ath:m_at d=15:m_da[rx]
	alu_addc(high16(m_at), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_b_ds_dd_ipm() // d100 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=12 c=2 m=xnzvc  i=b....i. ALU.addx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_addx8(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_8(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=b...... ALU.addx a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_b_pais_paid_ipm() // d108 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10f asxw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	// alu r=12 c=0 m=.....  i=b...... ALU.addx a=none d=R.dbin:m_dbin
	m_icount -= 2;
	// 131 asxw2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=12 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 132 asxw3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - (rx < 15 ? 1 : 2);
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=b...... ALU.addx a=none d=none
	// 04a asxw4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=b...... ALU.addx a=none d=R.dbin:m_dbin
	// 065 asxw5
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=12 c=2 m=xnzvc  i=b....i. ALU.addx a=alub d=R.dbin:m_dbin
	alu_addx8(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=12 c=0 m=.....  i=b...... ALU.addx a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_ais_ipm() // d110 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_aips_ipm() // d118 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + (ry < 15 ? 1 : 2);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_pais_ipm() // d120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - (ry < 15 ? 1 : 2);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=alub d=-1
	alu_and8(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_das_ipm() // d128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_dais_ipm() // d130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=b...... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_adr16_ipm() // d138 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_b_dd_adr32_ipm() // d139 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, m_aob & 1 ? 0x00ff : 0xff00);
	if(!(m_aob & 1))
		m_edb >>= 8;
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and8(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=b....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add8(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	set_8xl(m_dbout, m_aluo);
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, (m_aob & 1) ? 0x00ff : 0xff00);
	m_icount -= 4;
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_w_ds_dd_ipm() // d140 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c1 rorw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=12 c=2 m=xnzvc  i=.....i. ALU.addx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_addx(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 27a rrgw2
	m_ird = m_ir;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=....... ALU.addx a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_w_pais_paid_ipm() // d148 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10f asxw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	// alu r=12 c=0 m=.....  i=....... ALU.addx a=none d=R.dbin:m_dbin
	m_icount -= 2;
	// 131 asxw2
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=12 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 132 asxw3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=....... ALU.addx a=none d=none
	// 04a asxw4
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_at = m_au;
	m_da[rx] = m_au;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=....... ALU.addx a=none d=R.dbin:m_dbin
	// 065 asxw5
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=12 c=2 m=xnzvc  i=.....i. ALU.addx a=alub d=R.dbin:m_dbin
	alu_addx(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=12 c=0 m=.....  i=....... ALU.addx a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_ais_ipm() // d150 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_aips_ipm() // d158 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_pais_ipm() // d160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_das_ipm() // d168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_dais_ipm() // d170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_adr16_ipm() // d178 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_w_dd_adr32_ipm() // d179 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 299 morw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.....i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_l_ds_dd_ipm() // d180 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=12 c=2 m=xnzvc  i=.l...i. ALU.addx a=R.dyl:m_da[ry] d=R.dxl:m_da[rx]
	alu_addx(m_da[ry], m_da[rx]);
	sr_xnzvc_u();
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=none d=R.aluo:m_aluo
	// 25e rorl3
	// alu r=12 c=3 m=xnzvc  i=.l....f ALU.addx a=18:m_da[ry] d=16:m_da[rx]
	alu_addx(high16(m_da[ry]), high16(m_da[rx]));
	sr_xnzvc_u();
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::addx_l_pais_paid_ipm() // d188 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 10b asxl1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = 0;
	m_au = m_da[ry] - 2;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=none d=R.dbin:m_dbin
	m_icount -= 2;
	// 048 asxl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alub = m_dbin;
	m_au = m_au - 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=R.dbin:m_dbin d=none
	// 139 asxl3
	m_aob = m_au;
	m_da[ry] = m_au;
	// alu r=12 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 13a asxl4
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_da[rx] - 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=none d=none
	// 04c asxl5
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_au = m_au - 2;
	m_dbin = m_edb;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=R.dbin:m_dbin d=none
	// 047 asxl6
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_at = m_au;
	m_da[rx] = m_au;
	m_au = m_au + 2;
	// alu r=12 c=2 m=xnzvc  i=.l...i. ALU.addx a=R.aluo:m_aluo d=R.dbin:m_dbin
	alu_addx(m_aluo, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 061 asxl7
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = ext32(m_dbin);
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=none d=R.dbin:m_dbin
	// 062 asxl8
	m_aob = m_pc;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_irc = m_edb;
	m_au = m_at;
	// alu r=12 c=3 m=xnzvc  i=.l....f ALU.addx a=alub d=R.dbin:m_dbin
	alu_addx(m_alub, m_dbin);
	sr_xnzvc_u();
	m_dbin = m_edb;
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	// alu r=12 c=0 m=.....  i=.l..... ALU.addx a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_ais_ipm() // d190 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_aips_ipm() // d198 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_pais_ipm() // d1a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_das_ipm() // d1a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_dais_ipm() // d1b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=.l..... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_adr16_ipm() // d1b8 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::add_l_dd_adr32_ipm() // d1b9 f1ff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 29d morl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_pc = m_au;
	m_irc = m_edb;
	m_au = m_at;
	// alu r=2 c=2 m=xnzvc  i=.l...i. ALU.add a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_add(m_da[rx], m_dbin);
	sr_xnzvc();
	m_dbin = m_edb;
	// 34d morl2
	m_aob = m_au;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 6;
		return;
	}
	[[fallthrough]]; case 6:
	m_au = m_au - 2;
	// alu r=2 c=3 m=xnzvc  i=.l....f ALU.addc a=16:m_da[rx] d=R.alue:m_alue
	alu_addc(high16(m_da[rx]), m_alue);
	sr_xnzvc_u();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 7;
		return;
	}
	[[fallthrough]]; case 7:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_ds_ad_ipm() // d1c0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dyl:m_da[ry] d=R.axl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=18:m_da[ry] d=15:m_da[rx]
	alu_addc(high16(m_da[ry]), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_as_ad_ipm() // d1c8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_da[ry]);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.ayl:m_da[ry] d=R.axl:m_da[rx]
	alu_add(m_da[ry], m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=17:m_da[ry] d=15:m_da[rx]
	alu_addc(high16(m_da[ry]), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_ais_ad_ipm() // d1d0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00b adrl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_aips_ad_ipm() // d1d8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00f pinl1
	m_aob = m_da[ry];
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = m_da[ry] + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 21a pinl2
	m_aob = m_au;
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_au + 2;
	// 21b pinl3
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_pais_ad_ipm() // d1e0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 179 pdcl1
	m_au = m_da[ry] - 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_icount -= 2;
	// 17a pdcl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_das_ad_ipm() // d1e8 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_dais_ad_ipm() // d1f0 f1f8
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_adr16_ad_ipm() // d1f8 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 00e abww1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = 0;
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_adr32_ad_ipm() // d1f9 f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e6 ablw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 00d ablw2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = 0;
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 008 ablw3
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 005 adrl2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_dpc_ad_ipm() // d1fa f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c6 adsl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_pc;
	m_dbin = m_edb;
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_dpci_ad_ipm() // d1fb f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e7 aixw0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e6 aixw1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_pc + ext32(m_aluo);
	if(m_t)
		goto aixw4;
	else
		goto aixw2;
aixw2:
	// 124 aixw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
aixw4:
	// 1e4 aixw4
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsl2;
adsl2:
	// 00c adsl2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_au + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 026 adsl3
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_alub = m_dbin;
	m_alue = m_dbin;
	m_at = m_au;
	m_au = m_pc + 4;
	m_dbin = m_edb;
	// 1cb roml1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dbin);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dbin:m_dbin d=R.axl:m_da[rx]
	alu_add(m_dbin, m_da[rx]);
	// 25c roml2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=alub d=15:m_da[rx]
	alu_addc(m_alub, high16(m_da[rx]));
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::adda_l_imm32_ad_ipm() // d1fc f1ff
{
	int rx = map_sp(((m_irdi >> 9) & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 0a7 e#l1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_dt, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 0ea e#w1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	set_16h(m_at, m_dbin);
	set_16l(m_dt, m_dbin);
	m_irc = m_edb;
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 1c5 rorl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_at = ext32(m_dt);
	// alu r=2 c=2 m=.....  i=.....i. ALU.add a=R.dtl:m_dt d=R.axl:m_da[rx]
	alu_add(m_dt, m_da[rx]);
	// 3c0 rorl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	set_16l(m_da[rx], m_aluo);
	m_irc = m_edb;
	m_dbin = m_edb;
	// 25e rorl3
	// alu r=2 c=3 m=.....  i=......f ALU.addc a=23:m_dt d=15:m_da[rx]
	alu_addc(high16(m_dt), high16(m_da[rx]));
	m_icount -= 2;
	// 25d roml3
	m_ird = m_ir;
	set_16h(m_da[rx], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_b_imm3_ds_ipm() // e000 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=b....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_b_imm3_ds_ipm() // e008 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=b....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_b_imm3_ds_ipm() // e010 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=8 c=1 m=.....  i=b...r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_and8x(high16(m_da[ry]), 0xff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=b...ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8x(m_da[ry], 0xff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=b....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_b_imm3_ds_ipm() // e018 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=b....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror8(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_b_dd_ds_ipm() // e020 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=2 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=b....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_b_dd_ds_ipm() // e028 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=5 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=b....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_b_dd_ds_ipm() // e030 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=8 c=1 m=.....  i=b...r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_and8x(high16(m_da[ry]), 0xff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=b...ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8x(m_da[ry], 0xff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=b....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_b_dd_ds_ipm() // e038 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=10 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=b....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror8(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_w_imm3_ds_ipm() // e040 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_w_imm3_ds_ipm() // e048 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_w_imm3_ds_ipm() // e050 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_w_imm3_ds_ipm() // e058 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_w_dd_ds_ipm() // e060 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_w_dd_ds_ipm() // e068 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_w_dd_ds_ipm() // e070 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_w_dd_ds_ipm() // e078 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_l_imm3_ds_ipm() // e080 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=.l...i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_l_imm3_ds_ipm() // e088 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=.l...i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_l_imm3_ds_ipm() // e090 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=8 c=1 m=.....  i=.l..r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=.l..ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=.l...i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=8 c=1 m=.nz..  i=.l..r.f ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_l_imm3_ds_ipm() // e098 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=.l...i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror32(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_l_dd_ds_ipm() // e0a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=2 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=2 c=4 m=xnzvc  i=.l...i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_l_dd_ds_ipm() // e0a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=5 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=5 c=4 m=xnzvc  i=.l...i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_l_dd_ds_ipm() // e0b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=8 c=1 m=.....  i=.l..r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.nzvc  i=.l..ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=8 c=4 m=xnzvc  i=.l...i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=8 c=1 m=.nz..  i=.l..r.f ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_l_dd_ds_ipm() // e0b8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=10 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=10 c=4 m=.nzvc  i=.l...i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror32(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_ais_ipm() // e0d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_aips_ipm() // e0d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_pais_ipm() // e0e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_das_ipm() // e0e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_dais_ipm() // e0f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=2 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_adr16_ipm() // e0f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asr_adr32_ipm() // e0f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=2 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=2 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=2 c=4 m=xnzvc  i=.....i. ALU.asr a=R.aluo:m_aluo d=-1
	alu_asr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_b_imm3_ds_ipm() // e100 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=3 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=b....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_b_imm3_ds_ipm() // e108 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=b....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_b_imm3_ds_ipm() // e110 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_and8x(high16(m_da[ry]), 0xff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=b...ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8x(m_da[ry], 0xff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=b....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_b_imm3_ds_ipm() // e118 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=b....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol8(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_b_dd_ds_ipm() // e120 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=3 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=b....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_b_dd_ds_ipm() // e128 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=4 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=b....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=b...... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_b_dd_ds_ipm() // e130 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=11 c=1 m=.....  i=b...r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_and8x(high16(m_da[ry]), 0xff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=b...ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8x(m_da[ry], 0xff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=b....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl8(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_b_dd_ds_ipm() // e138 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=9 c=1 m=.....  i=b...... ALU.and_ a=18:m_da[ry] d=-1
	alu_and8(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=b....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and8(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=b....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol8(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_8(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_w_imm3_ds_ipm() // e140 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_w_imm3_ds_ipm() // e148 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_w_imm3_ds_ipm() // e150 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_w_imm3_ds_ipm() // e158 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 381 srrw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_w_dd_ds_ipm() // e160 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_w_dd_ds_ipm() // e168 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_w_dd_ds_ipm() // e170 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_w_dd_ds_ipm() // e178 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 382 sriw1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 383 srrw2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
srrw3:
	// 2d3 srrw3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto nbcr3;
	else
		goto srrw3;
nbcr3:
	// 253 nbcr3
	m_ird = m_ir;
	set_16l(m_da[ry], m_aluo);
	m_au = m_pc + 2;
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_l_imm3_ds_ipm() // e180 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=3 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=.l...i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=3 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_l_imm3_ds_ipm() // e188 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=.l...i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=R.alue:m_alue
	alu_and(m_aluo, m_alue);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_l_imm3_ds_ipm() // e190 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=.l..ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=.l...i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.nz..  i=.l..r.f ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_l_imm3_ds_ipm() // e198 f1f8
{
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 385 srrl1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_ftu);
	// alu r=9 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=.l...i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol32(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_l_dd_ds_ipm() // e1a0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=3 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=3 c=4 m=xnzvc  i=.l...i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=3 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_l_dd_ds_ipm() // e1a8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=4 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=4 c=4 m=xnzvc  i=.l...i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	// alu r=4 c=0 m=.....  i=.l..... ALU.and_ a=R.aluo:m_aluo d=R.alue:m_alue
	alu_and(m_aluo, m_alue);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_l_dd_ds_ipm() // e1b0 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=11 c=1 m=.....  i=.l..r.. ALU.and_ a=18:m_da[ry] d=-1
	alu_andx(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.nzvc  i=.l..ri. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_andx(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=11 c=4 m=xnzvc  i=.l...i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl32(m_aluo);
	sr_xnzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.nz..  i=.l..r.f ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_l_dd_ds_ipm() // e1b8 f1f8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = m_irdi & 7;
	switch(m_inst_substate) {
	case 0:
	// 386 sril1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = ext32(m_da[rx]);
	// alu r=9 c=1 m=.....  i=.l..... ALU.and_ a=18:m_da[ry] d=-1
	alu_and(high16(m_da[ry]), 0xffff);
	// 387 srrl2
	m_t = !(m_au & 0x3f);
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_alue = m_aluo;
	m_irc = m_edb;
	m_au = m_au - 1;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.nzvc  i=.l...i. ALU.and_ a=R.dyl:m_da[ry] d=-1
	alu_and(m_da[ry], 0xffff);
	sr_nzvc();
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl3:
	// 2d7 srrl3
	m_t = !(m_au & 0x3f);
	m_au = m_au - 1;
	// alu r=9 c=4 m=.nzvc  i=.l...i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol32(m_aluo);
	sr_nzvc();
	m_icount -= 2;
	if(m_t)
		goto srrl4;
	else
		goto srrl3;
srrl4:
	// 257 srrl4
	m_alub = m_alue;
	m_da[ry] = merge_16_32(m_alue, m_aluo);
	m_icount -= 2;
	// 306 srrl5
	m_ird = m_ir;
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.nz..  i=.l....f ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	sr_nz_u();
	set_ftu_const();
	m_icount -= 2;
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_ais_ipm() // e1d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_aips_ipm() // e1d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_pais_ipm() // e1e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_das_ipm() // e1e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_dais_ipm() // e1f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=3 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_adr16_ipm() // e1f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::asl_adr32_ipm() // e1f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=3 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=3 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=3 c=4 m=xnzvc  i=.....i. ALU.asl a=R.aluo:m_aluo d=-1
	alu_asl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_ais_ipm() // e2d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_aips_ipm() // e2d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_pais_ipm() // e2e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_das_ipm() // e2e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_dais_ipm() // e2f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=5 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_adr16_ipm() // e2f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsr_adr32_ipm() // e2f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=5 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=5 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=5 c=4 m=xnzvc  i=.....i. ALU.lsr a=R.aluo:m_aluo d=-1
	alu_lsr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_ais_ipm() // e3d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_aips_ipm() // e3d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_pais_ipm() // e3e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_das_ipm() // e3e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.dbin:m_dbin
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_dais_ipm() // e3f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=4 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.aluo:m_aluo d=none
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=R.rzl:m_da[map_sp(m_irc >> 12)]
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=none
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_adr16_ipm() // e3f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::lsl_adr32_ipm() // e3f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=none
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=R.dxl:m_da[rx] d=R.dbin:m_dbin
	alu_and(m_da[rx], m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=4 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=4 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=4 c=4 m=xnzvc  i=.....i. ALU.lsl a=R.aluo:m_aluo d=-1
	alu_lsl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	// alu r=4 c=0 m=.....  i=....... ALU.and_ a=none d=none
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_ais_ipm() // e4d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_aips_ipm() // e4d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_pais_ipm() // e4e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_das_ipm() // e4e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_dais_ipm() // e4f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=8 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_adr16_ipm() // e4f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxr_adr32_ipm() // e4f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=8 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=8 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=8 c=4 m=xnzvc  i=.....i. ALU.roxr a=R.aluo:m_aluo d=-1
	alu_roxr(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_ais_ipm() // e5d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_aips_ipm() // e5d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_pais_ipm() // e5e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=alub d=-1
	alu_andx(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_das_ipm() // e5e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_dais_ipm() // e5f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=11 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_adr16_ipm() // e5f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::roxl_adr32_ipm() // e5f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=11 c=1 m=.....  i=....r.. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=11 c=1 m=.nzvc  i=....ri. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_andx(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=11 c=4 m=xnzvc  i=.....i. ALU.roxl a=R.aluo:m_aluo d=-1
	alu_roxl(m_aluo);
	sr_xnzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_ais_ipm() // e6d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_aips_ipm() // e6d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_pais_ipm() // e6e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_das_ipm() // e6e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_dais_ipm() // e6f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=10 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_adr16_ipm() // e6f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::ror_adr32_ipm() // e6f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=10 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=10 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=10 c=4 m=.nzvc  i=.....i. ALU.ror a=R.aluo:m_aluo d=-1
	alu_ror(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_ais_ipm() // e7d0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 006 adrw1
	m_aob = m_da[ry];
	m_at = m_da[ry];
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_aips_ipm() // e7d8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 21c pinw1
	m_aob = m_da[ry];
	m_alub = m_dbin;
	m_dcr = m_da[rx];
	m_at = m_da[ry];
	m_au = m_da[ry] + 2;
	// 21d pinw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_da[ry] = m_au;
	m_au = m_pc + 2;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_pais_ipm() // e7e0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 103 pdcw1
	m_alub = m_dbin;
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_au = m_da[ry] - 2;
	m_icount -= 2;
	// 17b pdcw2
	m_aob = m_au;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_at = m_au;
	m_da[ry] = m_au;
	m_au = m_pc;
	m_dbin = m_edb;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=alub d=-1
	alu_and(m_alub, 0xffff);
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_das_ipm() // e7e8 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1c2 adsw1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_irc = m_edb;
	m_au = ext32(m_dbin) + m_da[ry];
	m_dbin = m_edb;
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_dais_ipm() // e7f0 fff8
{
	int rx = (m_irdi >> 9) & 7;
	int ry = map_sp((m_irdi & 7) | 8);
	switch(m_inst_substate) {
	case 0:
	// 1e3 aixl0
	// alu r=9 c=5 m=.....  i=....... ALU.ext a=R.dbin:m_dbin d=0
	alu_ext(m_dbin);
	m_icount -= 2;
	// 3e2 aixl1
	m_aob = m_au;
	m_t = m_irc & 0x0800;
	m_au = m_da[ry] + ext32(m_aluo);
	if(m_t)
		goto aixl5;
	else
		goto aixl2;
aixl2:
	// 120 aixl2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_au = ext32(m_da[map_sp(m_irc >> 12)]) + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
aixl5:
	// 1e0 aixl5
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_da[map_sp(m_irc >> 12)] + m_au;
	m_irc = m_edb;
	m_dbin = m_edb;
	step_movem();
	goto adsw2;
adsw2:
	// 02a adsw2
	m_aob = m_au;
	m_at = m_au;
	m_au = m_pc + 4;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	// 024 adrw2
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_dcr = m_da[rx];
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_adr16_ipm() // e7f8 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 00a abwl1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	m_pc = m_au;
	m_dcr = m_da[rx];
	m_at = ext32(m_dbin);
	m_irc = m_edb;
	m_au = ext32(m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

void m68000_device::rol_adr32_ipm() // e7f9 ffff
{
	int rx = (m_irdi >> 9) & 7;
	switch(m_inst_substate) {
	case 0:
	// 1e2 abll1
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 1;
		return;
	}
	[[fallthrough]]; case 1:
	set_16h(m_at, m_dbin);
	m_au = m_au + 2;
	m_dbin = m_edb;
	// 009 abll2
	m_aob = m_au;
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 2;
		return;
	}
	[[fallthrough]]; case 2:
	m_pc = m_au;
	m_dcr = m_da[rx];
	set_16l(m_at, m_dbin);
	m_irc = m_edb;
	m_au = merge_16_32(high16(m_at), m_dbin);
	m_dbin = m_edb;
	// 004 abll3
	m_aob = m_at;
	m_base_ssw = SSW_DATA | SSW_R;
	m_edb = m_mmu->read_data(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 3;
		return;
	}
	[[fallthrough]]; case 3:
	m_au = m_pc + 2;
	// alu r=9 c=1 m=.....  i=....... ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	m_dbin = m_edb;
	// 3c7 sftm1
	m_aob = m_au;
	m_ir = m_irc;
	if(m_next_state != S_TRACE) m_next_state = m_int_next_state;
	m_pc = m_au;
	m_au = m_au + 2;
	// alu r=9 c=1 m=.nzvc  i=.....i. ALU.and_ a=R.dbin:m_dbin d=-1
	alu_and(m_dbin, 0xffff);
	sr_nzvc();
	// 304 stmw2
	m_base_ssw = SSW_PROGRAM | SSW_R;
	m_edb = m_mmu->read_program(m_aob & ~1, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 4;
		return;
	}
	[[fallthrough]]; case 4:
	m_irc = m_edb;
	m_au = m_at;
	m_dbin = m_edb;
	// alu r=9 c=4 m=.nzvc  i=.....i. ALU.rol a=R.aluo:m_aluo d=-1
	alu_rol(m_aluo);
	sr_nzvc();
	// 38d morw2
	m_aob = m_au;
	m_ird = m_ir;
	m_dbout = m_aluo;
	m_base_ssw = SSW_DATA;
	m_mmu->write_data(m_aob & ~1, m_dbout, 0xffff);
	m_icount -= 4;
	if(m_aob & 1) {
		m_icount -= 4;
		m_inst_state = S_ADDRESS_ERROR;
		m_inst_substate = 0;
		return;
	}
	if(m_icount <= m_bcount) {
		m_inst_substate = 5;
		return;
	}
	[[fallthrough]]; case 5:
	m_au = m_pc + 2;
	set_ftu_const();
	m_inst_state = m_next_state ? m_next_state : m_decode_table[m_ird];
	m_inst_substate = 0;
	if(m_sr & SR_T)
		m_next_state = S_TRACE;
	return;
	}
}

const m68000_device::handler m68000_device::s_handlers_ipm[] = {
	&m68000_device::state_reset_ipm,
	&m68000_device::state_bus_error_ipm,
	&m68000_device::state_address_error_ipm,
	&m68000_device::state_double_fault_ipm,
	&m68000_device::state_interrupt_ipm,
	&m68000_device::state_trace_ipm,
	&m68000_device::state_illegal_ipm,
	&m68000_device::state_priviledge_ipm,
	&m68000_device::state_linea_ipm,
	&m68000_device::state_linef_ipm,
	&m68000_device::ori_b_imm8_ds_ipm,
	&m68000_device::ori_b_imm8_ais_ipm,
	&m68000_device::ori_b_imm8_aips_ipm,
	&m68000_device::ori_b_imm8_pais_ipm,
	&m68000_device::ori_b_imm8_das_ipm,
	&m68000_device::ori_b_imm8_dais_ipm,
	&m68000_device::ori_b_imm8_adr16_ipm,
	&m68000_device::ori_b_imm8_adr32_ipm,
	&m68000_device::ori_imm8_ccr_ipm,
	&m68000_device::ori_w_imm16_ds_ipm,
	&m68000_device::ori_w_imm16_ais_ipm,
	&m68000_device::ori_w_imm16_aips_ipm,
	&m68000_device::ori_w_imm16_pais_ipm,
	&m68000_device::ori_w_imm16_das_ipm,
	&m68000_device::ori_w_imm16_dais_ipm,
	&m68000_device::ori_w_imm16_adr16_ipm,
	&m68000_device::ori_w_imm16_adr32_ipm,
	&m68000_device::ori_i16u_sr_ipm,
	&m68000_device::ori_l_imm32_ds_ipm,
	&m68000_device::ori_l_imm32_ais_ipm,
	&m68000_device::ori_l_imm32_aips_ipm,
	&m68000_device::ori_l_imm32_pais_ipm,
	&m68000_device::ori_l_imm32_das_ipm,
	&m68000_device::ori_l_imm32_dais_ipm,
	&m68000_device::ori_l_imm32_adr16_ipm,
	&m68000_device::ori_l_imm32_adr32_ipm,
	&m68000_device::btst_dd_ds_ipm,
	&m68000_device::movep_w_das_dd_ipm,
	&m68000_device::btst_dd_ais_ipm,
	&m68000_device::btst_dd_aips_ipm,
	&m68000_device::btst_dd_pais_ipm,
	&m68000_device::btst_dd_das_ipm,
	&m68000_device::btst_dd_dais_ipm,
	&m68000_device::btst_dd_adr16_ipm,
	&m68000_device::btst_dd_adr32_ipm,
	&m68000_device::btst_dd_dpc_ipm,
	&m68000_device::btst_dd_dpci_ipm,
	&m68000_device::btst_dd_imm_ipm,
	&m68000_device::bchg_dd_ds_ipm,
	&m68000_device::movep_l_das_dd_ipm,
	&m68000_device::bchg_dd_ais_ipm,
	&m68000_device::bchg_dd_aips_ipm,
	&m68000_device::bchg_dd_pais_ipm,
	&m68000_device::bchg_dd_das_ipm,
	&m68000_device::bchg_dd_dais_ipm,
	&m68000_device::bchg_dd_adr16_ipm,
	&m68000_device::bchg_dd_adr32_ipm,
	&m68000_device::bclr_dd_ds_ipm,
	&m68000_device::movep_w_dd_das_ipm,
	&m68000_device::bclr_dd_ais_ipm,
	&m68000_device::bclr_dd_aips_ipm,
	&m68000_device::bclr_dd_pais_ipm,
	&m68000_device::bclr_dd_das_ipm,
	&m68000_device::bclr_dd_dais_ipm,
	&m68000_device::bclr_dd_adr16_ipm,
	&m68000_device::bclr_dd_adr32_ipm,
	&m68000_device::bset_dd_ds_ipm,
	&m68000_device::movep_l_dd_das_ipm,
	&m68000_device::bset_dd_ais_ipm,
	&m68000_device::bset_dd_aips_ipm,
	&m68000_device::bset_dd_pais_ipm,
	&m68000_device::bset_dd_das_ipm,
	&m68000_device::bset_dd_dais_ipm,
	&m68000_device::bset_dd_adr16_ipm,
	&m68000_device::bset_dd_adr32_ipm,
	&m68000_device::andi_b_imm8_ds_ipm,
	&m68000_device::andi_b_imm8_ais_ipm,
	&m68000_device::andi_b_imm8_aips_ipm,
	&m68000_device::andi_b_imm8_pais_ipm,
	&m68000_device::andi_b_imm8_das_ipm,
	&m68000_device::andi_b_imm8_dais_ipm,
	&m68000_device::andi_b_imm8_adr16_ipm,
	&m68000_device::andi_b_imm8_adr32_ipm,
	&m68000_device::andi_imm8_ccr_ipm,
	&m68000_device::andi_w_imm16_ds_ipm,
	&m68000_device::andi_w_imm16_ais_ipm,
	&m68000_device::andi_w_imm16_aips_ipm,
	&m68000_device::andi_w_imm16_pais_ipm,
	&m68000_device::andi_w_imm16_das_ipm,
	&m68000_device::andi_w_imm16_dais_ipm,
	&m68000_device::andi_w_imm16_adr16_ipm,
	&m68000_device::andi_w_imm16_adr32_ipm,
	&m68000_device::andi_i16u_sr_ipm,
	&m68000_device::andi_l_imm32_ds_ipm,
	&m68000_device::andi_l_imm32_ais_ipm,
	&m68000_device::andi_l_imm32_aips_ipm,
	&m68000_device::andi_l_imm32_pais_ipm,
	&m68000_device::andi_l_imm32_das_ipm,
	&m68000_device::andi_l_imm32_dais_ipm,
	&m68000_device::andi_l_imm32_adr16_ipm,
	&m68000_device::andi_l_imm32_adr32_ipm,
	&m68000_device::subi_b_imm8_ds_ipm,
	&m68000_device::subi_b_imm8_ais_ipm,
	&m68000_device::subi_b_imm8_aips_ipm,
	&m68000_device::subi_b_imm8_pais_ipm,
	&m68000_device::subi_b_imm8_das_ipm,
	&m68000_device::subi_b_imm8_dais_ipm,
	&m68000_device::subi_b_imm8_adr16_ipm,
	&m68000_device::subi_b_imm8_adr32_ipm,
	&m68000_device::subi_w_imm16_ds_ipm,
	&m68000_device::subi_w_imm16_ais_ipm,
	&m68000_device::subi_w_imm16_aips_ipm,
	&m68000_device::subi_w_imm16_pais_ipm,
	&m68000_device::subi_w_imm16_das_ipm,
	&m68000_device::subi_w_imm16_dais_ipm,
	&m68000_device::subi_w_imm16_adr16_ipm,
	&m68000_device::subi_w_imm16_adr32_ipm,
	&m68000_device::subi_l_imm32_ds_ipm,
	&m68000_device::subi_l_imm32_ais_ipm,
	&m68000_device::subi_l_imm32_aips_ipm,
	&m68000_device::subi_l_imm32_pais_ipm,
	&m68000_device::subi_l_imm32_das_ipm,
	&m68000_device::subi_l_imm32_dais_ipm,
	&m68000_device::subi_l_imm32_adr16_ipm,
	&m68000_device::subi_l_imm32_adr32_ipm,
	&m68000_device::addi_b_imm8_ds_ipm,
	&m68000_device::addi_b_imm8_ais_ipm,
	&m68000_device::addi_b_imm8_aips_ipm,
	&m68000_device::addi_b_imm8_pais_ipm,
	&m68000_device::addi_b_imm8_das_ipm,
	&m68000_device::addi_b_imm8_dais_ipm,
	&m68000_device::addi_b_imm8_adr16_ipm,
	&m68000_device::addi_b_imm8_adr32_ipm,
	&m68000_device::addi_w_imm16_ds_ipm,
	&m68000_device::addi_w_imm16_ais_ipm,
	&m68000_device::addi_w_imm16_aips_ipm,
	&m68000_device::addi_w_imm16_pais_ipm,
	&m68000_device::addi_w_imm16_das_ipm,
	&m68000_device::addi_w_imm16_dais_ipm,
	&m68000_device::addi_w_imm16_adr16_ipm,
	&m68000_device::addi_w_imm16_adr32_ipm,
	&m68000_device::addi_l_imm32_ds_ipm,
	&m68000_device::addi_l_imm32_ais_ipm,
	&m68000_device::addi_l_imm32_aips_ipm,
	&m68000_device::addi_l_imm32_pais_ipm,
	&m68000_device::addi_l_imm32_das_ipm,
	&m68000_device::addi_l_imm32_dais_ipm,
	&m68000_device::addi_l_imm32_adr16_ipm,
	&m68000_device::addi_l_imm32_adr32_ipm,
	&m68000_device::btst_imm8_ds_ipm,
	&m68000_device::btst_imm8_ais_ipm,
	&m68000_device::btst_imm8_aips_ipm,
	&m68000_device::btst_imm8_pais_ipm,
	&m68000_device::btst_imm8_das_ipm,
	&m68000_device::btst_imm8_dais_ipm,
	&m68000_device::btst_imm8_adr16_ipm,
	&m68000_device::btst_imm8_adr32_ipm,
	&m68000_device::btst_imm8_dpc_ipm,
	&m68000_device::btst_imm8_dpci_ipm,
	&m68000_device::bchg_imm8_ds_ipm,
	&m68000_device::bchg_imm8_ais_ipm,
	&m68000_device::bchg_imm8_aips_ipm,
	&m68000_device::bchg_imm8_pais_ipm,
	&m68000_device::bchg_imm8_das_ipm,
	&m68000_device::bchg_imm8_dais_ipm,
	&m68000_device::bchg_imm8_adr16_ipm,
	&m68000_device::bchg_imm8_adr32_ipm,
	&m68000_device::bclr_imm8_ds_ipm,
	&m68000_device::bclr_imm8_ais_ipm,
	&m68000_device::bclr_imm8_aips_ipm,
	&m68000_device::bclr_imm8_pais_ipm,
	&m68000_device::bclr_imm8_das_ipm,
	&m68000_device::bclr_imm8_dais_ipm,
	&m68000_device::bclr_imm8_adr16_ipm,
	&m68000_device::bclr_imm8_adr32_ipm,
	&m68000_device::bset_imm8_ds_ipm,
	&m68000_device::bset_imm8_ais_ipm,
	&m68000_device::bset_imm8_aips_ipm,
	&m68000_device::bset_imm8_pais_ipm,
	&m68000_device::bset_imm8_das_ipm,
	&m68000_device::bset_imm8_dais_ipm,
	&m68000_device::bset_imm8_adr16_ipm,
	&m68000_device::bset_imm8_adr32_ipm,
	&m68000_device::eori_b_imm8_ds_ipm,
	&m68000_device::eori_b_imm8_ais_ipm,
	&m68000_device::eori_b_imm8_aips_ipm,
	&m68000_device::eori_b_imm8_pais_ipm,
	&m68000_device::eori_b_imm8_das_ipm,
	&m68000_device::eori_b_imm8_dais_ipm,
	&m68000_device::eori_b_imm8_adr16_ipm,
	&m68000_device::eori_b_imm8_adr32_ipm,
	&m68000_device::eori_imm8_ccr_ipm,
	&m68000_device::eori_w_imm16_ds_ipm,
	&m68000_device::eori_w_imm16_ais_ipm,
	&m68000_device::eori_w_imm16_aips_ipm,
	&m68000_device::eori_w_imm16_pais_ipm,
	&m68000_device::eori_w_imm16_das_ipm,
	&m68000_device::eori_w_imm16_dais_ipm,
	&m68000_device::eori_w_imm16_adr16_ipm,
	&m68000_device::eori_w_imm16_adr32_ipm,
	&m68000_device::eori_i16u_sr_ipm,
	&m68000_device::eori_l_imm32_ds_ipm,
	&m68000_device::eori_l_imm32_ais_ipm,
	&m68000_device::eori_l_imm32_aips_ipm,
	&m68000_device::eori_l_imm32_pais_ipm,
	&m68000_device::eori_l_imm32_das_ipm,
	&m68000_device::eori_l_imm32_dais_ipm,
	&m68000_device::eori_l_imm32_adr16_ipm,
	&m68000_device::eori_l_imm32_adr32_ipm,
	&m68000_device::cmpi_b_imm8_ds_ipm,
	&m68000_device::cmpi_b_imm8_ais_ipm,
	&m68000_device::cmpi_b_imm8_aips_ipm,
	&m68000_device::cmpi_b_imm8_pais_ipm,
	&m68000_device::cmpi_b_imm8_das_ipm,
	&m68000_device::cmpi_b_imm8_dais_ipm,
	&m68000_device::cmpi_b_imm8_adr16_ipm,
	&m68000_device::cmpi_b_imm8_adr32_ipm,
	&m68000_device::cmpi_w_imm16_ds_ipm,
	&m68000_device::cmpi_w_imm16_ais_ipm,
	&m68000_device::cmpi_w_imm16_aips_ipm,
	&m68000_device::cmpi_w_imm16_pais_ipm,
	&m68000_device::cmpi_w_imm16_das_ipm,
	&m68000_device::cmpi_w_imm16_dais_ipm,
	&m68000_device::cmpi_w_imm16_adr16_ipm,
	&m68000_device::cmpi_w_imm16_adr32_ipm,
	&m68000_device::cmpi_l_imm32_ds_ipm,
	&m68000_device::cmpi_l_imm32_ais_ipm,
	&m68000_device::cmpi_l_imm32_aips_ipm,
	&m68000_device::cmpi_l_imm32_pais_ipm,
	&m68000_device::cmpi_l_imm32_das_ipm,
	&m68000_device::cmpi_l_imm32_dais_ipm,
	&m68000_device::cmpi_l_imm32_adr16_ipm,
	&m68000_device::cmpi_l_imm32_adr32_ipm,
	&m68000_device::move_b_ds_dd_ipm,
	&m68000_device::move_b_ais_dd_ipm,
	&m68000_device::move_b_aips_dd_ipm,
	&m68000_device::move_b_pais_dd_ipm,
	&m68000_device::move_b_das_dd_ipm,
	&m68000_device::move_b_dais_dd_ipm,
	&m68000_device::move_b_adr16_dd_ipm,
	&m68000_device::move_b_adr32_dd_ipm,
	&m68000_device::move_b_dpc_dd_ipm,
	&m68000_device::move_b_dpci_dd_ipm,
	&m68000_device::move_b_imm8_dd_ipm,
	&m68000_device::move_b_ds_aid_ipm,
	&m68000_device::move_b_ais_aid_ipm,
	&m68000_device::move_b_aips_aid_ipm,
	&m68000_device::move_b_pais_aid_ipm,
	&m68000_device::move_b_das_aid_ipm,
	&m68000_device::move_b_dais_aid_ipm,
	&m68000_device::move_b_adr16_aid_ipm,
	&m68000_device::move_b_adr32_aid_ipm,
	&m68000_device::move_b_dpc_aid_ipm,
	&m68000_device::move_b_dpci_aid_ipm,
	&m68000_device::move_b_imm8_aid_ipm,
	&m68000_device::move_b_ds_aipd_ipm,
	&m68000_device::move_b_ais_aipd_ipm,
	&m68000_device::move_b_aips_aipd_ipm,
	&m68000_device::move_b_pais_aipd_ipm,
	&m68000_device::move_b_das_aipd_ipm,
	&m68000_device::move_b_dais_aipd_ipm,
	&m68000_device::move_b_adr16_aipd_ipm,
	&m68000_device::move_b_adr32_aipd_ipm,
	&m68000_device::move_b_dpc_aipd_ipm,
	&m68000_device::move_b_dpci_aipd_ipm,
	&m68000_device::move_b_imm8_aipd_ipm,
	&m68000_device::move_b_ds_paid_ipm,
	&m68000_device::move_b_ais_paid_ipm,
	&m68000_device::move_b_aips_paid_ipm,
	&m68000_device::move_b_pais_paid_ipm,
	&m68000_device::move_b_das_paid_ipm,
	&m68000_device::move_b_dais_paid_ipm,
	&m68000_device::move_b_adr16_paid_ipm,
	&m68000_device::move_b_adr32_paid_ipm,
	&m68000_device::move_b_dpc_paid_ipm,
	&m68000_device::move_b_dpci_paid_ipm,
	&m68000_device::move_b_imm8_paid_ipm,
	&m68000_device::move_b_ds_dad_ipm,
	&m68000_device::move_b_ais_dad_ipm,
	&m68000_device::move_b_aips_dad_ipm,
	&m68000_device::move_b_pais_dad_ipm,
	&m68000_device::move_b_das_dad_ipm,
	&m68000_device::move_b_dais_dad_ipm,
	&m68000_device::move_b_adr16_dad_ipm,
	&m68000_device::move_b_adr32_dad_ipm,
	&m68000_device::move_b_dpc_dad_ipm,
	&m68000_device::move_b_dpci_dad_ipm,
	&m68000_device::move_b_imm8_dad_ipm,
	&m68000_device::move_b_ds_daid_ipm,
	&m68000_device::move_b_ais_daid_ipm,
	&m68000_device::move_b_aips_daid_ipm,
	&m68000_device::move_b_pais_daid_ipm,
	&m68000_device::move_b_das_daid_ipm,
	&m68000_device::move_b_dais_daid_ipm,
	&m68000_device::move_b_adr16_daid_ipm,
	&m68000_device::move_b_adr32_daid_ipm,
	&m68000_device::move_b_dpc_daid_ipm,
	&m68000_device::move_b_dpci_daid_ipm,
	&m68000_device::move_b_imm8_daid_ipm,
	&m68000_device::move_b_ds_adr16_ipm,
	&m68000_device::move_b_ais_adr16_ipm,
	&m68000_device::move_b_aips_adr16_ipm,
	&m68000_device::move_b_pais_adr16_ipm,
	&m68000_device::move_b_das_adr16_ipm,
	&m68000_device::move_b_dais_adr16_ipm,
	&m68000_device::move_b_adr16_adr16_ipm,
	&m68000_device::move_b_adr32_adr16_ipm,
	&m68000_device::move_b_dpc_adr16_ipm,
	&m68000_device::move_b_dpci_adr16_ipm,
	&m68000_device::move_b_imm8_adr16_ipm,
	&m68000_device::move_b_ds_adr32_ipm,
	&m68000_device::move_b_ais_adr32_ipm,
	&m68000_device::move_b_aips_adr32_ipm,
	&m68000_device::move_b_pais_adr32_ipm,
	&m68000_device::move_b_das_adr32_ipm,
	&m68000_device::move_b_dais_adr32_ipm,
	&m68000_device::move_b_adr16_adr32_ipm,
	&m68000_device::move_b_adr32_adr32_ipm,
	&m68000_device::move_b_dpc_adr32_ipm,
	&m68000_device::move_b_dpci_adr32_ipm,
	&m68000_device::move_b_imm8_adr32_ipm,
	&m68000_device::move_l_ds_dd_ipm,
	&m68000_device::move_l_as_dd_ipm,
	&m68000_device::move_l_ais_dd_ipm,
	&m68000_device::move_l_aips_dd_ipm,
	&m68000_device::move_l_pais_dd_ipm,
	&m68000_device::move_l_das_dd_ipm,
	&m68000_device::move_l_dais_dd_ipm,
	&m68000_device::move_l_adr16_dd_ipm,
	&m68000_device::move_l_adr32_dd_ipm,
	&m68000_device::move_l_dpc_dd_ipm,
	&m68000_device::move_l_dpci_dd_ipm,
	&m68000_device::move_l_imm32_dd_ipm,
	&m68000_device::movea_l_ds_ad_ipm,
	&m68000_device::movea_l_as_ad_ipm,
	&m68000_device::movea_l_ais_ad_ipm,
	&m68000_device::movea_l_aips_ad_ipm,
	&m68000_device::movea_l_pais_ad_ipm,
	&m68000_device::movea_l_das_ad_ipm,
	&m68000_device::movea_l_dais_ad_ipm,
	&m68000_device::movea_l_adr16_ad_ipm,
	&m68000_device::movea_l_adr32_ad_ipm,
	&m68000_device::movea_l_dpc_ad_ipm,
	&m68000_device::movea_l_dpci_ad_ipm,
	&m68000_device::movea_l_imm32_ad_ipm,
	&m68000_device::move_l_ds_aid_ipm,
	&m68000_device::move_l_as_aid_ipm,
	&m68000_device::move_l_ais_aid_ipm,
	&m68000_device::move_l_aips_aid_ipm,
	&m68000_device::move_l_pais_aid_ipm,
	&m68000_device::move_l_das_aid_ipm,
	&m68000_device::move_l_dais_aid_ipm,
	&m68000_device::move_l_adr16_aid_ipm,
	&m68000_device::move_l_adr32_aid_ipm,
	&m68000_device::move_l_dpc_aid_ipm,
	&m68000_device::move_l_dpci_aid_ipm,
	&m68000_device::move_l_imm32_aid_ipm,
	&m68000_device::move_l_ds_aipd_ipm,
	&m68000_device::move_l_as_aipd_ipm,
	&m68000_device::move_l_ais_aipd_ipm,
	&m68000_device::move_l_aips_aipd_ipm,
	&m68000_device::move_l_pais_aipd_ipm,
	&m68000_device::move_l_das_aipd_ipm,
	&m68000_device::move_l_dais_aipd_ipm,
	&m68000_device::move_l_adr16_aipd_ipm,
	&m68000_device::move_l_adr32_aipd_ipm,
	&m68000_device::move_l_dpc_aipd_ipm,
	&m68000_device::move_l_dpci_aipd_ipm,
	&m68000_device::move_l_imm32_aipd_ipm,
	&m68000_device::move_l_ds_paid_ipm,
	&m68000_device::move_l_as_paid_ipm,
	&m68000_device::move_l_ais_paid_ipm,
	&m68000_device::move_l_aips_paid_ipm,
	&m68000_device::move_l_pais_paid_ipm,
	&m68000_device::move_l_das_paid_ipm,
	&m68000_device::move_l_dais_paid_ipm,
	&m68000_device::move_l_adr16_paid_ipm,
	&m68000_device::move_l_adr32_paid_ipm,
	&m68000_device::move_l_dpc_paid_ipm,
	&m68000_device::move_l_dpci_paid_ipm,
	&m68000_device::move_l_imm32_paid_ipm,
	&m68000_device::move_l_ds_dad_ipm,
	&m68000_device::move_l_as_dad_ipm,
	&m68000_device::move_l_ais_dad_ipm,
	&m68000_device::move_l_aips_dad_ipm,
	&m68000_device::move_l_pais_dad_ipm,
	&m68000_device::move_l_das_dad_ipm,
	&m68000_device::move_l_dais_dad_ipm,
	&m68000_device::move_l_adr16_dad_ipm,
	&m68000_device::move_l_adr32_dad_ipm,
	&m68000_device::move_l_dpc_dad_ipm,
	&m68000_device::move_l_dpci_dad_ipm,
	&m68000_device::move_l_imm32_dad_ipm,
	&m68000_device::move_l_ds_daid_ipm,
	&m68000_device::move_l_as_daid_ipm,
	&m68000_device::move_l_ais_daid_ipm,
	&m68000_device::move_l_aips_daid_ipm,
	&m68000_device::move_l_pais_daid_ipm,
	&m68000_device::move_l_das_daid_ipm,
	&m68000_device::move_l_dais_daid_ipm,
	&m68000_device::move_l_adr16_daid_ipm,
	&m68000_device::move_l_adr32_daid_ipm,
	&m68000_device::move_l_dpc_daid_ipm,
	&m68000_device::move_l_dpci_daid_ipm,
	&m68000_device::move_l_imm32_daid_ipm,
	&m68000_device::move_l_ds_adr16_ipm,
	&m68000_device::move_l_as_adr16_ipm,
	&m68000_device::move_l_ais_adr16_ipm,
	&m68000_device::move_l_aips_adr16_ipm,
	&m68000_device::move_l_pais_adr16_ipm,
	&m68000_device::move_l_das_adr16_ipm,
	&m68000_device::move_l_dais_adr16_ipm,
	&m68000_device::move_l_adr16_adr16_ipm,
	&m68000_device::move_l_adr32_adr16_ipm,
	&m68000_device::move_l_dpc_adr16_ipm,
	&m68000_device::move_l_dpci_adr16_ipm,
	&m68000_device::move_l_imm32_adr16_ipm,
	&m68000_device::move_l_ds_adr32_ipm,
	&m68000_device::move_l_as_adr32_ipm,
	&m68000_device::move_l_ais_adr32_ipm,
	&m68000_device::move_l_aips_adr32_ipm,
	&m68000_device::move_l_pais_adr32_ipm,
	&m68000_device::move_l_das_adr32_ipm,
	&m68000_device::move_l_dais_adr32_ipm,
	&m68000_device::move_l_adr16_adr32_ipm,
	&m68000_device::move_l_adr32_adr32_ipm,
	&m68000_device::move_l_dpc_adr32_ipm,
	&m68000_device::move_l_dpci_adr32_ipm,
	&m68000_device::move_l_imm32_adr32_ipm,
	&m68000_device::move_w_ds_dd_ipm,
	&m68000_device::move_w_as_dd_ipm,
	&m68000_device::move_w_ais_dd_ipm,
	&m68000_device::move_w_aips_dd_ipm,
	&m68000_device::move_w_pais_dd_ipm,
	&m68000_device::move_w_das_dd_ipm,
	&m68000_device::move_w_dais_dd_ipm,
	&m68000_device::move_w_adr16_dd_ipm,
	&m68000_device::move_w_adr32_dd_ipm,
	&m68000_device::move_w_dpc_dd_ipm,
	&m68000_device::move_w_dpci_dd_ipm,
	&m68000_device::move_w_imm16_dd_ipm,
	&m68000_device::movea_w_ds_ad_ipm,
	&m68000_device::movea_w_as_ad_ipm,
	&m68000_device::movea_w_ais_ad_ipm,
	&m68000_device::movea_w_aips_ad_ipm,
	&m68000_device::movea_w_pais_ad_ipm,
	&m68000_device::movea_w_das_ad_ipm,
	&m68000_device::movea_w_dais_ad_ipm,
	&m68000_device::movea_w_adr16_ad_ipm,
	&m68000_device::movea_w_adr32_ad_ipm,
	&m68000_device::movea_w_dpc_ad_ipm,
	&m68000_device::movea_w_dpci_ad_ipm,
	&m68000_device::movea_w_imm16_ad_ipm,
	&m68000_device::move_w_ds_aid_ipm,
	&m68000_device::move_w_as_aid_ipm,
	&m68000_device::move_w_ais_aid_ipm,
	&m68000_device::move_w_aips_aid_ipm,
	&m68000_device::move_w_pais_aid_ipm,
	&m68000_device::move_w_das_aid_ipm,
	&m68000_device::move_w_dais_aid_ipm,
	&m68000_device::move_w_adr16_aid_ipm,
	&m68000_device::move_w_adr32_aid_ipm,
	&m68000_device::move_w_dpc_aid_ipm,
	&m68000_device::move_w_dpci_aid_ipm,
	&m68000_device::move_w_imm16_aid_ipm,
	&m68000_device::move_w_ds_aipd_ipm,
	&m68000_device::move_w_as_aipd_ipm,
	&m68000_device::move_w_ais_aipd_ipm,
	&m68000_device::move_w_aips_aipd_ipm,
	&m68000_device::move_w_pais_aipd_ipm,
	&m68000_device::move_w_das_aipd_ipm,
	&m68000_device::move_w_dais_aipd_ipm,
	&m68000_device::move_w_adr16_aipd_ipm,
	&m68000_device::move_w_adr32_aipd_ipm,
	&m68000_device::move_w_dpc_aipd_ipm,
	&m68000_device::move_w_dpci_aipd_ipm,
	&m68000_device::move_w_imm16_aipd_ipm,
	&m68000_device::move_w_ds_paid_ipm,
	&m68000_device::move_w_as_paid_ipm,
	&m68000_device::move_w_ais_paid_ipm,
	&m68000_device::move_w_aips_paid_ipm,
	&m68000_device::move_w_pais_paid_ipm,
	&m68000_device::move_w_das_paid_ipm,
	&m68000_device::move_w_dais_paid_ipm,
	&m68000_device::move_w_adr16_paid_ipm,
	&m68000_device::move_w_adr32_paid_ipm,
	&m68000_device::move_w_dpc_paid_ipm,
	&m68000_device::move_w_dpci_paid_ipm,
	&m68000_device::move_w_imm16_paid_ipm,
	&m68000_device::move_w_ds_dad_ipm,
	&m68000_device::move_w_as_dad_ipm,
	&m68000_device::move_w_ais_dad_ipm,
	&m68000_device::move_w_aips_dad_ipm,
	&m68000_device::move_w_pais_dad_ipm,
	&m68000_device::move_w_das_dad_ipm,
	&m68000_device::move_w_dais_dad_ipm,
	&m68000_device::move_w_adr16_dad_ipm,
	&m68000_device::move_w_adr32_dad_ipm,
	&m68000_device::move_w_dpc_dad_ipm,
	&m68000_device::move_w_dpci_dad_ipm,
	&m68000_device::move_w_imm16_dad_ipm,
	&m68000_device::move_w_ds_daid_ipm,
	&m68000_device::move_w_as_daid_ipm,
	&m68000_device::move_w_ais_daid_ipm,
	&m68000_device::move_w_aips_daid_ipm,
	&m68000_device::move_w_pais_daid_ipm,
	&m68000_device::move_w_das_daid_ipm,
	&m68000_device::move_w_dais_daid_ipm,
	&m68000_device::move_w_adr16_daid_ipm,
	&m68000_device::move_w_adr32_daid_ipm,
	&m68000_device::move_w_dpc_daid_ipm,
	&m68000_device::move_w_dpci_daid_ipm,
	&m68000_device::move_w_imm16_daid_ipm,
	&m68000_device::move_w_ds_adr16_ipm,
	&m68000_device::move_w_as_adr16_ipm,
	&m68000_device::move_w_ais_adr16_ipm,
	&m68000_device::move_w_aips_adr16_ipm,
	&m68000_device::move_w_pais_adr16_ipm,
	&m68000_device::move_w_das_adr16_ipm,
	&m68000_device::move_w_dais_adr16_ipm,
	&m68000_device::move_w_adr16_adr16_ipm,
	&m68000_device::move_w_adr32_adr16_ipm,
	&m68000_device::move_w_dpc_adr16_ipm,
	&m68000_device::move_w_dpci_adr16_ipm,
	&m68000_device::move_w_imm16_adr16_ipm,
	&m68000_device::move_w_ds_adr32_ipm,
	&m68000_device::move_w_as_adr32_ipm,
	&m68000_device::move_w_ais_adr32_ipm,
	&m68000_device::move_w_aips_adr32_ipm,
	&m68000_device::move_w_pais_adr32_ipm,
	&m68000_device::move_w_das_adr32_ipm,
	&m68000_device::move_w_dais_adr32_ipm,
	&m68000_device::move_w_adr16_adr32_ipm,
	&m68000_device::move_w_adr32_adr32_ipm,
	&m68000_device::move_w_dpc_adr32_ipm,
	&m68000_device::move_w_dpci_adr32_ipm,
	&m68000_device::move_w_imm16_adr32_ipm,
	&m68000_device::negx_b_ds_ipm,
	&m68000_device::negx_b_ais_ipm,
	&m68000_device::negx_b_aips_ipm,
	&m68000_device::negx_b_pais_ipm,
	&m68000_device::negx_b_das_ipm,
	&m68000_device::negx_b_dais_ipm,
	&m68000_device::negx_b_adr16_ipm,
	&m68000_device::negx_b_adr32_ipm,
	&m68000_device::negx_w_ds_ipm,
	&m68000_device::negx_w_ais_ipm,
	&m68000_device::negx_w_aips_ipm,
	&m68000_device::negx_w_pais_ipm,
	&m68000_device::negx_w_das_ipm,
	&m68000_device::negx_w_dais_ipm,
	&m68000_device::negx_w_adr16_ipm,
	&m68000_device::negx_w_adr32_ipm,
	&m68000_device::negx_l_ds_ipm,
	&m68000_device::negx_l_ais_ipm,
	&m68000_device::negx_l_aips_ipm,
	&m68000_device::negx_l_pais_ipm,
	&m68000_device::negx_l_das_ipm,
	&m68000_device::negx_l_dais_ipm,
	&m68000_device::negx_l_adr16_ipm,
	&m68000_device::negx_l_adr32_ipm,
	&m68000_device::move_sr_ds_ipm,
	&m68000_device::move_sr_ais_ipm,
	&m68000_device::move_sr_aips_ipm,
	&m68000_device::move_sr_pais_ipm,
	&m68000_device::move_sr_das_ipm,
	&m68000_device::move_sr_dais_ipm,
	&m68000_device::move_sr_adr16_ipm,
	&m68000_device::move_sr_adr32_ipm,
	&m68000_device::chk_w_ds_dd_ipm,
	&m68000_device::chk_w_ais_dd_ipm,
	&m68000_device::chk_w_aips_dd_ipm,
	&m68000_device::chk_w_pais_dd_ipm,
	&m68000_device::chk_w_das_dd_ipm,
	&m68000_device::chk_w_dais_dd_ipm,
	&m68000_device::chk_w_adr16_dd_ipm,
	&m68000_device::chk_w_adr32_dd_ipm,
	&m68000_device::chk_w_dpc_dd_ipm,
	&m68000_device::chk_w_dpci_dd_ipm,
	&m68000_device::chk_w_imm16_dd_ipm,
	&m68000_device::lea_ais_ad_ipm,
	&m68000_device::lea_das_ad_ipm,
	&m68000_device::lea_dais_ad_ipm,
	&m68000_device::lea_adr16_ad_ipm,
	&m68000_device::lea_adr32_ad_ipm,
	&m68000_device::lea_dpc_ad_ipm,
	&m68000_device::lea_dpci_ad_ipm,
	&m68000_device::clr_b_ds_ipm,
	&m68000_device::clr_b_ais_ipm,
	&m68000_device::clr_b_aips_ipm,
	&m68000_device::clr_b_pais_ipm,
	&m68000_device::clr_b_das_ipm,
	&m68000_device::clr_b_dais_ipm,
	&m68000_device::clr_b_adr16_ipm,
	&m68000_device::clr_b_adr32_ipm,
	&m68000_device::clr_w_ds_ipm,
	&m68000_device::clr_w_ais_ipm,
	&m68000_device::clr_w_aips_ipm,
	&m68000_device::clr_w_pais_ipm,
	&m68000_device::clr_w_das_ipm,
	&m68000_device::clr_w_dais_ipm,
	&m68000_device::clr_w_adr16_ipm,
	&m68000_device::clr_w_adr32_ipm,
	&m68000_device::clr_l_ds_ipm,
	&m68000_device::clr_l_ais_ipm,
	&m68000_device::clr_l_aips_ipm,
	&m68000_device::clr_l_pais_ipm,
	&m68000_device::clr_l_das_ipm,
	&m68000_device::clr_l_dais_ipm,
	&m68000_device::clr_l_adr16_ipm,
	&m68000_device::clr_l_adr32_ipm,
	&m68000_device::neg_b_ds_ipm,
	&m68000_device::neg_b_ais_ipm,
	&m68000_device::neg_b_aips_ipm,
	&m68000_device::neg_b_pais_ipm,
	&m68000_device::neg_b_das_ipm,
	&m68000_device::neg_b_dais_ipm,
	&m68000_device::neg_b_adr16_ipm,
	&m68000_device::neg_b_adr32_ipm,
	&m68000_device::neg_w_ds_ipm,
	&m68000_device::neg_w_ais_ipm,
	&m68000_device::neg_w_aips_ipm,
	&m68000_device::neg_w_pais_ipm,
	&m68000_device::neg_w_das_ipm,
	&m68000_device::neg_w_dais_ipm,
	&m68000_device::neg_w_adr16_ipm,
	&m68000_device::neg_w_adr32_ipm,
	&m68000_device::neg_l_ds_ipm,
	&m68000_device::neg_l_ais_ipm,
	&m68000_device::neg_l_aips_ipm,
	&m68000_device::neg_l_pais_ipm,
	&m68000_device::neg_l_das_ipm,
	&m68000_device::neg_l_dais_ipm,
	&m68000_device::neg_l_adr16_ipm,
	&m68000_device::neg_l_adr32_ipm,
	&m68000_device::move_ds_ccr_ipm,
	&m68000_device::move_ais_ccr_ipm,
	&m68000_device::move_aips_ccr_ipm,
	&m68000_device::move_pais_ccr_ipm,
	&m68000_device::move_das_ccr_ipm,
	&m68000_device::move_dais_ccr_ipm,
	&m68000_device::move_adr16_ccr_ipm,
	&m68000_device::move_adr32_ccr_ipm,
	&m68000_device::move_dpc_ccr_ipm,
	&m68000_device::move_dpci_ccr_ipm,
	&m68000_device::move_imm8_ccr_ipm,
	&m68000_device::not_b_ds_ipm,
	&m68000_device::not_b_ais_ipm,
	&m68000_device::not_b_aips_ipm,
	&m68000_device::not_b_pais_ipm,
	&m68000_device::not_b_das_ipm,
	&m68000_device::not_b_dais_ipm,
	&m68000_device::not_b_adr16_ipm,
	&m68000_device::not_b_adr32_ipm,
	&m68000_device::not_w_ds_ipm,
	&m68000_device::not_w_ais_ipm,
	&m68000_device::not_w_aips_ipm,
	&m68000_device::not_w_pais_ipm,
	&m68000_device::not_w_das_ipm,
	&m68000_device::not_w_dais_ipm,
	&m68000_device::not_w_adr16_ipm,
	&m68000_device::not_w_adr32_ipm,
	&m68000_device::not_l_ds_ipm,
	&m68000_device::not_l_ais_ipm,
	&m68000_device::not_l_aips_ipm,
	&m68000_device::not_l_pais_ipm,
	&m68000_device::not_l_das_ipm,
	&m68000_device::not_l_dais_ipm,
	&m68000_device::not_l_adr16_ipm,
	&m68000_device::not_l_adr32_ipm,
	&m68000_device::move_ds_sr_ipm,
	&m68000_device::move_ais_sr_ipm,
	&m68000_device::move_aips_sr_ipm,
	&m68000_device::move_pais_sr_ipm,
	&m68000_device::move_das_sr_ipm,
	&m68000_device::move_dais_sr_ipm,
	&m68000_device::move_adr16_sr_ipm,
	&m68000_device::move_adr32_sr_ipm,
	&m68000_device::move_dpc_sr_ipm,
	&m68000_device::move_dpci_sr_ipm,
	&m68000_device::move_i16u_sr_ipm,
	&m68000_device::nbcd_b_ds_ipm,
	&m68000_device::nbcd_b_ais_ipm,
	&m68000_device::nbcd_b_aips_ipm,
	&m68000_device::nbcd_b_pais_ipm,
	&m68000_device::nbcd_b_das_ipm,
	&m68000_device::nbcd_b_dais_ipm,
	&m68000_device::nbcd_b_adr16_ipm,
	&m68000_device::nbcd_b_adr32_ipm,
	&m68000_device::swap_ds_ipm,
	&m68000_device::pea_ais_ipm,
	&m68000_device::pea_das_ipm,
	&m68000_device::pea_dais_ipm,
	&m68000_device::pea_adr16_ipm,
	&m68000_device::pea_adr32_ipm,
	&m68000_device::pea_dpc_ipm,
	&m68000_device::pea_dpci_ipm,
	&m68000_device::ext_w_ds_ipm,
	&m68000_device::movem_w_list_ais_ipm,
	&m68000_device::movem_w_listp_pais_ipm,
	&m68000_device::movem_w_list_das_ipm,
	&m68000_device::movem_w_list_dais_ipm,
	&m68000_device::movem_w_list_adr16_ipm,
	&m68000_device::movem_w_list_adr32_ipm,
	&m68000_device::ext_l_ds_ipm,
	&m68000_device::movem_l_list_ais_ipm,
	&m68000_device::movem_l_listp_pais_ipm,
	&m68000_device::movem_l_list_das_ipm,
	&m68000_device::movem_l_list_dais_ipm,
	&m68000_device::movem_l_list_adr16_ipm,
	&m68000_device::movem_l_list_adr32_ipm,
	&m68000_device::tst_b_ds_ipm,
	&m68000_device::tst_b_ais_ipm,
	&m68000_device::tst_b_aips_ipm,
	&m68000_device::tst_b_pais_ipm,
	&m68000_device::tst_b_das_ipm,
	&m68000_device::tst_b_dais_ipm,
	&m68000_device::tst_b_adr16_ipm,
	&m68000_device::tst_b_adr32_ipm,
	&m68000_device::tst_w_ds_ipm,
	&m68000_device::tst_w_ais_ipm,
	&m68000_device::tst_w_aips_ipm,
	&m68000_device::tst_w_pais_ipm,
	&m68000_device::tst_w_das_ipm,
	&m68000_device::tst_w_dais_ipm,
	&m68000_device::tst_w_adr16_ipm,
	&m68000_device::tst_w_adr32_ipm,
	&m68000_device::tst_l_ds_ipm,
	&m68000_device::tst_l_ais_ipm,
	&m68000_device::tst_l_aips_ipm,
	&m68000_device::tst_l_pais_ipm,
	&m68000_device::tst_l_das_ipm,
	&m68000_device::tst_l_dais_ipm,
	&m68000_device::tst_l_adr16_ipm,
	&m68000_device::tst_l_adr32_ipm,
	&m68000_device::tas_ds_ipm,
	&m68000_device::tas_ais_ipm,
	&m68000_device::tas_aips_ipm,
	&m68000_device::tas_pais_ipm,
	&m68000_device::tas_das_ipm,
	&m68000_device::tas_dais_ipm,
	&m68000_device::tas_adr16_ipm,
	&m68000_device::tas_adr32_ipm,
	&m68000_device::movem_w_ais_list_ipm,
	&m68000_device::movem_w_aips_list_ipm,
	&m68000_device::movem_w_das_list_ipm,
	&m68000_device::movem_w_dais_list_ipm,
	&m68000_device::movem_w_adr16_list_ipm,
	&m68000_device::movem_w_adr32_list_ipm,
	&m68000_device::movem_w_dpc_list_ipm,
	&m68000_device::movem_w_dpci_list_ipm,
	&m68000_device::movem_l_ais_list_ipm,
	&m68000_device::movem_l_aips_list_ipm,
	&m68000_device::movem_l_das_list_ipm,
	&m68000_device::movem_l_dais_list_ipm,
	&m68000_device::movem_l_adr16_list_ipm,
	&m68000_device::movem_l_adr32_list_ipm,
	&m68000_device::movem_l_dpc_list_ipm,
	&m68000_device::movem_l_dpci_list_ipm,
	&m68000_device::trap_imm4_ipm,
	&m68000_device::link_as_imm16_ipm,
	&m68000_device::unlk_as_ipm,
	&m68000_device::move_as_usp_ipm,
	&m68000_device::move_usp_as_ipm,
	&m68000_device::reset_ipm,
	&m68000_device::nop_ipm,
	&m68000_device::stop_i16u_ipm,
	&m68000_device::rte_ipm,
	&m68000_device::rts_ipm,
	&m68000_device::trapv_ipm,
	&m68000_device::rtr_ipm,
	&m68000_device::jsr_ais_ipm,
	&m68000_device::jsr_das_ipm,
	&m68000_device::jsr_dais_ipm,
	&m68000_device::jsr_adr16_ipm,
	&m68000_device::jsr_adr32_ipm,
	&m68000_device::jsr_dpc_ipm,
	&m68000_device::jsr_dpci_ipm,
	&m68000_device::jmp_ais_ipm,
	&m68000_device::jmp_das_ipm,
	&m68000_device::jmp_dais_ipm,
	&m68000_device::jmp_adr16_ipm,
	&m68000_device::jmp_adr32_ipm,
	&m68000_device::jmp_dpc_ipm,
	&m68000_device::jmp_dpci_ipm,
	&m68000_device::addq_b_imm3_ds_ipm,
	&m68000_device::addq_b_imm3_ais_ipm,
	&m68000_device::addq_b_imm3_aips_ipm,
	&m68000_device::addq_b_imm3_pais_ipm,
	&m68000_device::addq_b_imm3_das_ipm,
	&m68000_device::addq_b_imm3_dais_ipm,
	&m68000_device::addq_b_imm3_adr16_ipm,
	&m68000_device::addq_b_imm3_adr32_ipm,
	&m68000_device::addq_w_imm3_ds_ipm,
	&m68000_device::addq_w_imm3_as_ipm,
	&m68000_device::addq_w_imm3_ais_ipm,
	&m68000_device::addq_w_imm3_aips_ipm,
	&m68000_device::addq_w_imm3_pais_ipm,
	&m68000_device::addq_w_imm3_das_ipm,
	&m68000_device::addq_w_imm3_dais_ipm,
	&m68000_device::addq_w_imm3_adr16_ipm,
	&m68000_device::addq_w_imm3_adr32_ipm,
	&m68000_device::addq_l_imm3_ds_ipm,
	&m68000_device::addq_l_imm3_as_ipm,
	&m68000_device::addq_l_imm3_ais_ipm,
	&m68000_device::addq_l_imm3_aips_ipm,
	&m68000_device::addq_l_imm3_pais_ipm,
	&m68000_device::addq_l_imm3_das_ipm,
	&m68000_device::addq_l_imm3_dais_ipm,
	&m68000_device::addq_l_imm3_adr16_ipm,
	&m68000_device::addq_l_imm3_adr32_ipm,
	&m68000_device::st_ds_ipm,
	&m68000_device::dbt_ds_rel16_ipm,
	&m68000_device::st_ais_ipm,
	&m68000_device::st_aips_ipm,
	&m68000_device::st_pais_ipm,
	&m68000_device::st_das_ipm,
	&m68000_device::st_dais_ipm,
	&m68000_device::st_adr16_ipm,
	&m68000_device::st_adr32_ipm,
	&m68000_device::subq_b_imm3_ds_ipm,
	&m68000_device::subq_b_imm3_ais_ipm,
	&m68000_device::subq_b_imm3_aips_ipm,
	&m68000_device::subq_b_imm3_pais_ipm,
	&m68000_device::subq_b_imm3_das_ipm,
	&m68000_device::subq_b_imm3_dais_ipm,
	&m68000_device::subq_b_imm3_adr16_ipm,
	&m68000_device::subq_b_imm3_adr32_ipm,
	&m68000_device::subq_w_imm3_ds_ipm,
	&m68000_device::subq_w_imm3_as_ipm,
	&m68000_device::subq_w_imm3_ais_ipm,
	&m68000_device::subq_w_imm3_aips_ipm,
	&m68000_device::subq_w_imm3_pais_ipm,
	&m68000_device::subq_w_imm3_das_ipm,
	&m68000_device::subq_w_imm3_dais_ipm,
	&m68000_device::subq_w_imm3_adr16_ipm,
	&m68000_device::subq_w_imm3_adr32_ipm,
	&m68000_device::subq_l_imm3_ds_ipm,
	&m68000_device::subq_l_imm3_as_ipm,
	&m68000_device::subq_l_imm3_ais_ipm,
	&m68000_device::subq_l_imm3_aips_ipm,
	&m68000_device::subq_l_imm3_pais_ipm,
	&m68000_device::subq_l_imm3_das_ipm,
	&m68000_device::subq_l_imm3_dais_ipm,
	&m68000_device::subq_l_imm3_adr16_ipm,
	&m68000_device::subq_l_imm3_adr32_ipm,
	&m68000_device::sf_ds_ipm,
	&m68000_device::dbra_ds_rel16_ipm,
	&m68000_device::sf_ais_ipm,
	&m68000_device::sf_aips_ipm,
	&m68000_device::sf_pais_ipm,
	&m68000_device::sf_das_ipm,
	&m68000_device::sf_dais_ipm,
	&m68000_device::sf_adr16_ipm,
	&m68000_device::sf_adr32_ipm,
	&m68000_device::shi_ds_ipm,
	&m68000_device::dbhi_ds_rel16_ipm,
	&m68000_device::shi_ais_ipm,
	&m68000_device::shi_aips_ipm,
	&m68000_device::shi_pais_ipm,
	&m68000_device::shi_das_ipm,
	&m68000_device::shi_dais_ipm,
	&m68000_device::shi_adr16_ipm,
	&m68000_device::shi_adr32_ipm,
	&m68000_device::sls_ds_ipm,
	&m68000_device::dbls_ds_rel16_ipm,
	&m68000_device::sls_ais_ipm,
	&m68000_device::sls_aips_ipm,
	&m68000_device::sls_pais_ipm,
	&m68000_device::sls_das_ipm,
	&m68000_device::sls_dais_ipm,
	&m68000_device::sls_adr16_ipm,
	&m68000_device::sls_adr32_ipm,
	&m68000_device::scc_ds_ipm,
	&m68000_device::dbcc_ds_rel16_ipm,
	&m68000_device::scc_ais_ipm,
	&m68000_device::scc_aips_ipm,
	&m68000_device::scc_pais_ipm,
	&m68000_device::scc_das_ipm,
	&m68000_device::scc_dais_ipm,
	&m68000_device::scc_adr16_ipm,
	&m68000_device::scc_adr32_ipm,
	&m68000_device::scs_ds_ipm,
	&m68000_device::dbcs_ds_rel16_ipm,
	&m68000_device::scs_ais_ipm,
	&m68000_device::scs_aips_ipm,
	&m68000_device::scs_pais_ipm,
	&m68000_device::scs_das_ipm,
	&m68000_device::scs_dais_ipm,
	&m68000_device::scs_adr16_ipm,
	&m68000_device::scs_adr32_ipm,
	&m68000_device::sne_ds_ipm,
	&m68000_device::dbne_ds_rel16_ipm,
	&m68000_device::sne_ais_ipm,
	&m68000_device::sne_aips_ipm,
	&m68000_device::sne_pais_ipm,
	&m68000_device::sne_das_ipm,
	&m68000_device::sne_dais_ipm,
	&m68000_device::sne_adr16_ipm,
	&m68000_device::sne_adr32_ipm,
	&m68000_device::seq_ds_ipm,
	&m68000_device::dbeq_ds_rel16_ipm,
	&m68000_device::seq_ais_ipm,
	&m68000_device::seq_aips_ipm,
	&m68000_device::seq_pais_ipm,
	&m68000_device::seq_das_ipm,
	&m68000_device::seq_dais_ipm,
	&m68000_device::seq_adr16_ipm,
	&m68000_device::seq_adr32_ipm,
	&m68000_device::svc_ds_ipm,
	&m68000_device::dbvc_ds_rel16_ipm,
	&m68000_device::svc_ais_ipm,
	&m68000_device::svc_aips_ipm,
	&m68000_device::svc_pais_ipm,
	&m68000_device::svc_das_ipm,
	&m68000_device::svc_dais_ipm,
	&m68000_device::svc_adr16_ipm,
	&m68000_device::svc_adr32_ipm,
	&m68000_device::svs_ds_ipm,
	&m68000_device::dbvs_ds_rel16_ipm,
	&m68000_device::svs_ais_ipm,
	&m68000_device::svs_aips_ipm,
	&m68000_device::svs_pais_ipm,
	&m68000_device::svs_das_ipm,
	&m68000_device::svs_dais_ipm,
	&m68000_device::svs_adr16_ipm,
	&m68000_device::svs_adr32_ipm,
	&m68000_device::spl_ds_ipm,
	&m68000_device::dbpl_ds_rel16_ipm,
	&m68000_device::spl_ais_ipm,
	&m68000_device::spl_aips_ipm,
	&m68000_device::spl_pais_ipm,
	&m68000_device::spl_das_ipm,
	&m68000_device::spl_dais_ipm,
	&m68000_device::spl_adr16_ipm,
	&m68000_device::spl_adr32_ipm,
	&m68000_device::smi_ds_ipm,
	&m68000_device::dbmi_ds_rel16_ipm,
	&m68000_device::smi_ais_ipm,
	&m68000_device::smi_aips_ipm,
	&m68000_device::smi_pais_ipm,
	&m68000_device::smi_das_ipm,
	&m68000_device::smi_dais_ipm,
	&m68000_device::smi_adr16_ipm,
	&m68000_device::smi_adr32_ipm,
	&m68000_device::sge_ds_ipm,
	&m68000_device::dbge_ds_rel16_ipm,
	&m68000_device::sge_ais_ipm,
	&m68000_device::sge_aips_ipm,
	&m68000_device::sge_pais_ipm,
	&m68000_device::sge_das_ipm,
	&m68000_device::sge_dais_ipm,
	&m68000_device::sge_adr16_ipm,
	&m68000_device::sge_adr32_ipm,
	&m68000_device::slt_ds_ipm,
	&m68000_device::dblt_ds_rel16_ipm,
	&m68000_device::slt_ais_ipm,
	&m68000_device::slt_aips_ipm,
	&m68000_device::slt_pais_ipm,
	&m68000_device::slt_das_ipm,
	&m68000_device::slt_dais_ipm,
	&m68000_device::slt_adr16_ipm,
	&m68000_device::slt_adr32_ipm,
	&m68000_device::sgt_ds_ipm,
	&m68000_device::dbgt_ds_rel16_ipm,
	&m68000_device::sgt_ais_ipm,
	&m68000_device::sgt_aips_ipm,
	&m68000_device::sgt_pais_ipm,
	&m68000_device::sgt_das_ipm,
	&m68000_device::sgt_dais_ipm,
	&m68000_device::sgt_adr16_ipm,
	&m68000_device::sgt_adr32_ipm,
	&m68000_device::sle_ds_ipm,
	&m68000_device::dble_ds_rel16_ipm,
	&m68000_device::sle_ais_ipm,
	&m68000_device::sle_aips_ipm,
	&m68000_device::sle_pais_ipm,
	&m68000_device::sle_das_ipm,
	&m68000_device::sle_dais_ipm,
	&m68000_device::sle_adr16_ipm,
	&m68000_device::sle_adr32_ipm,
	&m68000_device::bra_rel16_ipm,
	&m68000_device::bra_rel8_ipm,
	&m68000_device::bsr_rel16_ipm,
	&m68000_device::bsr_rel8_ipm,
	&m68000_device::bhi_rel16_ipm,
	&m68000_device::bhi_rel8_ipm,
	&m68000_device::bls_rel16_ipm,
	&m68000_device::bls_rel8_ipm,
	&m68000_device::bcc_rel16_ipm,
	&m68000_device::bcc_rel8_ipm,
	&m68000_device::bcs_rel16_ipm,
	&m68000_device::bcs_rel8_ipm,
	&m68000_device::bne_rel16_ipm,
	&m68000_device::bne_rel8_ipm,
	&m68000_device::beq_rel16_ipm,
	&m68000_device::beq_rel8_ipm,
	&m68000_device::bvc_rel16_ipm,
	&m68000_device::bvc_rel8_ipm,
	&m68000_device::bvs_rel16_ipm,
	&m68000_device::bvs_rel8_ipm,
	&m68000_device::bpl_rel16_ipm,
	&m68000_device::bpl_rel8_ipm,
	&m68000_device::bmi_rel16_ipm,
	&m68000_device::bmi_rel8_ipm,
	&m68000_device::bge_rel16_ipm,
	&m68000_device::bge_rel8_ipm,
	&m68000_device::blt_rel16_ipm,
	&m68000_device::blt_rel8_ipm,
	&m68000_device::bgt_rel16_ipm,
	&m68000_device::bgt_rel8_ipm,
	&m68000_device::ble_rel16_ipm,
	&m68000_device::ble_rel8_ipm,
	&m68000_device::moveq_imm8o_dd_ipm,
	&m68000_device::or_b_ds_dd_ipm,
	&m68000_device::or_b_ais_dd_ipm,
	&m68000_device::or_b_aips_dd_ipm,
	&m68000_device::or_b_pais_dd_ipm,
	&m68000_device::or_b_das_dd_ipm,
	&m68000_device::or_b_dais_dd_ipm,
	&m68000_device::or_b_adr16_dd_ipm,
	&m68000_device::or_b_adr32_dd_ipm,
	&m68000_device::or_b_dpc_dd_ipm,
	&m68000_device::or_b_dpci_dd_ipm,
	&m68000_device::or_b_imm8_dd_ipm,
	&m68000_device::or_w_ds_dd_ipm,
	&m68000_device::or_w_ais_dd_ipm,
	&m68000_device::or_w_aips_dd_ipm,
	&m68000_device::or_w_pais_dd_ipm,
	&m68000_device::or_w_das_dd_ipm,
	&m68000_device::or_w_dais_dd_ipm,
	&m68000_device::or_w_adr16_dd_ipm,
	&m68000_device::or_w_adr32_dd_ipm,
	&m68000_device::or_w_dpc_dd_ipm,
	&m68000_device::or_w_dpci_dd_ipm,
	&m68000_device::or_w_imm16_dd_ipm,
	&m68000_device::or_l_ds_dd_ipm,
	&m68000_device::or_l_ais_dd_ipm,
	&m68000_device::or_l_aips_dd_ipm,
	&m68000_device::or_l_pais_dd_ipm,
	&m68000_device::or_l_das_dd_ipm,
	&m68000_device::or_l_dais_dd_ipm,
	&m68000_device::or_l_adr16_dd_ipm,
	&m68000_device::or_l_adr32_dd_ipm,
	&m68000_device::or_l_dpc_dd_ipm,
	&m68000_device::or_l_dpci_dd_ipm,
	&m68000_device::or_l_imm32_dd_ipm,
	&m68000_device::divu_w_ds_dd_ipm,
	&m68000_device::divu_w_ais_dd_ipm,
	&m68000_device::divu_w_aips_dd_ipm,
	&m68000_device::divu_w_pais_dd_ipm,
	&m68000_device::divu_w_das_dd_ipm,
	&m68000_device::divu_w_dais_dd_ipm,
	&m68000_device::divu_w_adr16_dd_ipm,
	&m68000_device::divu_w_adr32_dd_ipm,
	&m68000_device::divu_w_dpc_dd_ipm,
	&m68000_device::divu_w_dpci_dd_ipm,
	&m68000_device::divu_w_imm16_dd_ipm,
	&m68000_device::sbcd_ds_dd_ipm,
	&m68000_device::sbcd_pais_paid_ipm,
	&m68000_device::or_b_dd_ais_ipm,
	&m68000_device::or_b_dd_aips_ipm,
	&m68000_device::or_b_dd_pais_ipm,
	&m68000_device::or_b_dd_das_ipm,
	&m68000_device::or_b_dd_dais_ipm,
	&m68000_device::or_b_dd_adr16_ipm,
	&m68000_device::or_b_dd_adr32_ipm,
	&m68000_device::or_w_dd_ais_ipm,
	&m68000_device::or_w_dd_aips_ipm,
	&m68000_device::or_w_dd_pais_ipm,
	&m68000_device::or_w_dd_das_ipm,
	&m68000_device::or_w_dd_dais_ipm,
	&m68000_device::or_w_dd_adr16_ipm,
	&m68000_device::or_w_dd_adr32_ipm,
	&m68000_device::or_l_dd_ais_ipm,
	&m68000_device::or_l_dd_aips_ipm,
	&m68000_device::or_l_dd_pais_ipm,
	&m68000_device::or_l_dd_das_ipm,
	&m68000_device::or_l_dd_dais_ipm,
	&m68000_device::or_l_dd_adr16_ipm,
	&m68000_device::or_l_dd_adr32_ipm,
	&m68000_device::divs_w_ds_dd_ipm,
	&m68000_device::divs_w_ais_dd_ipm,
	&m68000_device::divs_w_aips_dd_ipm,
	&m68000_device::divs_w_pais_dd_ipm,
	&m68000_device::divs_w_das_dd_ipm,
	&m68000_device::divs_w_dais_dd_ipm,
	&m68000_device::divs_w_adr16_dd_ipm,
	&m68000_device::divs_w_adr32_dd_ipm,
	&m68000_device::divs_w_dpc_dd_ipm,
	&m68000_device::divs_w_dpci_dd_ipm,
	&m68000_device::divs_w_imm16_dd_ipm,
	&m68000_device::sub_b_ds_dd_ipm,
	&m68000_device::sub_b_ais_dd_ipm,
	&m68000_device::sub_b_aips_dd_ipm,
	&m68000_device::sub_b_pais_dd_ipm,
	&m68000_device::sub_b_das_dd_ipm,
	&m68000_device::sub_b_dais_dd_ipm,
	&m68000_device::sub_b_adr16_dd_ipm,
	&m68000_device::sub_b_adr32_dd_ipm,
	&m68000_device::sub_b_dpc_dd_ipm,
	&m68000_device::sub_b_dpci_dd_ipm,
	&m68000_device::sub_b_imm8_dd_ipm,
	&m68000_device::sub_w_ds_dd_ipm,
	&m68000_device::sub_w_as_dd_ipm,
	&m68000_device::sub_w_ais_dd_ipm,
	&m68000_device::sub_w_aips_dd_ipm,
	&m68000_device::sub_w_pais_dd_ipm,
	&m68000_device::sub_w_das_dd_ipm,
	&m68000_device::sub_w_dais_dd_ipm,
	&m68000_device::sub_w_adr16_dd_ipm,
	&m68000_device::sub_w_adr32_dd_ipm,
	&m68000_device::sub_w_dpc_dd_ipm,
	&m68000_device::sub_w_dpci_dd_ipm,
	&m68000_device::sub_w_imm16_dd_ipm,
	&m68000_device::sub_l_ds_dd_ipm,
	&m68000_device::sub_l_as_dd_ipm,
	&m68000_device::sub_l_ais_dd_ipm,
	&m68000_device::sub_l_aips_dd_ipm,
	&m68000_device::sub_l_pais_dd_ipm,
	&m68000_device::sub_l_das_dd_ipm,
	&m68000_device::sub_l_dais_dd_ipm,
	&m68000_device::sub_l_adr16_dd_ipm,
	&m68000_device::sub_l_adr32_dd_ipm,
	&m68000_device::sub_l_dpc_dd_ipm,
	&m68000_device::sub_l_dpci_dd_ipm,
	&m68000_device::sub_l_imm32_dd_ipm,
	&m68000_device::suba_w_ds_ad_ipm,
	&m68000_device::suba_w_as_ad_ipm,
	&m68000_device::suba_w_ais_ad_ipm,
	&m68000_device::suba_w_aips_ad_ipm,
	&m68000_device::suba_w_pais_ad_ipm,
	&m68000_device::suba_w_das_ad_ipm,
	&m68000_device::suba_w_dais_ad_ipm,
	&m68000_device::suba_w_adr16_ad_ipm,
	&m68000_device::suba_w_adr32_ad_ipm,
	&m68000_device::suba_w_dpc_ad_ipm,
	&m68000_device::suba_w_dpci_ad_ipm,
	&m68000_device::suba_w_imm16_ad_ipm,
	&m68000_device::subx_b_ds_dd_ipm,
	&m68000_device::subx_b_pais_paid_ipm,
	&m68000_device::sub_b_dd_ais_ipm,
	&m68000_device::sub_b_dd_aips_ipm,
	&m68000_device::sub_b_dd_pais_ipm,
	&m68000_device::sub_b_dd_das_ipm,
	&m68000_device::sub_b_dd_dais_ipm,
	&m68000_device::sub_b_dd_adr16_ipm,
	&m68000_device::sub_b_dd_adr32_ipm,
	&m68000_device::subx_w_ds_dd_ipm,
	&m68000_device::subx_w_pais_paid_ipm,
	&m68000_device::sub_w_dd_ais_ipm,
	&m68000_device::sub_w_dd_aips_ipm,
	&m68000_device::sub_w_dd_pais_ipm,
	&m68000_device::sub_w_dd_das_ipm,
	&m68000_device::sub_w_dd_dais_ipm,
	&m68000_device::sub_w_dd_adr16_ipm,
	&m68000_device::sub_w_dd_adr32_ipm,
	&m68000_device::subx_l_ds_dd_ipm,
	&m68000_device::subx_l_pais_paid_ipm,
	&m68000_device::sub_l_dd_ais_ipm,
	&m68000_device::sub_l_dd_aips_ipm,
	&m68000_device::sub_l_dd_pais_ipm,
	&m68000_device::sub_l_dd_das_ipm,
	&m68000_device::sub_l_dd_dais_ipm,
	&m68000_device::sub_l_dd_adr16_ipm,
	&m68000_device::sub_l_dd_adr32_ipm,
	&m68000_device::suba_l_ds_ad_ipm,
	&m68000_device::suba_l_as_ad_ipm,
	&m68000_device::suba_l_ais_ad_ipm,
	&m68000_device::suba_l_aips_ad_ipm,
	&m68000_device::suba_l_pais_ad_ipm,
	&m68000_device::suba_l_das_ad_ipm,
	&m68000_device::suba_l_dais_ad_ipm,
	&m68000_device::suba_l_adr16_ad_ipm,
	&m68000_device::suba_l_adr32_ad_ipm,
	&m68000_device::suba_l_dpc_ad_ipm,
	&m68000_device::suba_l_dpci_ad_ipm,
	&m68000_device::suba_l_imm32_ad_ipm,
	&m68000_device::cmp_b_ds_dd_ipm,
	&m68000_device::cmp_b_ais_dd_ipm,
	&m68000_device::cmp_b_aips_dd_ipm,
	&m68000_device::cmp_b_pais_dd_ipm,
	&m68000_device::cmp_b_das_dd_ipm,
	&m68000_device::cmp_b_dais_dd_ipm,
	&m68000_device::cmp_b_adr16_dd_ipm,
	&m68000_device::cmp_b_adr32_dd_ipm,
	&m68000_device::cmp_b_dpc_dd_ipm,
	&m68000_device::cmp_b_dpci_dd_ipm,
	&m68000_device::cmp_b_imm8_dd_ipm,
	&m68000_device::cmp_w_ds_dd_ipm,
	&m68000_device::cmp_w_as_dd_ipm,
	&m68000_device::cmp_w_ais_dd_ipm,
	&m68000_device::cmp_w_aips_dd_ipm,
	&m68000_device::cmp_w_pais_dd_ipm,
	&m68000_device::cmp_w_das_dd_ipm,
	&m68000_device::cmp_w_dais_dd_ipm,
	&m68000_device::cmp_w_adr16_dd_ipm,
	&m68000_device::cmp_w_adr32_dd_ipm,
	&m68000_device::cmp_w_dpc_dd_ipm,
	&m68000_device::cmp_w_dpci_dd_ipm,
	&m68000_device::cmp_w_imm16_dd_ipm,
	&m68000_device::cmp_l_ds_dd_ipm,
	&m68000_device::cmp_l_as_dd_ipm,
	&m68000_device::cmp_l_ais_dd_ipm,
	&m68000_device::cmp_l_aips_dd_ipm,
	&m68000_device::cmp_l_pais_dd_ipm,
	&m68000_device::cmp_l_das_dd_ipm,
	&m68000_device::cmp_l_dais_dd_ipm,
	&m68000_device::cmp_l_adr16_dd_ipm,
	&m68000_device::cmp_l_adr32_dd_ipm,
	&m68000_device::cmp_l_dpc_dd_ipm,
	&m68000_device::cmp_l_dpci_dd_ipm,
	&m68000_device::cmp_l_imm32_dd_ipm,
	&m68000_device::cmpa_w_ds_ad_ipm,
	&m68000_device::cmpa_w_as_ad_ipm,
	&m68000_device::cmpa_w_ais_ad_ipm,
	&m68000_device::cmpa_w_aips_ad_ipm,
	&m68000_device::cmpa_w_pais_ad_ipm,
	&m68000_device::cmpa_w_das_ad_ipm,
	&m68000_device::cmpa_w_dais_ad_ipm,
	&m68000_device::cmpa_w_adr16_ad_ipm,
	&m68000_device::cmpa_w_adr32_ad_ipm,
	&m68000_device::cmpa_w_dpc_ad_ipm,
	&m68000_device::cmpa_w_dpci_ad_ipm,
	&m68000_device::cmpa_w_imm16_ad_ipm,
	&m68000_device::eor_b_dd_ds_ipm,
	&m68000_device::cmpm_b_aips_aipd_ipm,
	&m68000_device::eor_b_dd_ais_ipm,
	&m68000_device::eor_b_dd_aips_ipm,
	&m68000_device::eor_b_dd_pais_ipm,
	&m68000_device::eor_b_dd_das_ipm,
	&m68000_device::eor_b_dd_dais_ipm,
	&m68000_device::eor_b_dd_adr16_ipm,
	&m68000_device::eor_b_dd_adr32_ipm,
	&m68000_device::eor_w_dd_ds_ipm,
	&m68000_device::cmpm_w_aips_aipd_ipm,
	&m68000_device::eor_w_dd_ais_ipm,
	&m68000_device::eor_w_dd_aips_ipm,
	&m68000_device::eor_w_dd_pais_ipm,
	&m68000_device::eor_w_dd_das_ipm,
	&m68000_device::eor_w_dd_dais_ipm,
	&m68000_device::eor_w_dd_adr16_ipm,
	&m68000_device::eor_w_dd_adr32_ipm,
	&m68000_device::eor_l_dd_ds_ipm,
	&m68000_device::cmpm_l_aips_aipd_ipm,
	&m68000_device::eor_l_dd_ais_ipm,
	&m68000_device::eor_l_dd_aips_ipm,
	&m68000_device::eor_l_dd_pais_ipm,
	&m68000_device::eor_l_dd_das_ipm,
	&m68000_device::eor_l_dd_dais_ipm,
	&m68000_device::eor_l_dd_adr16_ipm,
	&m68000_device::eor_l_dd_adr32_ipm,
	&m68000_device::cmpa_l_ds_ad_ipm,
	&m68000_device::cmpa_l_as_ad_ipm,
	&m68000_device::cmpa_l_ais_ad_ipm,
	&m68000_device::cmpa_l_aips_ad_ipm,
	&m68000_device::cmpa_l_pais_ad_ipm,
	&m68000_device::cmpa_l_das_ad_ipm,
	&m68000_device::cmpa_l_dais_ad_ipm,
	&m68000_device::cmpa_l_adr16_ad_ipm,
	&m68000_device::cmpa_l_adr32_ad_ipm,
	&m68000_device::cmpa_l_dpc_ad_ipm,
	&m68000_device::cmpa_l_dpci_ad_ipm,
	&m68000_device::cmpa_l_imm32_ad_ipm,
	&m68000_device::and_b_ds_dd_ipm,
	&m68000_device::and_b_ais_dd_ipm,
	&m68000_device::and_b_aips_dd_ipm,
	&m68000_device::and_b_pais_dd_ipm,
	&m68000_device::and_b_das_dd_ipm,
	&m68000_device::and_b_dais_dd_ipm,
	&m68000_device::and_b_adr16_dd_ipm,
	&m68000_device::and_b_adr32_dd_ipm,
	&m68000_device::and_b_dpc_dd_ipm,
	&m68000_device::and_b_dpci_dd_ipm,
	&m68000_device::and_b_imm8_dd_ipm,
	&m68000_device::and_w_ds_dd_ipm,
	&m68000_device::and_w_ais_dd_ipm,
	&m68000_device::and_w_aips_dd_ipm,
	&m68000_device::and_w_pais_dd_ipm,
	&m68000_device::and_w_das_dd_ipm,
	&m68000_device::and_w_dais_dd_ipm,
	&m68000_device::and_w_adr16_dd_ipm,
	&m68000_device::and_w_adr32_dd_ipm,
	&m68000_device::and_w_dpc_dd_ipm,
	&m68000_device::and_w_dpci_dd_ipm,
	&m68000_device::and_w_imm16_dd_ipm,
	&m68000_device::and_l_ds_dd_ipm,
	&m68000_device::and_l_ais_dd_ipm,
	&m68000_device::and_l_aips_dd_ipm,
	&m68000_device::and_l_pais_dd_ipm,
	&m68000_device::and_l_das_dd_ipm,
	&m68000_device::and_l_dais_dd_ipm,
	&m68000_device::and_l_adr16_dd_ipm,
	&m68000_device::and_l_adr32_dd_ipm,
	&m68000_device::and_l_dpc_dd_ipm,
	&m68000_device::and_l_dpci_dd_ipm,
	&m68000_device::and_l_imm32_dd_ipm,
	&m68000_device::mulu_w_ds_dd_ipm,
	&m68000_device::mulu_w_ais_dd_ipm,
	&m68000_device::mulu_w_aips_dd_ipm,
	&m68000_device::mulu_w_pais_dd_ipm,
	&m68000_device::mulu_w_das_dd_ipm,
	&m68000_device::mulu_w_dais_dd_ipm,
	&m68000_device::mulu_w_adr16_dd_ipm,
	&m68000_device::mulu_w_adr32_dd_ipm,
	&m68000_device::mulu_w_dpc_dd_ipm,
	&m68000_device::mulu_w_dpci_dd_ipm,
	&m68000_device::mulu_w_imm16_dd_ipm,
	&m68000_device::abcd_ds_dd_ipm,
	&m68000_device::abcd_pais_paid_ipm,
	&m68000_device::and_b_dd_ais_ipm,
	&m68000_device::and_b_dd_aips_ipm,
	&m68000_device::and_b_dd_pais_ipm,
	&m68000_device::and_b_dd_das_ipm,
	&m68000_device::and_b_dd_dais_ipm,
	&m68000_device::and_b_dd_adr16_ipm,
	&m68000_device::and_b_dd_adr32_ipm,
	&m68000_device::exg_dd_ds_ipm,
	&m68000_device::exg_ad_as_ipm,
	&m68000_device::and_w_dd_ais_ipm,
	&m68000_device::and_w_dd_aips_ipm,
	&m68000_device::and_w_dd_pais_ipm,
	&m68000_device::and_w_dd_das_ipm,
	&m68000_device::and_w_dd_dais_ipm,
	&m68000_device::and_w_dd_adr16_ipm,
	&m68000_device::and_w_dd_adr32_ipm,
	&m68000_device::exg_dd_as_ipm,
	&m68000_device::and_l_dd_ais_ipm,
	&m68000_device::and_l_dd_aips_ipm,
	&m68000_device::and_l_dd_pais_ipm,
	&m68000_device::and_l_dd_das_ipm,
	&m68000_device::and_l_dd_dais_ipm,
	&m68000_device::and_l_dd_adr16_ipm,
	&m68000_device::and_l_dd_adr32_ipm,
	&m68000_device::muls_w_ds_dd_ipm,
	&m68000_device::muls_w_ais_dd_ipm,
	&m68000_device::muls_w_aips_dd_ipm,
	&m68000_device::muls_w_pais_dd_ipm,
	&m68000_device::muls_w_das_dd_ipm,
	&m68000_device::muls_w_dais_dd_ipm,
	&m68000_device::muls_w_adr16_dd_ipm,
	&m68000_device::muls_w_adr32_dd_ipm,
	&m68000_device::muls_w_dpc_dd_ipm,
	&m68000_device::muls_w_dpci_dd_ipm,
	&m68000_device::muls_w_imm16_dd_ipm,
	&m68000_device::add_b_ds_dd_ipm,
	&m68000_device::add_b_ais_dd_ipm,
	&m68000_device::add_b_aips_dd_ipm,
	&m68000_device::add_b_pais_dd_ipm,
	&m68000_device::add_b_das_dd_ipm,
	&m68000_device::add_b_dais_dd_ipm,
	&m68000_device::add_b_adr16_dd_ipm,
	&m68000_device::add_b_adr32_dd_ipm,
	&m68000_device::add_b_dpc_dd_ipm,
	&m68000_device::add_b_dpci_dd_ipm,
	&m68000_device::add_b_imm8_dd_ipm,
	&m68000_device::add_w_ds_dd_ipm,
	&m68000_device::add_w_as_dd_ipm,
	&m68000_device::add_w_ais_dd_ipm,
	&m68000_device::add_w_aips_dd_ipm,
	&m68000_device::add_w_pais_dd_ipm,
	&m68000_device::add_w_das_dd_ipm,
	&m68000_device::add_w_dais_dd_ipm,
	&m68000_device::add_w_adr16_dd_ipm,
	&m68000_device::add_w_adr32_dd_ipm,
	&m68000_device::add_w_dpc_dd_ipm,
	&m68000_device::add_w_dpci_dd_ipm,
	&m68000_device::add_w_imm16_dd_ipm,
	&m68000_device::add_l_ds_dd_ipm,
	&m68000_device::add_l_as_dd_ipm,
	&m68000_device::add_l_ais_dd_ipm,
	&m68000_device::add_l_aips_dd_ipm,
	&m68000_device::add_l_pais_dd_ipm,
	&m68000_device::add_l_das_dd_ipm,
	&m68000_device::add_l_dais_dd_ipm,
	&m68000_device::add_l_adr16_dd_ipm,
	&m68000_device::add_l_adr32_dd_ipm,
	&m68000_device::add_l_dpc_dd_ipm,
	&m68000_device::add_l_dpci_dd_ipm,
	&m68000_device::add_l_imm32_dd_ipm,
	&m68000_device::adda_w_ds_ad_ipm,
	&m68000_device::adda_w_as_ad_ipm,
	&m68000_device::adda_w_ais_ad_ipm,
	&m68000_device::adda_w_aips_ad_ipm,
	&m68000_device::adda_w_pais_ad_ipm,
	&m68000_device::adda_w_das_ad_ipm,
	&m68000_device::adda_w_dais_ad_ipm,
	&m68000_device::adda_w_adr16_ad_ipm,
	&m68000_device::adda_w_adr32_ad_ipm,
	&m68000_device::adda_w_dpc_ad_ipm,
	&m68000_device::adda_w_dpci_ad_ipm,
	&m68000_device::adda_w_imm16_ad_ipm,
	&m68000_device::addx_b_ds_dd_ipm,
	&m68000_device::addx_b_pais_paid_ipm,
	&m68000_device::add_b_dd_ais_ipm,
	&m68000_device::add_b_dd_aips_ipm,
	&m68000_device::add_b_dd_pais_ipm,
	&m68000_device::add_b_dd_das_ipm,
	&m68000_device::add_b_dd_dais_ipm,
	&m68000_device::add_b_dd_adr16_ipm,
	&m68000_device::add_b_dd_adr32_ipm,
	&m68000_device::addx_w_ds_dd_ipm,
	&m68000_device::addx_w_pais_paid_ipm,
	&m68000_device::add_w_dd_ais_ipm,
	&m68000_device::add_w_dd_aips_ipm,
	&m68000_device::add_w_dd_pais_ipm,
	&m68000_device::add_w_dd_das_ipm,
	&m68000_device::add_w_dd_dais_ipm,
	&m68000_device::add_w_dd_adr16_ipm,
	&m68000_device::add_w_dd_adr32_ipm,
	&m68000_device::addx_l_ds_dd_ipm,
	&m68000_device::addx_l_pais_paid_ipm,
	&m68000_device::add_l_dd_ais_ipm,
	&m68000_device::add_l_dd_aips_ipm,
	&m68000_device::add_l_dd_pais_ipm,
	&m68000_device::add_l_dd_das_ipm,
	&m68000_device::add_l_dd_dais_ipm,
	&m68000_device::add_l_dd_adr16_ipm,
	&m68000_device::add_l_dd_adr32_ipm,
	&m68000_device::adda_l_ds_ad_ipm,
	&m68000_device::adda_l_as_ad_ipm,
	&m68000_device::adda_l_ais_ad_ipm,
	&m68000_device::adda_l_aips_ad_ipm,
	&m68000_device::adda_l_pais_ad_ipm,
	&m68000_device::adda_l_das_ad_ipm,
	&m68000_device::adda_l_dais_ad_ipm,
	&m68000_device::adda_l_adr16_ad_ipm,
	&m68000_device::adda_l_adr32_ad_ipm,
	&m68000_device::adda_l_dpc_ad_ipm,
	&m68000_device::adda_l_dpci_ad_ipm,
	&m68000_device::adda_l_imm32_ad_ipm,
	&m68000_device::asr_b_imm3_ds_ipm,
	&m68000_device::lsr_b_imm3_ds_ipm,
	&m68000_device::roxr_b_imm3_ds_ipm,
	&m68000_device::ror_b_imm3_ds_ipm,
	&m68000_device::asr_b_dd_ds_ipm,
	&m68000_device::lsr_b_dd_ds_ipm,
	&m68000_device::roxr_b_dd_ds_ipm,
	&m68000_device::ror_b_dd_ds_ipm,
	&m68000_device::asr_w_imm3_ds_ipm,
	&m68000_device::lsr_w_imm3_ds_ipm,
	&m68000_device::roxr_w_imm3_ds_ipm,
	&m68000_device::ror_w_imm3_ds_ipm,
	&m68000_device::asr_w_dd_ds_ipm,
	&m68000_device::lsr_w_dd_ds_ipm,
	&m68000_device::roxr_w_dd_ds_ipm,
	&m68000_device::ror_w_dd_ds_ipm,
	&m68000_device::asr_l_imm3_ds_ipm,
	&m68000_device::lsr_l_imm3_ds_ipm,
	&m68000_device::roxr_l_imm3_ds_ipm,
	&m68000_device::ror_l_imm3_ds_ipm,
	&m68000_device::asr_l_dd_ds_ipm,
	&m68000_device::lsr_l_dd_ds_ipm,
	&m68000_device::roxr_l_dd_ds_ipm,
	&m68000_device::ror_l_dd_ds_ipm,
	&m68000_device::asr_ais_ipm,
	&m68000_device::asr_aips_ipm,
	&m68000_device::asr_pais_ipm,
	&m68000_device::asr_das_ipm,
	&m68000_device::asr_dais_ipm,
	&m68000_device::asr_adr16_ipm,
	&m68000_device::asr_adr32_ipm,
	&m68000_device::asl_b_imm3_ds_ipm,
	&m68000_device::lsl_b_imm3_ds_ipm,
	&m68000_device::roxl_b_imm3_ds_ipm,
	&m68000_device::rol_b_imm3_ds_ipm,
	&m68000_device::asl_b_dd_ds_ipm,
	&m68000_device::lsl_b_dd_ds_ipm,
	&m68000_device::roxl_b_dd_ds_ipm,
	&m68000_device::rol_b_dd_ds_ipm,
	&m68000_device::asl_w_imm3_ds_ipm,
	&m68000_device::lsl_w_imm3_ds_ipm,
	&m68000_device::roxl_w_imm3_ds_ipm,
	&m68000_device::rol_w_imm3_ds_ipm,
	&m68000_device::asl_w_dd_ds_ipm,
	&m68000_device::lsl_w_dd_ds_ipm,
	&m68000_device::roxl_w_dd_ds_ipm,
	&m68000_device::rol_w_dd_ds_ipm,
	&m68000_device::asl_l_imm3_ds_ipm,
	&m68000_device::lsl_l_imm3_ds_ipm,
	&m68000_device::roxl_l_imm3_ds_ipm,
	&m68000_device::rol_l_imm3_ds_ipm,
	&m68000_device::asl_l_dd_ds_ipm,
	&m68000_device::lsl_l_dd_ds_ipm,
	&m68000_device::roxl_l_dd_ds_ipm,
	&m68000_device::rol_l_dd_ds_ipm,
	&m68000_device::asl_ais_ipm,
	&m68000_device::asl_aips_ipm,
	&m68000_device::asl_pais_ipm,
	&m68000_device::asl_das_ipm,
	&m68000_device::asl_dais_ipm,
	&m68000_device::asl_adr16_ipm,
	&m68000_device::asl_adr32_ipm,
	&m68000_device::lsr_ais_ipm,
	&m68000_device::lsr_aips_ipm,
	&m68000_device::lsr_pais_ipm,
	&m68000_device::lsr_das_ipm,
	&m68000_device::lsr_dais_ipm,
	&m68000_device::lsr_adr16_ipm,
	&m68000_device::lsr_adr32_ipm,
	&m68000_device::lsl_ais_ipm,
	&m68000_device::lsl_aips_ipm,
	&m68000_device::lsl_pais_ipm,
	&m68000_device::lsl_das_ipm,
	&m68000_device::lsl_dais_ipm,
	&m68000_device::lsl_adr16_ipm,
	&m68000_device::lsl_adr32_ipm,
	&m68000_device::roxr_ais_ipm,
	&m68000_device::roxr_aips_ipm,
	&m68000_device::roxr_pais_ipm,
	&m68000_device::roxr_das_ipm,
	&m68000_device::roxr_dais_ipm,
	&m68000_device::roxr_adr16_ipm,
	&m68000_device::roxr_adr32_ipm,
	&m68000_device::roxl_ais_ipm,
	&m68000_device::roxl_aips_ipm,
	&m68000_device::roxl_pais_ipm,
	&m68000_device::roxl_das_ipm,
	&m68000_device::roxl_dais_ipm,
	&m68000_device::roxl_adr16_ipm,
	&m68000_device::roxl_adr32_ipm,
	&m68000_device::ror_ais_ipm,
	&m68000_device::ror_aips_ipm,
	&m68000_device::ror_pais_ipm,
	&m68000_device::ror_das_ipm,
	&m68000_device::ror_dais_ipm,
	&m68000_device::ror_adr16_ipm,
	&m68000_device::ror_adr32_ipm,
	&m68000_device::rol_ais_ipm,
	&m68000_device::rol_aips_ipm,
	&m68000_device::rol_pais_ipm,
	&m68000_device::rol_das_ipm,
	&m68000_device::rol_dais_ipm,
	&m68000_device::rol_adr16_ipm,
	&m68000_device::rol_adr32_ipm,
};
