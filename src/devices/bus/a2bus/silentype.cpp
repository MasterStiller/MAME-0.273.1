// license:BSD-3-Clause
// copyright-holders: Golden Child
/*********************************************************************

    silentype.c

    Implementation of the Apple Silentype Printer

    Useful Resources:


OpenEmulator and its Apple Silentype driver by Marc S. Ressl
(Lots of good info in the OpenEmulator driver)


Apple II Documentation Project:
Apple II Documentation Project/Interface Cards/Serial/Apple Synch Printer Interface Card (Silentype)/

Apple II Documentation Project/Interface Cards/Serial/Apple Synch Printer Interface Card (Silentype)/Source Code/
silendump.c   (Program to dump Silentype Character Set from the ROM)
silendump.txt (Output of dumping Silentype Character Set)
silentype.s   (Silentype Firmware Disassembly by Marc S. Ressl, extremely useful)

(If you assemble this from the disassembly using ca65 or xa, it matches the firmware 341-0039-00.bin)
(It's very useful to have the assembly listing from ca65 with the assembled binary opcodes along with the
cross reference list and symbol table generated by xa65)

to combine the assembly from ca65 with the labellist from xa, just cat them together:
  cat silentype.labels.txt silentype.list.txt > silentype_combo_listing.txt

(Under Ubuntu, you can install xa65 with sudo apt install xa65, and ca65 with sudo apt install ca65)

xa65 needs "* = $C800" in the source.

xa silentype.s -l silentype.labels.txt -r

       -l filename   Set labellist filename, default is none.
       -r            Add cross-reference list to labellist (requires -l).

md5sum a.o65
d6def58f2cacbf00e09a8b624ebfdc07  a.o65

==============================================================================

To assemble with ca65 you need to use ld65 to generate the final output binary.

ca65 needs ".ORG $C800" in the source.

ca65 -v -l silentype.list.txt silentype.s

  -l name       Create a listing file if assembly was ok
  -v            Increase verbosity

The ld65 linker needs a configuration file:

cat ld65_configure_simple.txt
MEMORY {
        ROM3:  start = $C800, size = $800, file = "silentype_output.bin";
       }

SEGMENTS {
            CODE:   load = ROM3, type = ro;
         }

ld65 silentype.o --config ld65_configure_simple.txt -v
Opened `silentype_output.bin'...
  Dumping `ROM3'
    Writing `CODE'

(If you want a disassembly you can use da65)
da65 -S '0xc800' ../silentype_output.bin --comments 3

md5sum silentype_output.bin
d6def58f2cacbf00e09a8b624ebfdc07  silentype_output.bin

===============================================================================

md5sum "Apple Silentype Printer Interface Card ROM - 341-0039-00.bin"
d6def58f2cacbf00e09a8b624ebfdc07  Apple Silentype Printer Interface Card ROM - 341-0039-00.bin

===============================================================================



Apple II Documentation Project/Interface Cards/Serial/Apple Synch Printer Interface Card (Silentype)/Schematics/
Apple Silentype Schematics:
Apple Sync Printer Card - Schematics 050-0024-00.pdf
Apple Sync Printer Card - Schematics 050-0024-01.pdf


Apple II Documentation Project/Peripherals/Printers/Apple Silentype/Photos/
lots of good photos
Apple Silentype - Info 1.jpg  (specs: 60 dpi  6 pixel wide chars * 80 chars = 480 dots across = 8 inches)
                              (actually can do 83 chars across for 498 dots across)
Apple Silentype - Info 2.jpg  (Full Technical Specs: horiz resolution = 60 dots/inch  vertical resolution = 60 dots/inch)

Apple II Documentation Project/Peripherals/Printers/Apple Silentype/Manuals/
Apple Silentype Operation and Reference Manual.pdf

Apple II Documentation Project/Peripherals/Printers/Apple Silentype/Schematics/
Apple Deserializer Driver Printer - Schematics 050-0023-01.pdf
shows the 74LS673 16 bit shift register and how the outputs are connected to the print head, paper drive motor
and the head drive motor.


Apple-Orchard-v1n3-1980-1-Winter.pdf
Inside the Silentype Firmware by J.D. Eisenberg and A.J. Hertzfeld
(The Apple Orchard Winter 1980, p.43)
(There's information in this article that should have been in the Silentype Reference Manual, like how to print
your own bit patterns.  The article has warnings about using the Silentype and the Disk II simultaneously as it will
damage the Apple's power supply.  Perhaps Apple was worried about experimenters damaging their systems.)

1982_02_BYTE_07-02_Winter_Computing.pdf
Double-Width Silentype Graphics for Your Apple by Charles H Putney (Byte Feb 1982, p413)
(Lots of good technical information)

Nibble 1981_v2n6.pdf
Silentype Double Hi-Res Printing by Jenny Schmidt
(Nibble Magazine, V2N6 1981 p.121)


Apple Service Level I Technical Procedures #072 0062 Vol II
https://archive.org/details/AppleServiceLevelITechnicalProcedures0720062VolIIJan1986Ed/page/n29/mode/2up
covers using the Apple II Product Diagnostics Disk to perform diagnostics on the Silentype Printer and Interface.

Disk named "Apple II+ Products diagnostic 652-0334.dsk"

======================================================================


    C0nX: C0n1 is write address, for slot 1 = C091, offset=1, bit 5 = rom enable
          C0n4 is read register, for slot 1 = C094, offset=4, bit 7 = left side head limit switch


    Cn00-CnFF: ROM (First 256 bytes of ROM mirrored here)
    C800-CBFF: ROM 2048 byte ROM
    CF00-CFFF: RAM (256 bytes) switched in/out by bit 5 of data writes to C081

    The ROM in the overlapping RAM/ROM area from CF00-CFFF is only accessed for font table data,
    so the code writes $2C to the write register, setting bit 5 and enabling the rom.  Once it reads the
    font data, it immediately writes a $0C to the write register, disabling the rom again.
    This is the only place in the code that the font data is accessed.

00CC37  1  A9 2C                LDA #$2C
00CC39  1  20 A3 CA             JSR sendStateBit

00CAA3  1               sendStateBit:
00CAA3  1  AE 00 CF             LDX varIOBase
00CAA6  1  9D 81 C0             STA ioBase1,X    ; Write 0x2C, enables rom, bit 5 = 1
00CAA9  1  60                   RTS

00CC3C  1  B1 2A                LDA (textBaseL),Y  ; load our font data
00CC3E  1  48                   PHA
00CC3F  1  A9 0C                LDA #$0C
00CC41  1  9D 81 C0             STA ioBase1,X   ; Write 0x0c, disables rom, bit 5 = 0
00CC44  1  68                   PLA


*********************************************************************/

#include "emu.h"
#include "silentype.h"
#include "video.h"
#include "screen.h"
#include "emuopts.h"
#include "fileio.h"
#include "png.h"

//#include "ex800.lh"
//defines from OpenEmulator

#define SILENTYPE_DATA                  (0)
#define SILENTYPE_SHIFTCLOCKB           (1)  // SHIFT CLOCK (CLOCKED WITH PHI-1)
#define SILENTYPE_STORECLOCK            (2)
#define SILENTYPE_DATAWRITEENABLED      (3)  // OUTPUT ENABLE
#define SILENTYPE_SHIFTCLOCKA           (4)  // LATCHED SHIFT CLOCK
#define SILENTYPE_ROMENABLED            (5)
#define SILENTYPE_SHIFTCLOCKDISABLED    (6)  // SHIFT CLOCK OUTPUT DISABLE

// read bits @ c094
#define SILENTYPE_STATUS                (7)
#define SERIAL_DATA_Q15                 (7)  // shift register Q15 output
#define SERIAL_CLOCK_STATUS             (6)  // current shift clock output, read on A01


/***************************************************************************
    PARAMETERS
***************************************************************************/

//**************************************************************************
//  GLOBAL VARIABLES
//**************************************************************************

DEFINE_DEVICE_TYPE(A2BUS_SILENTYPE,      a2bus_silentype_device, "a2silentype", "Silentype")

#define SILENTYPE_ROM_REGION  "silentype_rom"

ROM_START( silentype )
	ROM_REGION(0x800, SILENTYPE_ROM_REGION, 0)
	ROM_LOAD( "341-0039-00.bin", 0x000000, 0x000800, CRC(bfdcf54d) SHA1(5a133c11b379c5866bcf7fcef902ed2bad415f57))
ROM_END



/***************************************************************************
    FUNCTION PROTOTYPES
***************************************************************************/

//-------------------------------------------------
//  device_add_mconfig - add device configuration
//-------------------------------------------------

void a2bus_silentype_device::device_add_mconfig(machine_config &config)
{
	   /* video hardware (simulates paper) */
		screen_device &screen(SCREEN(config, m_screen, SCREEN_TYPE_RASTER));
		screen.set_refresh_hz(60);
		screen.set_vblank_time(ATTOSECONDS_IN_USEC(0));
		screen.set_size(PAPER_WIDTH, PAPER_SCREEN_HEIGHT);
		screen.set_visarea(0, PAPER_WIDTH-1, 0, PAPER_SCREEN_HEIGHT-1);
		screen.set_screen_update(FUNC(a2bus_silentype_device::screen_update_silentype));

}

//-------------------------------------------------
//  rom_region - device-specific ROM region
//-------------------------------------------------

const tiny_rom_entry *a2bus_silentype_device::device_rom_region() const
{
	return ROM_NAME( silentype );
}


//**************************************************************************
//  LIVE DEVICE
//**************************************************************************

a2bus_silentype_device::a2bus_silentype_device(const machine_config &mconfig, device_type type, const char *tag, device_t *owner, uint32_t clock) :
		device_t(mconfig, type, tag, owner, clock),
		device_a2bus_card_interface(mconfig, *this),
		m_rom(nullptr),
		m_screen(*this, "screen")
{
}

a2bus_silentype_device::a2bus_silentype_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock) :
		a2bus_silentype_device(mconfig, A2BUS_SILENTYPE, tag, owner, clock)
{

}

//-------------------------------------------------
//  device_start - device-specific startup
//-------------------------------------------------

void a2bus_silentype_device::device_start()
{
	m_rom = device().machine().root_device().memregion(this->subtag(SILENTYPE_ROM_REGION).c_str())->base();

	memset(m_ram, 0, 256);

	m_bitmap.allocate(PAPER_WIDTH,PAPER_HEIGHT);  // try 660 pixels for 11 inch long

	m_bitmap.fill(0xffffff); /* Start with a clean white piece of paper */

	save_item(NAME(m_bitmap));
	save_item(NAME(m_ram));
	save_item(NAME(m_xpos));
	save_item(NAME(m_ypos));
	save_item(NAME(right_offset));
	save_item(NAME(left_offset));
	save_item(NAME(heattime));
	save_item(NAME(decaytime));
	save_item(NAME(lastheadbits));
	save_item(NAME(headtemp));
//    save_item(NAME(hstepper));
//    save_item(NAME(vstepper));
	save_item(NAME(hstepperlast));
	save_item(NAME(vstepperlast));
//    save_item(NAME(headbits));
	save_item(NAME(xdirection));
	save_item(NAME(newpageflag));
	save_item(NAME(page_count));
	save_item(NAME(last_update_time));
//    save_item(NAME(time_elapsed));
}

void a2bus_silentype_device::device_reset_after_children()
{
	m_ypos=10;
}

void a2bus_silentype_device::device_reset()
{
	update_pf_stepper(0);
	update_cr_stepper(0);
	update_printhead(0);
}


uint32_t a2bus_silentype_device::screen_update_silentype(screen_device &screen,
							 bitmap_rgb32 &bitmap, const rectangle &cliprect)
{

	int distfrombottom=50;
	int scrolly=bitmap.height()-distfrombottom-(m_ypos*7/4);

	int bottomlinetoclear = std::min(PAPER_HEIGHT-PAPER_SCREEN_HEIGHT,PAPER_HEIGHT);

	m_bitmap.plot_box(0,m_ypos*7/4+10,PAPER_WIDTH,bottomlinetoclear,rgb_t::white());

	copyscrollbitmap(bitmap, m_bitmap, 0, nullptr, 1, &scrolly, cliprect);

	m_bitmap.plot_box(0,0,559,2,0xEEE8AA);  // draw a line on the very top of the bitmap

	bitmap.plot_box(m_xpos-10,bitmap.height()-distfrombottom+10, 20, 30, 0xBDB76B);
	bitmap.plot_box(m_xpos-5, bitmap.height()-distfrombottom+10+5, 10, 20, 0xEEE8AA);

	return 0;
}


/*-------------------------------------------------
  read_c0nx - called for reads from this card's c0nx space
  -------------------------------------------------*/

uint8_t a2bus_silentype_device::read_c0nx(uint8_t offset)
{

	int value=0;
	if (offset==4)
	{
		setbit(value,SILENTYPE_STATUS,(m_xpos<=0));   // set bit 7 if we are at the left edge
		return value;
	}
	else
		return 0x00;
}



void a2bus_silentype_device::write_snapshot_to_file()
{
	// save a snapshot with the slot and page as part of the filename

	emu_file file(machine().options().snapshot_directory()+std::string("/silentype"),
		  OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
	auto const filerr = file.open(std::string("silentype")+
				  std::string("_slot")+
				  std::to_string(slotno())+
				  "_page"+std::to_string(page_count++)+".png");

	if (filerr == osd_file::error::NONE)
	{
		static const rgb_t png_palette[] = { rgb_t::white(), rgb_t::black() };

		// clear paper to bottom
		m_bitmap.plot_box(m_ypos*7/4,3,PAPER_WIDTH-1,PAPER_HEIGHT-1,rgb_t::white());

		// save the paper into a png
		util::png_write_bitmap(file, nullptr, m_bitmap, 2, png_palette);
	}
}


/*-------------------------------------------------
    write_c0nx - called for writes to this card's c0nx space
-------------------------------------------------*/


void a2bus_silentype_device::update_printhead(uint8_t headbits)
{
		printf("PRINTHEAD %x\n",headbits);
		double time_elapsed = machine().time().as_double() - last_update_time;
		last_update_time = machine().time().as_double();

		int intensity = 0;

		for (int i=0;i<7;i++) {
		headtemp[i]= headtemp[i] +
			( (lastheadbits & (1<<i)) ?
				(time_elapsed / ((double) heattime  / 100000)) :
			  - (time_elapsed / ((double) decaytime / 100000)) );
		if (headtemp[i] < 0.0) headtemp[i]=0;
		if (headtemp[i] > 1.0) headtemp[i]=1.0;
		}

		for (int j=0;j<7;j++)
		{
			intensity = headtemp[j]*7.0;
			printf("intensity %x = %x  %f\n",j,intensity,headtemp[j]);

			// to get the left moving  rows and right rows to align, need to do a little fudging
			int xpixel= m_xpos + ((xdirection==1) ? right_offset : left_offset);
			int ypixel= (m_ypos*7/4)+(6-j);
			if ((xpixel>=0) && (xpixel <= (PAPER_WIDTH-1)))
			{
				//darken a pixel based on intensity

//              int pixelval = m_bitmap.pix32(ypixel,xpixel);
				int pixelval = m_bitmap.pix(ypixel,xpixel);
				int darkenval;
				if (intensity == 0) darkenval = 0;
				else darkenval = intensity * 0x222222+0x111111;

				pixelval &= 0xffffff;

				int rp = (pixelval & 0xff0000)>>16;
				int gp = (pixelval & 0x00ff00)>>8;
				int bp = (pixelval & 0x0000ff)>>0;

				int rd = (darkenval & 0xff0000)>>16;
				int gd = (darkenval & 0x00ff00)>>8;
				int bd = (darkenval & 0x0000ff)>>0;

				int r = (rp >= rd) ? rp-rd : 0;
				int g = (gp >= gd) ? gp-gd : 0;
				int b = (bp >= bd) ? bp-bd : 0;

				pixelval = (r<<16)|(g<<8)|(b<<0);

//              m_bitmap.pix32(ypixel,xpixel) = pixelval;
				m_bitmap.pix(ypixel,xpixel) = pixelval;
			}
		}

		lastheadbits = headbits;
}

void a2bus_silentype_device::update_pf_stepper(uint8_t vstepper)
{
		int halfstepflag;
		const int drivetable[4]={3,9,12,6};
		const int halfsteptable[4]={2,4,8,1};

		if (vstepper!=0){

		for(int i=0;i<4;i++)
			{
			if (drivetable[i]==vstepperlast)
				{
				if (drivetable[wrap(i+1,4)]==vstepper)
					// we are moving down the page
					{
					m_ypos+=1;
					if (newpageflag==1) {
						m_ypos=10;  // lock to the top of page until we seek horizontally

					}
					if (m_ypos*7/4>m_bitmap.height()-50)
						// if we are within 50 pixels of the bottom of the page we will
						// write the page to a file, then erase the top part of the page
						// so we can still see the last page printed.
						{
						write_snapshot_to_file();

						newpageflag=1;
						m_ypos=10;

						//m_bitmap.fill(rgb_t::white());
						// clear from beneath the print head to the visible area
						m_bitmap.plot_box(0,
								  3,
								  PAPER_WIDTH,
								  PAPER_HEIGHT-3-PAPER_SCREEN_HEIGHT,
								  rgb_t::white());
						}
					}
				else if (drivetable[wrap(i-1,4)]==vstepper) { m_ypos-=1; }
				}
			}

		// ignore half steps
		halfstepflag=0;
		for (int i=0;i<4;i++) if (halfsteptable[i]==vstepper) halfstepflag=1;

		if (!halfstepflag) vstepperlast=vstepper;
		}
}

void a2bus_silentype_device::update_cr_stepper(uint8_t hstepper)
{
//      printf("CR_STEPPER %x\n",hstepper);
		int halfstepflag;
		const int drivetable[4]={3,9,12,6};
		const int halfsteptable[4]={2,4,8,1};

		if (hstepper!=0){
		newpageflag=0;

		for(int i=0;i<4;i++)
			{if (drivetable[i]==hstepperlast)
				{
				if (drivetable[wrap(i+1,4)]==hstepper)
					{ m_xpos+=1;   xdirection = 1;}
				else if (drivetable[wrap(i-1,4)]==hstepper)
					{ m_xpos-=1;   xdirection = -1;  if (m_xpos < 0) m_xpos=0; }
				}
			}

		// ignore half steps
		halfstepflag=0;
		for (int i=0;i<4;i++) if (halfsteptable[i]==hstepper) halfstepflag=1;

		if (!halfstepflag) hstepperlast=hstepper;
		}
}


void a2bus_silentype_device::write_c0nx(uint8_t offset, uint8_t data)
{
//  printf("WRITE %x = %x\n",offset+slotno()*0x10+0xc080,data);
	m_romenable = BIT(data,SILENTYPE_ROMENABLED) ? 1 : 0;  // should be reversed I think because it's NOT ROMENABLE

	if ((BIT(data,SILENTYPE_SHIFTCLOCKA) == 0) && (BIT(data,SILENTYPE_SHIFTCLOCKB) == 0))
	{
//  printf("CLEAR\n");
		m_shift_reg = 0;
	}
//    else if ((BIT(data,SILENTYPE_SHIFTCLOCKA) == 0) && (BIT(data,SILENTYPE_SHIFTCLOCKB) == 1))
	else if ((BIT(data,SILENTYPE_SHIFTCLOCKA) == 0) && (BIT(data,SILENTYPE_SHIFTCLOCKB) == 1))
	{
//      printf("SHIFT\n");
		m_shift_reg = (m_shift_reg << 1) | BIT(data,SILENTYPE_DATA);
	}
	else if ((BIT(data,SILENTYPE_STORECLOCK) == 0))  // when NOT STORECLOCK, store shift register to parallel register
	{
		m_parallel_reg = m_shift_reg;

		uint8_t hstepperbits = BITS(m_parallel_reg,3,0);
		uint8_t vstepperbits = BITS(m_parallel_reg,7,4);
		uint8_t headbits     = BITS(m_parallel_reg,15,9);

		printf("PARALLEL REGISTER = %x\n",m_parallel_reg);
		update_pf_stepper(vstepperbits);
		update_cr_stepper(hstepperbits);
		update_printhead(headbits);

	}
//  else printf("NONE\n");
}


/*-------------------------------------------------
    read_cnxx - called for reads from this card's cnxx space
-------------------------------------------------*/

uint8_t a2bus_silentype_device::read_cnxx(uint8_t offset)
{
	return m_rom[offset];
}

/*-------------------------------------------------
    write_cnxx - called for writes to this card's cnxx space
-------------------------------------------------*/
void a2bus_silentype_device::write_cnxx(uint8_t offset, uint8_t data)
{
}

/*-------------------------------------------------
    read_c800 - called for reads from this card's c800 space
-------------------------------------------------*/

uint8_t a2bus_silentype_device::read_c800(uint16_t offset)
{
  if ((offset>=0x700) && (!m_romenable)) return m_ram[offset-0x700];
 else   return m_rom[offset];

}

/*-------------------------------------------------
    write_c800 - called for writes to this card's c800 space
-------------------------------------------------*/
void a2bus_silentype_device::write_c800(uint16_t offset, uint8_t data)
{
  if (offset >= 0x700) m_ram[(offset-0x700)] = data;
}

